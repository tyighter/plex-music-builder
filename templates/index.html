<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Plex Playlist Builder</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --plex-orange: #e5a00d;
        --plex-orange-dark: #d48c07;
        --plex-dark: #1a1a1a;
        --plex-gray: #2b2b2b;
        --plex-light: #f5f5f5;
        --card-bg: rgba(34, 34, 34, 0.92);
        --border-radius: 14px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Roboto", sans-serif;
        background: radial-gradient(circle at top, #2a2a2a 0%, #111 70%);
        color: var(--plex-light);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        background: linear-gradient(135deg, var(--plex-dark), #0d0d0d);
        padding: 24px 48px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }

      header h1 {
        margin: 0;
        font-size: 28px;
        letter-spacing: 0.04em;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      header h1 span.icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 42px;
        height: 42px;
        border-radius: 50%;
        background: var(--plex-orange);
        color: #111;
        font-size: 22px;
        box-shadow: 0 8px 20px rgba(229, 160, 13, 0.45);
      }

      .action-bar {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      main {
        flex: 1;
        padding: 32px 48px 64px;
        overflow-y: auto;
      }

      section {
        margin-bottom: 32px;
      }

      h2 {
        margin: 0 0 16px;
        font-size: 22px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      h2 .section-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border-radius: 12px;
        background: rgba(229, 160, 13, 0.2);
        color: var(--plex-orange);
        font-size: 16px;
      }

      .card {
        background: var(--card-bg);
        border-radius: var(--border-radius);
        padding: 20px;
        margin-bottom: 18px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(229, 160, 13, 0.18);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .card:hover {
        transform: translateY(-3px);
        box-shadow: 0 24px 45px rgba(0, 0, 0, 0.55);
      }

      .build-status-panel {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .build-status-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 24px;
        flex-wrap: wrap;
      }

      .status-info {
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex: 1;
      }

      .status-headline {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 18px;
        font-weight: 600;
      }

      .status-text {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .status-indicator {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.35);
        box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.08);
        flex-shrink: 0;
      }

      .status-indicator.running {
        background: #4caf50;
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.25);
      }

      .status-indicator.idle {
        background: #f5c150;
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.25);
      }

      .status-indicator.error {
        background: #e94146;
        box-shadow: 0 0 0 3px rgba(233, 65, 70, 0.3);
      }

      .status-indicator.success {
        background: #3fbf61;
        box-shadow: 0 0 0 3px rgba(63, 191, 97, 0.25);
      }

      .status-indicator.stopped {
        background: #9e9e9e;
        box-shadow: 0 0 0 3px rgba(158, 158, 158, 0.25);
      }

      .status-message {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.75);
      }

      .status-meta {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.6);
      }

      .status-actions {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .status-actions button {
        white-space: nowrap;
      }

      .playlist-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 14px;
        margin-bottom: 18px;
      }

      .playlist-header h3 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
      }

      .playlist-header-title {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
      }

      .playlist-header-actions {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .playlist-status {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
      }

      .playlist-status-text {
        display: flex;
        flex-direction: column;
        gap: 2px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 13px;
        min-width: 0;
      }

      .playlist-status-line {
        font-size: 14px;
        font-weight: 500;
        color: var(--plex-light);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .playlist-status-message {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.55);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .playlist-build-btn {
        white-space: nowrap;
      }

      .input-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 12px;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.8);
      }

      input[type="text"],
      input[type="number"],
      select,
      textarea {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(229, 160, 13, 0.25);
        background: rgba(17, 17, 17, 0.6);
        color: var(--plex-light);
        font-size: 15px;
        transition: border 0.2s ease, box-shadow 0.2s ease;
      }

      input:focus,
      select:focus,
      textarea:focus {
        outline: none;
        border-color: var(--plex-orange);
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.25);
      }

      textarea {
        min-height: 42px;
        resize: vertical;
      }

      .filter-row {
        display: grid;
        grid-template-columns: 1.1fr 1fr 1fr auto;
        gap: 12px;
        align-items: center;
        margin-bottom: 10px;
      }

      .filter-row .value-input {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .filter-row .value-input input {
        flex: 1;
      }

      .filter-row .match-all {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.7);
      }

      .path-input {
        position: relative;
        display: flex;
        flex-direction: column;
      }

      .path-suggestions {
        position: absolute;
        top: calc(100% + 6px);
        left: 0;
        right: 0;
        background: rgba(18, 18, 18, 0.95);
        border: 1px solid rgba(229, 160, 13, 0.25);
        border-radius: 10px;
        box-shadow: 0 18px 32px rgba(0, 0, 0, 0.45);
        max-height: 220px;
        overflow-y: auto;
        display: none;
        flex-direction: column;
        z-index: 20;
      }

      .path-suggestions.show {
        display: flex;
      }

      .path-suggestions button {
        background: transparent;
        border: none;
        text-align: left;
        padding: 10px 12px;
        color: var(--plex-light);
        font-size: 14px;
        cursor: pointer;
        transition: background 0.15s ease;
      }

      .path-suggestions button:hover {
        background: rgba(229, 160, 13, 0.18);
      }

      .button,
      button {
        cursor: pointer;
        border: none;
        border-radius: 999px;
        padding: 10px 18px;
        font-size: 15px;
        font-weight: 500;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: #111;
        background: var(--plex-orange);
        transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 12px 24px rgba(229, 160, 13, 0.35);
      }

      button.secondary {
        background: rgba(229, 160, 13, 0.16);
        color: var(--plex-light);
        box-shadow: none;
        border: 1px solid rgba(229, 160, 13, 0.35);
      }

      button.danger {
        background: rgba(229, 65, 70, 0.85);
        color: #fff;
        box-shadow: 0 12px 24px rgba(229, 65, 70, 0.45);
      }

      button.icon-only {
        padding: 8px;
        border-radius: 12px;
        width: 36px;
        height: 36px;
        justify-content: center;
      }

      button:hover {
        transform: translateY(-1px);
      }

      button:active {
        transform: translateY(0);
      }

      .filters-container {
        border: 1px dashed rgba(229, 160, 13, 0.25);
        border-radius: 12px;
        padding: 16px;
        background: rgba(14, 14, 14, 0.55);
      }

      .build-status-logs {
        padding: 16px;
        border-radius: 12px;
        background: linear-gradient(135deg, rgba(20, 20, 20, 0.85), rgba(12, 12, 12, 0.9));
        border: 1px solid rgba(229, 160, 13, 0.18);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
        transition: box-shadow 0.3s ease;
      }

      .build-status-panel.running .build-status-logs {
        box-shadow: inset 0 0 0 1px rgba(229, 160, 13, 0.2), 0 10px 30px rgba(229, 160, 13, 0.12);
      }

      .playlist-log-header {
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.55);
      }

      .playlist-log-list {
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .playlist-log-entry {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 12px 14px;
        border-radius: 10px;
        background: rgba(229, 160, 13, 0.08);
        border: 1px solid rgba(229, 160, 13, 0.18);
        position: relative;
        overflow: hidden;
      }

      .playlist-log-entry::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at top right, rgba(229, 160, 13, 0.18), transparent 55%);
        pointer-events: none;
        opacity: 0.6;
      }

      .build-status-panel.running .playlist-log-entry::after {
        animation: filteringGlow 2.2s ease-in-out infinite;
      }

      .playlist-log-bar {
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: rgba(229, 160, 13, 0.16);
        overflow: hidden;
        position: relative;
      }

      .playlist-log-bar span {
        display: block;
        height: 100%;
        width: var(--progress, 0%);
        background: linear-gradient(90deg, var(--plex-orange), #ffce4a);
        box-shadow: 0 0 12px rgba(229, 160, 13, 0.4);
        transition: width 0.35s ease;
      }

      .build-status-panel.running .playlist-log-bar span {
        animation: filteringPulse 1.8s ease-in-out infinite;
      }

      .playlist-log-text {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.85);
        position: relative;
        z-index: 1;
      }

      .playlist-log-empty {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.55);
      }

      .playlist-log-entry.general-entry {
        background: rgba(120, 120, 120, 0.18);
        border-color: rgba(255, 255, 255, 0.16);
      }

      .playlist-log-entry.general-entry::after {
        background: radial-gradient(
          circle at top right,
          rgba(255, 255, 255, 0.18),
          transparent 55%
        );
      }

      .build-log-list {
        margin-top: 16px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .build-log-playlist {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .build-log-playlist-title {
        font-size: 15px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.78);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .build-log-playlist-title::before {
        content: "";
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: rgba(229, 160, 13, 0.6);
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.12);
      }

      .build-log-playlist.is-active .build-log-playlist-title::before {
        background: #4caf50;
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.25);
      }

      .build-log-playlist-entries {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      @keyframes filteringPulse {
        0% {
          filter: brightness(0.95);
        }
        50% {
          filter: brightness(1.2);
        }
        100% {
          filter: brightness(0.95);
        }
      }

      @keyframes filteringGlow {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 0.9;
        }
      }

      .no-filters {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 12px;
      }

      .message {
        margin-left: auto;
        padding: 10px 16px;
        border-radius: 999px;
        font-size: 14px;
        background: rgba(229, 160, 13, 0.2);
        color: var(--plex-light);
        display: none;
      }

      .message.show {
        display: inline-flex;
      }

      @media (max-width: 960px) {
        main {
          padding: 24px;
        }

        header {
          flex-direction: column;
          align-items: flex-start;
          gap: 16px;
        }

        .playlist-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 12px;
        }

        .playlist-header-actions {
          width: 100%;
          align-items: flex-start;
        }

        .playlist-status {
          width: 100%;
        }

        .playlist-status-line,
        .playlist-status-message {
          white-space: normal;
        }

        .filter-row {
          grid-template-columns: 1fr;
        }

        .filter-row .match-all {
          justify-content: flex-start;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1><span class="icon">▶</span>Plex Playlist Builder</h1>
      <div class="action-bar">
        <button id="reloadBtn" class="secondary" type="button">⟳ Refresh from File</button>
        <button id="clearAllmusicCacheBtn" class="secondary" type="button">🧹 Clear AllMusic Cache</button>
        <button id="saveBtn" type="button">💾 Save to playlists.yml</button>
        <span id="message" class="message"></span>
      </div>
    </header>
    <main>
      <section>
        <h2><span class="section-icon">🛠</span>Build Status</h2>
        <div id="buildStatusPanel" class="card build-status-panel">
          <div class="build-status-header">
            <div class="status-info">
              <div class="status-headline">
                <span id="buildStatusIndicator" class="status-indicator idle"></span>
                <div class="status-text">
                  <div id="buildStatusText">Checking build status…</div>
                  <div id="buildStatusMessage" class="status-message"></div>
                </div>
              </div>
              <div id="buildStatusMeta" class="status-meta"></div>
            </div>
            <div class="status-actions">
              <button id="buildToggleBtn" type="button">▶ Build All</button>
            </div>
          </div>
          <div class="build-status-logs">
            <div class="playlist-log-header">Playlist Activity</div>
            <div id="buildLogContainer" class="build-log-list"></div>
          </div>
        </div>
      </section>

      <section>
        <h2><span class="section-icon">⚙</span>Default Plex Filters</h2>
        <div class="card">
          <div id="defaultFilters" class="filters-container"></div>
          <button id="addDefaultFilter" class="secondary" type="button">＋ Add Default Filter</button>
        </div>
      </section>

      <section>
        <div class="playlist-header">
          <h2><span class="section-icon">🎵</span>Playlists</h2>
          <button id="addPlaylist" type="button">＋ Add Playlist</button>
        </div>
        <div id="playlistsContainer"></div>
      </section>
    </main>

    <script>
      const state = {
        defaults: { plex_filter: [], extras: {} },
        playlists: [],
      };

      let options = {
        fields: [],
        operators: [],
        sort_fields: [],
      };

      const messageEl = document.getElementById("message");
      const playlistsContainer = document.getElementById("playlistsContainer");
      const defaultFiltersContainer = document.getElementById("defaultFilters");
      const buildStatusIndicator = document.getElementById("buildStatusIndicator");
      const buildStatusText = document.getElementById("buildStatusText");
      const buildStatusMessage = document.getElementById("buildStatusMessage");
      const buildStatusMeta = document.getElementById("buildStatusMeta");
      const buildToggleBtn = document.getElementById("buildToggleBtn");
      const buildStatusPanel = document.getElementById("buildStatusPanel");
      const buildLogContainer = document.getElementById("buildLogContainer");
      let latestBuildStatus = null;
      let buildStatusTimer = null;

      function showMessage(text, isError = false) {
        if (!text) {
          messageEl.classList.remove("show");
          return;
        }
        messageEl.textContent = text;
        messageEl.style.background = isError
          ? "rgba(229, 65, 70, 0.25)"
          : "rgba(229, 160, 13, 0.2)";
        messageEl.classList.add("show");
        setTimeout(() => messageEl.classList.remove("show"), 4000);
      }

      function formatTimestamp(isoString) {
        if (!isoString) {
          return "";
        }
        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return isoString;
        }
        return `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
      }

      function updatePlaylistBuildUi(playlist) {
        if (!playlist || !playlist._statusElements) {
          return;
        }

        const { indicator, line, message, button } = playlist._statusElements;
        const playlistName = (playlist.name || "").trim();
        const status = latestBuildStatus;
        const activeJob = status?.job || null;
        const activePlaylistName =
          activeJob && activeJob.type === "playlist"
            ? (activeJob.playlist || "")
            : "";

        const isRunningThisPlaylist = Boolean(
          status?.running &&
            activeJob?.type === "playlist" &&
            playlistName &&
            activePlaylistName === playlistName
        );
        const isAllRunning = Boolean(status?.running && activeJob?.type === "all");
        const otherJobRunning = Boolean(
          status?.running &&
            !isRunningThisPlaylist &&
            (isAllRunning ||
              (activeJob?.type === "playlist" && activePlaylistName !== playlistName))
        );

        const playlistResults = status?.results?.playlists || {};
        const lastResult = playlistName ? playlistResults[playlistName] : undefined;

        let indicatorState = "idle";
        if (isRunningThisPlaylist) {
          indicatorState = "running";
        } else if (lastResult) {
          if (lastResult.state === "success") {
            indicatorState = "success";
          } else if (lastResult.state === "error") {
            indicatorState = "error";
          } else if (lastResult.state === "stopped") {
            indicatorState = "stopped";
          }
        } else {
          indicatorState = "idle";
        }

        indicator.classList.remove("running", "idle", "error", "success", "stopped");
        indicator.classList.add(indicatorState);

        let statusLineText = playlistName ? "Not built yet" : "Name required to build";
        if (isRunningThisPlaylist) {
          statusLineText = "Building now…";
        } else if (isAllRunning) {
          statusLineText = "All playlists build running";
        } else if (otherJobRunning) {
          if (activeJob?.type === "playlist" && activePlaylistName) {
            statusLineText = `Waiting – '${activePlaylistName}' is building`;
          } else {
            statusLineText = "Waiting – build in progress";
          }
        } else if (lastResult) {
          if (lastResult.state === "success") {
            statusLineText = "Last build succeeded";
          } else if (lastResult.state === "stopped") {
            statusLineText = "Last build stopped";
          } else if (lastResult.state === "error") {
            statusLineText = "Last build failed";
          }
        }
        line.textContent = statusLineText;

        const detailParts = [];
        if (isRunningThisPlaylist) {
          if (status?.message) {
            detailParts.push(status.message);
          }
          if (status?.since) {
            detailParts.push(`Started ${formatTimestamp(status.since)}`);
          }
        } else if (otherJobRunning) {
          if (isAllRunning) {
            detailParts.push("Currently building all playlists");
          } else if (activePlaylistName) {
            detailParts.push(`Currently building '${activePlaylistName}'`);
          }
        } else if (lastResult) {
          if (lastResult.message) {
            detailParts.push(lastResult.message);
          }
          if (lastResult.finished_at) {
            detailParts.push(`Finished ${formatTimestamp(lastResult.finished_at)}`);
          }
        }
        message.textContent = detailParts.join(" • ");

        if (isRunningThisPlaylist) {
          button.textContent = "⏹ Stop Build";
          button.classList.add("danger");
        } else {
          button.textContent = "▶ Build Playlist";
          button.classList.remove("danger");
        }

        const disableButton = !playlistName || (status?.running && !isRunningThisPlaylist);
        button.disabled = Boolean(disableButton);
        if (!playlistName) {
          button.title = "Enter a playlist name to build it individually.";
        } else if (status?.running && !isRunningThisPlaylist) {
          if (isAllRunning) {
            button.title = "Building all playlists. Please wait.";
          } else if (activePlaylistName) {
            button.title = `Building '${activePlaylistName}'. Please wait.`;
          } else {
            button.title = "Another build is currently running.";
          }
        } else {
          button.title = "";
        }

      }

      function updateBuildLogsUi(status) {
        if (!buildStatusPanel || !buildLogContainer) {
          return;
        }

        const running = Boolean(status?.running);
        const activeJob = status?.job || null;
        const activePlaylistName =
          running && activeJob?.type === "playlist"
            ? (activeJob.playlist || "").trim()
            : "";

        buildStatusPanel.classList.toggle("running", running);

        const logsByPlaylist = status?.logs?.playlists || {};
        const generalLogs = status?.logs?.general || [];

        const playlistNames = Object.keys(logsByPlaylist).filter(
          (name) => name && name.trim()
        );
        if (activePlaylistName && !playlistNames.includes(activePlaylistName)) {
          playlistNames.push(activePlaylistName);
        }

        playlistNames.sort((a, b) => a.localeCompare(b));

        buildLogContainer.innerHTML = "";

        let renderedGroups = 0;

        playlistNames.forEach((name) => {
          const trimmedName = name.trim();
          const entries = logsByPlaylist[name] || [];
          if (!entries.length && !running) {
            return;
          }

          renderedGroups += 1;
          const block = document.createElement("div");
          block.className = "build-log-playlist";
          if (running && trimmedName === activePlaylistName) {
            block.classList.add("is-active");
          }

          const title = document.createElement("div");
          title.className = "build-log-playlist-title";
          title.textContent = trimmedName || "Unnamed Playlist";
          block.appendChild(title);

          const listEl = document.createElement("div");
          listEl.className = "build-log-playlist-entries";

          if (entries.length) {
            entries.forEach((entry, index) => {
              const item = document.createElement("div");
              item.className = "playlist-log-entry";

              const progressWrapper = document.createElement("div");
              progressWrapper.className = "playlist-log-bar";
              const progressFill = document.createElement("span");
              const progressValue = ((index + 1) / entries.length) * 100;
              progressFill.style.setProperty("--progress", `${progressValue}%`);
              progressWrapper.appendChild(progressFill);

              const text = document.createElement("div");
              text.className = "playlist-log-text";
              text.textContent = entry;

              item.appendChild(progressWrapper);
              item.appendChild(text);
              listEl.appendChild(item);
            });
          } else {
            const empty = document.createElement("div");
            empty.className = "playlist-log-empty";
            empty.textContent = running
              ? "Waiting for playlist activity…"
              : "No recent activity.";
            listEl.appendChild(empty);
          }

          block.appendChild(listEl);
          buildLogContainer.appendChild(block);
        });

        if (generalLogs.length) {
          renderedGroups += 1;
          const block = document.createElement("div");
          block.className = "build-log-playlist";
          const title = document.createElement("div");
          title.className = "build-log-playlist-title";
          title.textContent = "General Activity";
          block.appendChild(title);

          const listEl = document.createElement("div");
          listEl.className = "build-log-playlist-entries";

          generalLogs.slice(-40).forEach((entry) => {
            const item = document.createElement("div");
            item.className = "playlist-log-entry general-entry";
            const text = document.createElement("div");
            text.className = "playlist-log-text";
            text.textContent = entry;
            item.appendChild(text);
            listEl.appendChild(item);
          });

          block.appendChild(listEl);
          buildLogContainer.appendChild(block);
        }

        if (!renderedGroups) {
          const empty = document.createElement("div");
          empty.className = "playlist-log-empty";
          empty.textContent = running
            ? "Waiting for playlist activity…"
            : "No playlist activity recorded yet.";
          buildLogContainer.appendChild(empty);
        }
      }

      function updateBuildStatusUi(status) {
        if (!status) {
          return;
        }

        latestBuildStatus = status;
        updateBuildLogsUi(status);
        const isRunning = Boolean(status.running);
        const activeJob = status.job || null;
        const isAllRunning = Boolean(isRunning && activeJob?.type === "all");
        const isPlaylistRunning = Boolean(isRunning && activeJob?.type === "playlist");
        const indicatorState = isRunning
          ? "running"
          : status.status === "error"
          ? "error"
          : "idle";

        buildStatusIndicator.classList.remove("running", "idle", "error");
        buildStatusIndicator.classList.add(indicatorState);

        let statusTextValue = "Builder is idle";
        if (isRunning) {
          if (isAllRunning) {
            statusTextValue = "Building all playlists";
          } else if (isPlaylistRunning && activeJob?.playlist) {
            statusTextValue = `Building "${activeJob.playlist}"`;
          } else {
            statusTextValue = "Build in progress";
          }
        } else if (status.status === "error") {
          statusTextValue = "Build encountered an issue";
        }
        buildStatusText.textContent = statusTextValue;
        buildStatusMessage.textContent = status.message || "";

        const metaParts = [];
        if (isRunning && status.pid) {
          metaParts.push(`PID ${status.pid}`);
        }
        if (isRunning && status.since) {
          metaParts.push(`Started ${formatTimestamp(status.since)}`);
        }
        if (isPlaylistRunning && activeJob?.playlist) {
          metaParts.push(`Playlist '${activeJob.playlist}'`);
        }
        if (!isRunning) {
          const lastAllResult = status.results?.all;
          const lastFinishedIso = status.last_finished;
          if (
            lastAllResult?.finished_at &&
            (!lastFinishedIso || lastAllResult.finished_at === lastFinishedIso)
          ) {
            let label = "Last build finished";
            if (lastAllResult.state === "success") {
              label = "Last build completed";
            } else if (lastAllResult.state === "stopped") {
              label = "Last build stopped";
            } else if (lastAllResult.state === "error") {
              label = "Last build failed";
            }
            metaParts.push(`${label} ${formatTimestamp(lastAllResult.finished_at)}`);
          } else if (status.last_finished) {
            metaParts.push(`Last finished ${formatTimestamp(status.last_finished)}`);
          }
          if (typeof status.exit_code === "number") {
            metaParts.push(`Last exit code ${status.exit_code}`);
          }
        }
        buildStatusMeta.textContent = metaParts.join(" • ");

        buildToggleBtn.textContent = isAllRunning ? "⏹ Stop All" : "▶ Build All";
        buildToggleBtn.classList.toggle("danger", isAllRunning);
        buildToggleBtn.disabled = Boolean(status.transitioning || (isRunning && !isAllRunning));
        buildToggleBtn.title = isRunning && !isAllRunning ? "A playlist build is currently running." : "";

        if (Array.isArray(state.playlists)) {
          state.playlists.forEach((playlist) => updatePlaylistBuildUi(playlist));
        }
      }

      async function refreshBuildStatus(showErrors = false) {
        try {
          const response = await fetch("/api/build/status");
          if (!response.ok) {
            throw new Error("Unable to retrieve build status");
          }
          const status = await response.json();
          updateBuildStatusUi(status);
        } catch (error) {
          console.error(error);
          if (showErrors) {
            showMessage(error.message, true);
          }
        }
      }

      async function toggleBuild() {
        const isRunningAll = Boolean(
          latestBuildStatus?.running && latestBuildStatus?.job?.type === "all"
        );
        const anotherJobRunning = Boolean(
          latestBuildStatus?.running && !isRunningAll
        );
        if (anotherJobRunning) {
          showMessage("A playlist build is currently running. Stop it before starting a full build.", true);
          return;
        }

        const endpoint = isRunningAll ? "/api/build/stop" : "/api/build/start";

        buildToggleBtn.disabled = true;
        try {
          const response = await fetch(endpoint, { method: "POST" });
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(
              result.message ||
                (isRunningAll ? "Failed to stop build." : "Failed to start build.")
            );
          }

          if (result.status) {
            updateBuildStatusUi(result.status);
          } else {
            await refreshBuildStatus();
          }

          if (result.message) {
            showMessage(result.message, false);
          } else {
            showMessage(isRunningAll ? "Build stopping..." : "Build starting...");
          }

          setTimeout(() => {
            refreshBuildStatus();
          }, 1000);
        } catch (error) {
          console.error(error);
          showMessage(error.message, true);
        } finally {
          buildToggleBtn.disabled = false;
        }
      }

      async function togglePlaylistBuild(playlist) {
        const playlistName = (playlist?.name || "").trim();
        if (!playlistName) {
          showMessage("Please name the playlist before building it.", true);
          return;
        }

        const isRunningThisPlaylist = Boolean(
          latestBuildStatus?.running &&
            latestBuildStatus?.job?.type === "playlist" &&
            latestBuildStatus?.job?.playlist === playlistName
        );

        if (
          !isRunningThisPlaylist &&
          latestBuildStatus?.running &&
          latestBuildStatus?.job?.type === "all"
        ) {
          showMessage(
            "Can't start an individual build while all playlists are building.",
            true
          );
          return;
        }

        const elements = playlist._statusElements || {};
        if (elements.button) {
          elements.button.disabled = true;
        }

        const endpoint = isRunningThisPlaylist ? "/api/build/stop" : "/api/build/start";
        const options = { method: "POST" };
        if (!isRunningThisPlaylist) {
          options.headers = { "Content-Type": "application/json" };
          options.body = JSON.stringify({ playlist: playlistName });
        }

        try {
          const response = await fetch(endpoint, options);
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(
              result.message ||
                (isRunningThisPlaylist
                  ? "Failed to stop playlist build."
                  : "Failed to start playlist build.")
            );
          }

          if (result.status) {
            updateBuildStatusUi(result.status);
          } else {
            await refreshBuildStatus();
          }

          if (result.message) {
            showMessage(result.message);
          } else {
            showMessage(
              isRunningThisPlaylist
                ? `Stopping '${playlistName}'...`
                : `Starting '${playlistName}'...`
            );
          }

          setTimeout(() => {
            refreshBuildStatus();
          }, 1000);
        } catch (error) {
          console.error(error);
          showMessage(error.message, true);
        } finally {
          if (elements.button) {
            elements.button.disabled = false;
          }
          updatePlaylistBuildUi(playlist);
        }
      }

      function ensureExtras(target) {
        if (!target.extras || typeof target.extras !== "object") {
          target.extras = {};
        }
        return target.extras;
      }

      function sanitizeExtras(extras) {
        const sanitized = {};
        Object.entries(extras || {}).forEach(([key, value]) => {
          if (value === undefined || value === null) {
            return;
          }
          const trimmed = String(value).trim();
          if (trimmed) {
            sanitized[key] = trimmed;
          }
        });
        return sanitized;
      }

      function setupPathAutocomplete(inputEl, suggestionsEl, playlist, extrasKey) {
        const extras = ensureExtras(playlist);
        let debounceTimer = null;
        let controller = null;

        function hideSuggestions() {
          suggestionsEl.classList.remove("show");
          suggestionsEl.innerHTML = "";
        }

        function renderSuggestions(entries) {
          if (!entries.length) {
            hideSuggestions();
            return;
          }
          suggestionsEl.innerHTML = "";
          entries.forEach((entry) => {
            const optionBtn = document.createElement("button");
            optionBtn.type = "button";
            optionBtn.textContent = entry.display;
            optionBtn.addEventListener("mousedown", (event) => {
              event.preventDefault();
              const suggestion = entry.suggestion;
              inputEl.value = suggestion;
              extras[extrasKey] = suggestion;
              hideSuggestions();
            });
            suggestionsEl.appendChild(optionBtn);
          });
          suggestionsEl.classList.add("show");
        }

        async function requestSuggestions(value) {
          if (controller) {
            controller.abort();
          }

          controller = new AbortController();
          const { signal } = controller;

          const params = new URLSearchParams();
          if (value) {
            params.set("path", value);
          }
          const query = params.toString();
          const url = query
            ? `/api/list_directory?${query}`
            : "/api/list_directory";

          try {
            const response = await fetch(url, {
              signal,
            });
            if (!response.ok) {
              throw new Error("Unable to fetch directory suggestions");
            }
            const data = await response.json();
            if (signal.aborted) {
              return;
            }
            renderSuggestions(data.entries || []);
          } catch (error) {
            if (signal.aborted) {
              return;
            }
            console.error(error);
            hideSuggestions();
          }
        }

        function scheduleSuggestions(value) {
          if (debounceTimer) {
            clearTimeout(debounceTimer);
          }
          debounceTimer = setTimeout(() => {
            requestSuggestions(value);
          }, 180);
        }

        inputEl.addEventListener("input", (event) => {
          const value = event.target.value;
          extras[extrasKey] = value;
          scheduleSuggestions(value);
        });

        inputEl.addEventListener("focus", () => {
          scheduleSuggestions(inputEl.value);
        });

        inputEl.addEventListener("blur", () => {
          setTimeout(hideSuggestions, 150);
        });
      }

      function createOptionElements(selectEl, opts, selectedValue = "") {
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select...";
        selectEl.appendChild(placeholder);

        opts.forEach((opt) => {
          const option = document.createElement("option");
          option.value = opt.value;
          option.textContent = opt.label;
          if (opt.value === selectedValue) {
            option.selected = true;
          }
          selectEl.appendChild(option);
        });
      }

      function renderFilters(containerEl, filters, onRemove) {
        containerEl.innerHTML = "";

        if (!filters.length) {
          const emptyState = document.createElement("p");
          emptyState.className = "no-filters";
          emptyState.textContent = "No filters configured.";
          containerEl.appendChild(emptyState);
        }

        filters.forEach((filter, index) => {
          const row = document.createElement("div");
          row.className = "filter-row";

          const fieldSelect = document.createElement("select");
          createOptionElements(fieldSelect, options.fields, filter.field || "");
          fieldSelect.value = filter.field || "";
          fieldSelect.addEventListener("change", (event) => {
            filter.field = event.target.value;
          });

          const operatorSelect = document.createElement("select");
          createOptionElements(operatorSelect, options.operators, filter.operator || "equals");
          operatorSelect.value = filter.operator || "";
          operatorSelect.addEventListener("change", (event) => {
            filter.operator = event.target.value;
          });

          const valueWrapper = document.createElement("div");
          valueWrapper.className = "value-input";
          const valueInput = document.createElement("input");
          valueInput.type = "text";
          valueInput.placeholder = "Value (comma separated for multiple)";
          valueInput.value = filter.value || "";
          valueInput.addEventListener("input", (event) => {
            filter.value = event.target.value;
          });

          const matchAllLabel = document.createElement("label");
          matchAllLabel.className = "match-all";
          const matchAllInput = document.createElement("input");
          matchAllInput.type = "checkbox";
          matchAllInput.checked = filter.match_all !== undefined ? !!filter.match_all : true;
          matchAllInput.addEventListener("change", (event) => {
            filter.match_all = event.target.checked;
          });
          matchAllLabel.appendChild(matchAllInput);
          matchAllLabel.appendChild(document.createTextNode("Match all values"));
          valueWrapper.appendChild(valueInput);
          valueWrapper.appendChild(matchAllLabel);

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "icon-only danger";
          removeBtn.textContent = "✕";
          removeBtn.title = "Remove filter";
          removeBtn.addEventListener("click", () => onRemove(index));

          row.appendChild(fieldSelect);
          row.appendChild(operatorSelect);
          row.appendChild(valueWrapper);
          row.appendChild(removeBtn);

          containerEl.appendChild(row);
        });
      }

      function renderPlaylists() {
        playlistsContainer.innerHTML = "";

        if (!state.playlists.length) {
          const empty = document.createElement("p");
          empty.className = "no-filters";
          empty.textContent = "No playlists yet. Add one to get started.";
          playlistsContainer.appendChild(empty);
          return;
        }

        state.playlists.forEach((playlist, index) => {
          const card = document.createElement("div");
          card.className = "card";

          const header = document.createElement("div");
          header.className = "playlist-header";

          const titleWrapper = document.createElement("div");
          titleWrapper.className = "playlist-header-title";
          const title = document.createElement("h3");
          title.textContent = playlist.name || "Untitled Playlist";
          titleWrapper.appendChild(title);

          const headerActions = document.createElement("div");
          headerActions.className = "playlist-header-actions";

          const statusGroup = document.createElement("div");
          statusGroup.className = "playlist-status";

          const statusIndicator = document.createElement("span");
          statusIndicator.className = "status-indicator idle";

          const statusTextWrapper = document.createElement("div");
          statusTextWrapper.className = "playlist-status-text";

          const statusLine = document.createElement("div");
          statusLine.className = "playlist-status-line";
          statusLine.textContent = "Not built yet";

          const statusMessage = document.createElement("div");
          statusMessage.className = "playlist-status-message";

          statusTextWrapper.appendChild(statusLine);
          statusTextWrapper.appendChild(statusMessage);
          statusGroup.appendChild(statusIndicator);
          statusGroup.appendChild(statusTextWrapper);

          const buildBtn = document.createElement("button");
          buildBtn.type = "button";
          buildBtn.className = "playlist-build-btn secondary";
          buildBtn.textContent = "▶ Build Playlist";
          buildBtn.addEventListener("click", () => togglePlaylistBuild(playlist));

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "icon-only danger";
          removeBtn.textContent = "✕";
          removeBtn.title = "Delete playlist";
          removeBtn.addEventListener("click", () => {
            delete playlist._statusElements;
            state.playlists.splice(index, 1);
            renderPlaylists();
          });

          headerActions.appendChild(statusGroup);
          headerActions.appendChild(buildBtn);
          headerActions.appendChild(removeBtn);

          header.appendChild(titleWrapper);
          header.appendChild(headerActions);
          card.appendChild(header);

          const extras = ensureExtras(playlist);

          playlist._statusElements = {
            indicator: statusIndicator,
            line: statusLine,
            message: statusMessage,
            button: buildBtn,
          };
          updatePlaylistBuildUi(playlist);

          const grid = document.createElement("div");
          grid.className = "input-grid";

          const nameLabel = document.createElement("label");
          nameLabel.textContent = "Playlist Name";
          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.value = playlist.name || "";
          nameInput.addEventListener("input", (event) => {
            playlist.name = event.target.value;
            title.textContent = event.target.value || "Untitled Playlist";
            updatePlaylistBuildUi(playlist);
          });
          nameLabel.appendChild(nameInput);

          const limitLabel = document.createElement("label");
          limitLabel.textContent = "Limit";
          const limitInput = document.createElement("input");
          limitInput.type = "number";
          limitInput.min = "0";
          limitInput.value = playlist.limit ?? 0;
          limitInput.addEventListener("input", (event) => {
            playlist.limit = event.target.value;
          });
          limitLabel.appendChild(limitInput);

          const artistLimitLabel = document.createElement("label");
          artistLimitLabel.textContent = "Artist Limit";
          const artistLimitInput = document.createElement("input");
          artistLimitInput.type = "number";
          artistLimitInput.min = "0";
          artistLimitInput.value = playlist.artist_limit ?? 0;
          artistLimitInput.addEventListener("input", (event) => {
            playlist.artist_limit = event.target.value;
          });
          artistLimitLabel.appendChild(artistLimitInput);

          const albumLimitLabel = document.createElement("label");
          albumLimitLabel.textContent = "Album Limit";
          const albumLimitInput = document.createElement("input");
          albumLimitInput.type = "number";
          albumLimitInput.min = "0";
          albumLimitInput.value = playlist.album_limit ?? 0;
          albumLimitInput.addEventListener("input", (event) => {
            playlist.album_limit = event.target.value;
          });
          albumLimitLabel.appendChild(albumLimitInput);

          const sortLabel = document.createElement("label");
          sortLabel.textContent = "Sort By";
          const sortSelect = document.createElement("select");
          const sortFieldValues = options.sort_fields.map((opt) => opt.value);
          if (
            (!playlist.sort_by || !sortFieldValues.includes(playlist.sort_by)) &&
            options.sort_fields.length
          ) {
            playlist.sort_by = options.sort_fields[0].value;
          }
          options.sort_fields.forEach((opt) => {
            const option = document.createElement("option");
            option.value = opt.value;
            option.textContent = opt.label;
            sortSelect.appendChild(option);
          });
          sortSelect.value = playlist.sort_by || "";
          sortSelect.addEventListener("change", (event) => {
            playlist.sort_by = event.target.value;
          });
          sortLabel.appendChild(sortSelect);

          const coverLabel = document.createElement("label");
          coverLabel.textContent = "Cover Image Path";
          const coverWrapper = document.createElement("div");
          coverWrapper.className = "path-input";
          const coverInput = document.createElement("input");
          coverInput.type = "text";
          coverInput.placeholder = "/images/cover.png";
          coverInput.value = extras.cover || "";
          coverInput.addEventListener("input", (event) => {
            extras.cover = event.target.value;
          });
          const suggestionsList = document.createElement("div");
          suggestionsList.className = "path-suggestions";
          coverWrapper.appendChild(coverInput);
          coverWrapper.appendChild(suggestionsList);
          coverLabel.appendChild(coverWrapper);

          grid.appendChild(nameLabel);
          grid.appendChild(limitLabel);
          grid.appendChild(artistLimitLabel);
          grid.appendChild(albumLimitLabel);
          grid.appendChild(sortLabel);
          grid.appendChild(coverLabel);

          card.appendChild(grid);

          const filtersWrapper = document.createElement("div");
          filtersWrapper.className = "filters-container";
          renderFilters(filtersWrapper, playlist.plex_filter, (filterIndex) => {
            playlist.plex_filter.splice(filterIndex, 1);
            renderPlaylists();
          });

          card.appendChild(filtersWrapper);

          const addFilterBtn = document.createElement("button");
          addFilterBtn.type = "button";
          addFilterBtn.className = "secondary";
          addFilterBtn.textContent = "＋ Add Filter";
          addFilterBtn.addEventListener("click", () => {
            playlist.plex_filter.push({
              field: "",
              operator: "equals",
              value: "",
              match_all: true,
            });
            renderPlaylists();
          });

          card.appendChild(addFilterBtn);

          setupPathAutocomplete(coverInput, suggestionsList, playlist, "cover");

          playlistsContainer.appendChild(card);
        });
      }

      function renderDefaultFilters() {
        renderFilters(defaultFiltersContainer, state.defaults.plex_filter, (index) => {
          state.defaults.plex_filter.splice(index, 1);
          renderDefaultFilters();
        });
      }

      function renderAll() {
        renderDefaultFilters();
        renderPlaylists();
      }

      async function loadData() {
        try {
          const response = await fetch("/api/playlists");
          if (!response.ok) {
            throw new Error("Unable to load playlists.");
          }
          const data = await response.json();
          options = data.options || options;

          state.defaults.plex_filter = (data.defaults?.plex_filter || []).map((filter) => ({
            field: filter.field || "",
            operator: filter.operator || "equals",
            value: filter.value || "",
            match_all: filter.match_all !== undefined ? filter.match_all : true,
          }));
          state.defaults.extras = data.defaults?.extras || {};

          state.playlists = (data.playlists || []).map((playlist) => ({
            name: playlist.name || "",
            limit: playlist.limit ?? 0,
            artist_limit: playlist.artist_limit ?? 0,
            album_limit: playlist.album_limit ?? 0,
            sort_by: playlist.sort_by || "",
            plex_filter: (playlist.plex_filter || []).map((filter) => ({
              field: filter.field || "",
              operator: filter.operator || "equals",
              value: filter.value || "",
              match_all: filter.match_all !== undefined ? filter.match_all : true,
            })),
            extras: playlist.extras || {},
          }));

          renderAll();
        } catch (error) {
          console.error(error);
          showMessage(error.message, true);
        }
      }

      function prepareFiltersForSave(filters) {
        return filters.map((filter) => ({
          field: filter.field || "",
          operator: filter.operator || "equals",
          value: filter.value || "",
          match_all: filter.match_all !== undefined ? !!filter.match_all : true,
        }));
      }

      async function saveData() {
        const payload = {
          defaults: {
            plex_filter: prepareFiltersForSave(state.defaults.plex_filter),
            extras: sanitizeExtras(state.defaults.extras || {}),
          },
          playlists: state.playlists.map((playlist) => ({
            name: playlist.name || "",
            limit: playlist.limit ?? 0,
            artist_limit: playlist.artist_limit ?? 0,
            album_limit: playlist.album_limit ?? 0,
            sort_by: playlist.sort_by || "",
            plex_filter: prepareFiltersForSave(playlist.plex_filter),
            extras: sanitizeExtras(playlist.extras || {}),
          })),
        };

        try {
          const response = await fetch("/api/playlists", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ error: "Unknown error" }));
            throw new Error(error.error || "Failed to save playlists.");
          }

          showMessage("Playlists saved successfully.");
        } catch (error) {
          console.error(error);
          showMessage(error.message, true);
        }
      }

      document.getElementById("addDefaultFilter").addEventListener("click", () => {
        state.defaults.plex_filter.push({
          field: "",
          operator: "equals",
          value: "",
          match_all: true,
        });
        renderDefaultFilters();
      });

      document.getElementById("addPlaylist").addEventListener("click", () => {
        const defaultSort = options.sort_fields?.[0]?.value || "";
        state.playlists.push({
          name: "New Playlist",
          limit: 0,
          artist_limit: 0,
          album_limit: 0,
          sort_by: defaultSort,
          plex_filter: [],
          extras: {},
        });
        renderPlaylists();
      });

      document.getElementById("reloadBtn").addEventListener("click", () => {
        loadData().then(() => showMessage("Reloaded from playlists.yml"));
      });

      document
        .getElementById("clearAllmusicCacheBtn")
        .addEventListener("click", async () => {
          try {
            const response = await fetch("/api/cache/allmusic", { method: "POST" });
            const result = await response.json().catch(() => ({}));

            if (!response.ok) {
              throw new Error(result.error || "Failed to clear AllMusic cache.");
            }

            if (result.status === "missing") {
              showMessage("AllMusic cache already clear.");
            } else {
              showMessage("AllMusic cache cleared.");
            }
          } catch (error) {
            console.error(error);
            showMessage(error.message, true);
          }
        });

      document.getElementById("saveBtn").addEventListener("click", saveData);

      if (buildToggleBtn) {
        buildToggleBtn.addEventListener("click", toggleBuild);
      }

      refreshBuildStatus();
      buildStatusTimer = setInterval(() => refreshBuildStatus(), 5000);
      loadData();
    </script>
  </body>
</html>
