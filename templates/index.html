<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Plex Playlist Builder</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --plex-orange: #e5a00d;
        --plex-orange-dark: #d48c07;
        --plex-dark: #1a1a1a;
        --plex-gray: #2b2b2b;
        --plex-light: #f5f5f5;
        --card-bg: rgba(34, 34, 34, 0.92);
        --border-radius: 14px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Roboto", sans-serif;
        background: radial-gradient(circle at top, #2a2a2a 0%, #111 70%);
        color: var(--plex-light);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        background: linear-gradient(135deg, var(--plex-dark), #0d0d0d);
        padding: 24px 48px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }

      header h1 {
        margin: 0;
        font-size: 28px;
        letter-spacing: 0.04em;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      header h1 span.icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 42px;
        height: 42px;
        border-radius: 50%;
        background: var(--plex-orange);
        color: #111;
        font-size: 22px;
        box-shadow: 0 8px 20px rgba(229, 160, 13, 0.45);
      }

      .action-bar {
        display: flex;
        gap: 12px;
        flex-wrap: nowrap;
        align-items: center;
      }

      .action-bar button {
        flex: 0 0 auto;
      }

      main {
        flex: 1;
        padding: 32px 48px 120px;
        overflow-y: auto;
      }

      section {
        margin-bottom: 32px;
      }

      .section-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
        margin-bottom: 16px;
      }

      .section-header h2 {
        margin: 0;
      }

      .section-header .section-actions {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .default-filters-header-title {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .collapsible-card.collapsed {
        display: none;
      }

      h2 {
        margin: 0 0 16px;
        font-size: 22px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      h2 .section-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border-radius: 12px;
        background: rgba(229, 160, 13, 0.2);
        color: var(--plex-orange);
        font-size: 16px;
      }

      .card {
        background: var(--card-bg);
        border-radius: var(--border-radius);
        padding: 20px;
        margin-bottom: 18px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(229, 160, 13, 0.18);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .card:hover {
        transform: translateY(-3px);
        box-shadow: 0 24px 45px rgba(0, 0, 0, 0.55);
      }

      .build-status-panel {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .build-status-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 24px;
        flex-wrap: wrap;
      }

      .status-info {
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex: 1;
      }

      .status-headline {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 18px;
        font-weight: 600;
      }

      .status-text {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .status-indicator {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.35);
        box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.08);
        flex-shrink: 0;
      }

      .status-indicator.running {
        background: #4caf50;
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.25);
      }

      .status-indicator.waiting {
        background: #f5c150;
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.25);
      }

      .status-indicator.idle {
        background: #9e9e9e;
        box-shadow: 0 0 0 3px rgba(158, 158, 158, 0.25);
      }

      .status-indicator.error {
        background: #e94146;
        box-shadow: 0 0 0 3px rgba(233, 65, 70, 0.3);
      }

      .status-indicator.success {
        background: #3fbf61;
        box-shadow: 0 0 0 3px rgba(63, 191, 97, 0.25);
      }

      .status-indicator.stopped {
        background: #9e9e9e;
        box-shadow: 0 0 0 3px rgba(158, 158, 158, 0.25);
      }

      .status-message {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.75);
      }

      .status-meta {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.6);
      }

      .status-actions {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .status-actions button {
        white-space: nowrap;
      }

      .playlist-header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 18px;
        flex-wrap: wrap;
      }

      .playlist-list-controls {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 12px;
        flex-wrap: wrap;
      }

      #addPlaylist {
        position: fixed;
        bottom: 32px;
        right: 48px;
        z-index: 1100;
        box-shadow: 0 18px 36px rgba(0, 0, 0, 0.5);
      }

      #addPlaylist:hover,
      #addPlaylist:focus-visible {
        transform: translateY(-2px);
      }

      .playlist-header h3 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
      }

      .playlist-header-title {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
        flex: 1 1 220px;
      }

      .playlist-status {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
        flex: 1 1 240px;
      }

      .playlist-action-buttons {
        display: flex;
        align-items: center;
        gap: 8px;
        flex: 0 0 auto;
      }

      .playlist-inline-message {
        display: none;
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 13px;
        background: rgba(229, 160, 13, 0.18);
        color: var(--plex-light);
        flex-basis: 100%;
        margin-top: 4px;
      }

      .playlist-inline-message.show {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .playlist-inline-message.error {
        background: rgba(229, 65, 70, 0.28);
        color: #fff;
      }

      .playlist-details {
        display: flex;
        flex-direction: column;
        gap: 18px;
        margin-top: 18px;
      }

      .playlist-card.is-collapsed .playlist-details {
        display: none;
      }

      .playlist-collapse-btn,
      .default-filters-collapse-btn {
        font-size: 18px;
        line-height: 1;
      }

      .playlist-status-text {
        display: flex;
        flex-direction: column;
        gap: 2px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 13px;
        min-width: 0;
      }

      .playlist-status-line {
        font-size: 14px;
        font-weight: 500;
        color: var(--plex-light);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .playlist-status-message {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.55);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .playlist-build-btn {
        white-space: nowrap;
      }

      .input-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 12px;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.8);
      }

      input[type="text"],
      input[type="number"],
      select,
      textarea {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(229, 160, 13, 0.25);
        background: rgba(17, 17, 17, 0.6);
        color: var(--plex-light);
        font-size: 15px;
        transition: border 0.2s ease, box-shadow 0.2s ease;
      }

      input:focus,
      select:focus,
      textarea:focus {
        outline: none;
        border-color: var(--plex-orange);
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.25);
      }

      textarea {
        min-height: 42px;
        resize: vertical;
      }

      .filter-row {
        display: grid;
        grid-template-columns: 1.1fr 1fr 1fr auto auto;
        gap: 12px;
        align-items: start;
        margin-bottom: 10px;
      }

      .boosts-popout {
        margin-top: 18px;
      }

      .boosts-popout summary {
        list-style: none;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 18px;
        border-radius: 999px;
        background: rgba(229, 160, 13, 0.16);
        border: 1px solid rgba(229, 160, 13, 0.35);
        color: var(--plex-light);
        font-size: 15px;
        font-weight: 500;
        box-shadow: none;
        transition: background 0.2s ease, transform 0.2s ease;
      }

      .boosts-popout summary::-webkit-details-marker {
        display: none;
      }

      .boosts-popout[open] summary {
        background: rgba(229, 160, 13, 0.28);
        transform: translateY(-1px);
      }

      .boosts-panel {
        margin-top: 14px;
        padding: 18px;
        border-radius: 12px;
        background: rgba(14, 14, 14, 0.65);
        border: 1px solid rgba(229, 160, 13, 0.22);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);
      }

      .boosts-panel p {
        margin: 0 0 14px;
        color: rgba(255, 255, 255, 0.75);
        font-size: 14px;
      }

      .boosts-container {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .boost-row {
        grid-template-columns: 1.1fr 1fr 1fr auto 0.6fr auto;
      }

      .boost-row .boost-input {
        display: flex;
        align-items: center;
      }

      .boost-row .boost-input input {
        width: 100%;
        min-width: 110px;
      }

      .filter-row .value-input {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .filter-row .value-input input {
        width: 100%;
        min-width: 180px;
      }

      .filter-row .filter-flags {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: flex-start;
      }

      .filter-row .filter-flag {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.7);
        white-space: nowrap;
      }

      .path-input {
        position: relative;
        display: flex;
        flex-direction: column;
      }

      .path-suggestions {
        position: absolute;
        top: calc(100% + 6px);
        left: 0;
        right: 0;
        background: rgba(18, 18, 18, 0.95);
        border: 1px solid rgba(229, 160, 13, 0.25);
        border-radius: 10px;
        box-shadow: 0 18px 32px rgba(0, 0, 0, 0.45);
        max-height: 220px;
        overflow-y: auto;
        display: none;
        flex-direction: column;
        z-index: 20;
      }

      .path-suggestions.show {
        display: flex;
      }

      .path-suggestions button {
        background: transparent;
        border: none;
        text-align: left;
        padding: 10px 12px;
        color: var(--plex-light);
        font-size: 14px;
        cursor: pointer;
        transition: background 0.15s ease;
      }

      .path-suggestions button:hover {
        background: rgba(229, 160, 13, 0.18);
      }

      .button,
      button {
        cursor: pointer;
        border: none;
        border-radius: 999px;
        padding: 10px 18px;
        font-size: 15px;
        font-weight: 500;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: #111;
        background: var(--plex-orange);
        transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 12px 24px rgba(229, 160, 13, 0.35);
      }

      button.secondary {
        background: rgba(229, 160, 13, 0.16);
        color: var(--plex-light);
        box-shadow: none;
        border: 1px solid rgba(229, 160, 13, 0.35);
      }

      button.danger {
        background: rgba(229, 65, 70, 0.85);
        color: #fff;
        box-shadow: 0 12px 24px rgba(229, 65, 70, 0.45);
      }

      button.icon-only {
        padding: 8px;
        border-radius: 12px;
        width: 40px;
        height: 40px;
        justify-content: center;
        font-size: 18px;
        line-height: 1;
      }

      button:hover {
        transform: translateY(-1px);
      }

      button:active {
        transform: scale(0.97);
        background: var(--plex-orange-dark);
      }

      button.secondary:active {
        background: rgba(229, 160, 13, 0.28);
      }

      button.danger:active {
        background: rgba(229, 65, 70, 0.95);
      }

      .filters-container {
        border: 1px dashed rgba(229, 160, 13, 0.25);
        border-radius: 12px;
        padding: 16px;
        background: rgba(14, 14, 14, 0.55);
      }

      .build-status-logs {
        padding: 16px;
        border-radius: 12px;
        background: linear-gradient(135deg, rgba(20, 20, 20, 0.85), rgba(12, 12, 12, 0.9));
        border: 1px solid rgba(229, 160, 13, 0.18);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
        transition: box-shadow 0.3s ease;
      }

      .build-status-panel.running .build-status-logs {
        box-shadow: inset 0 0 0 1px rgba(229, 160, 13, 0.2), 0 10px 30px rgba(229, 160, 13, 0.12);
      }

      .playlist-log-toggle {
        cursor: pointer;
        background: none;
        border: none;
        border-radius: 0;
        padding: 0;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.6);
        transition: color 0.2s ease;
        box-shadow: none;
      }

      .playlist-log-toggle:hover,
      .playlist-log-toggle:focus-visible {
        color: rgba(255, 255, 255, 0.85);
        outline: none;
      }

      .playlist-log-toggle:focus-visible {
        outline: 2px solid rgba(229, 160, 13, 0.6);
        outline-offset: 2px;
      }

      .playlist-log-toggle-label {
        pointer-events: none;
      }

      .playlist-log-toggle-icon {
        font-size: 14px;
        transition: transform 0.2s ease;
        pointer-events: none;
      }

      .build-status-logs.collapsed .playlist-log-toggle-icon {
        transform: rotate(-90deg);
      }

      .build-status-logs.collapsed .build-log-list {
        display: none;
      }

      .playlist-log-list {
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .playlist-log-entry {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 12px 14px;
        border-radius: 10px;
        background: rgba(229, 160, 13, 0.08);
        border: 1px solid rgba(229, 160, 13, 0.18);
        position: relative;
        overflow: hidden;
      }

      .playlist-log-entry.progress-entry {
        gap: 10px;
      }

      .playlist-log-entry::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at top right, rgba(229, 160, 13, 0.18), transparent 55%);
        pointer-events: none;
        opacity: 0.6;
      }

      .build-status-panel.running .playlist-log-entry::after {
        animation: filteringGlow 2.2s ease-in-out infinite;
      }

      .playlist-log-bar {
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: rgba(229, 160, 13, 0.16);
        overflow: hidden;
        position: relative;
      }

      .playlist-log-bar span {
        display: block;
        height: 100%;
        width: var(--progress, 0%);
        background: linear-gradient(90deg, var(--plex-orange), #ffce4a);
        box-shadow: 0 0 12px rgba(229, 160, 13, 0.4);
        transition: width 0.35s ease;
      }

      .build-status-panel.running .playlist-log-bar span {
        animation: filteringPulse 1.8s ease-in-out infinite;
      }

      .playlist-log-message {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .playlist-log-spinner {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 2px solid rgba(229, 160, 13, 0.25);
        border-top-color: var(--plex-orange);
        animation: spin 0.9s linear infinite;
        flex-shrink: 0;
      }

      .playlist-log-entry:not(.is-active-step) .playlist-log-spinner {
        display: none;
      }

      .playlist-log-text {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.85);
        position: relative;
        z-index: 1;
        flex: 1;
      }

      .playlist-log-dismiss {
        margin-left: auto;
        background: transparent;
        border: none;
        color: #ff6b6b;
        font-size: 16px;
        cursor: pointer;
        border-radius: 999px;
        width: 24px;
        height: 24px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        padding: 0;
        transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      }

      .playlist-log-dismiss:hover,
      .playlist-log-dismiss:focus-visible {
        background: rgba(255, 107, 107, 0.18);
        color: #ff8f8f;
      }

      .playlist-log-dismiss:focus-visible {
        outline: 2px solid rgba(255, 107, 107, 0.3);
        outline-offset: 2px;
      }

      .playlist-log-dismiss:active {
        transform: scale(0.92);
      }

      .playlist-log-empty {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.55);
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .playlist-log-entry.general-entry {
        background: rgba(120, 120, 120, 0.18);
        border-color: rgba(255, 255, 255, 0.16);
      }

      .playlist-log-entry.general-entry::after {
        background: radial-gradient(
          circle at top right,
          rgba(255, 255, 255, 0.18),
          transparent 55%
        );
      }

      .build-log-list {
        margin-top: 16px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .build-log-playlist {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .build-log-playlist-title {
        font-size: 15px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.78);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .build-log-playlist-title::before {
        content: "";
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: rgba(229, 160, 13, 0.6);
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.12);
      }

      .build-log-playlist.is-waiting .build-log-playlist-title::before {
        background: rgba(229, 160, 13, 0.4);
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.08);
      }

      .build-log-playlist.is-active .build-log-playlist-title::before {
        background: #4caf50;
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.25);
      }

      .build-log-playlist.is-waiting .playlist-log-text {
        color: rgba(229, 160, 13, 0.82);
      }

      .build-log-playlist.is-waiting .playlist-log-spinner {
        border-top-color: rgba(229, 160, 13, 0.6);
      }

      .build-log-playlist-entries {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      @keyframes filteringPulse {
        0% {
          filter: brightness(0.95);
        }
        50% {
          filter: brightness(1.2);
        }
        100% {
          filter: brightness(0.95);
        }
      }

      @keyframes filteringGlow {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 0.9;
        }
      }

      .no-filters {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 12px;
      }

      .message {
        margin-left: auto;
        padding: 10px 16px;
        border-radius: 999px;
        font-size: 14px;
        background: rgba(229, 160, 13, 0.2);
        color: var(--plex-light);
        display: none;
      }

      .message.show {
        display: inline-flex;
      }

      @media (max-width: 960px) {
        main {
          padding: 24px;
          padding-bottom: 120px;
        }

        header {
          flex-direction: column;
          align-items: flex-start;
          gap: 16px;
        }

        .action-bar {
          width: 100%;
          flex-wrap: wrap;
        }

        #addPlaylist {
          bottom: 24px;
          right: 24px;
        }

        .playlist-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 12px;
        }

        .playlist-status {
          width: 100%;
        }

        .playlist-action-buttons {
          width: 100%;
        }

        .playlist-status-line,
        .playlist-status-message {
          white-space: normal;
        }

        .filter-row {
          grid-template-columns: 1fr;
        }

        .filter-row .filter-flags {
          width: 100%;
        }

        .filter-row .filter-flag {
          justify-content: flex-start;
        }

        .filter-row .value-input input {
          min-width: 0;
        }

        .boosts-popout summary {
          width: 100%;
          justify-content: center;
        }

        .boost-row {
          grid-template-columns: 1fr;
        }

        .boost-row .boost-input input {
          min-width: 0;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1><span class="icon">▶</span>Plex Playlist Builder</h1>
      <div class="action-bar">
        <button
          id="buildPopularityBtn"
          class="icon-only"
          type="button"
          title="Pull the latest popularity metadata"
          aria-label="Pull the latest popularity metadata"
        >
          ⬇️
        </button>
        <button
          id="clearPopularityCacheBtn"
          class="icon-only secondary"
          type="button"
          title="Clear the cached popularity data"
          aria-label="Clear the cached popularity data"
        >
          🧹
        </button>
        <button
          id="reloadBtn"
          class="icon-only secondary"
          type="button"
          title="Refresh playlists from playlists.yml"
          aria-label="Refresh playlists from playlists.yml"
        >
          ⟳
        </button>
        <button
          id="saveBtn"
          class="icon-only"
          type="button"
          title="Save all playlists to playlists.yml"
          aria-label="Save all playlists to playlists.yml"
        >
          💾
        </button>
        <button
          id="buildToggleBtn"
          class="icon-only"
          type="button"
          title="Build all playlists"
          aria-label="Build all playlists"
        >
          ▶
        </button>
        <span id="message" class="message"></span>
      </div>
    </header>
    <main>
      <section>
        <h2><span class="section-icon">🛠</span>Build Status</h2>
        <div id="buildStatusPanel" class="card build-status-panel">
          <div class="build-status-header">
            <div class="status-info">
              <div class="status-headline">
                <span id="buildStatusIndicator" class="status-indicator idle"></span>
                <div class="status-text">
                  <div id="buildStatusText">Checking build status…</div>
                  <div id="buildStatusMessage" class="status-message"></div>
                </div>
              </div>
              <div id="buildStatusMeta" class="status-meta"></div>
            </div>
          </div>
          <div id="buildStatusLogs" class="build-status-logs">
            <button
              id="playlistActivityToggle"
              class="playlist-log-toggle"
              type="button"
              aria-expanded="true"
            >
              <span class="playlist-log-toggle-label">Activity</span>
              <span class="playlist-log-toggle-icon" aria-hidden="true">▾</span>
            </button>
            <div id="buildLogContainer" class="build-log-list"></div>
          </div>
        </div>
      </section>

      <section>
        <div class="section-header default-filters-header">
          <div class="default-filters-header-title">
            <button
              id="toggleDefaultFilters"
              class="icon-only secondary default-filters-collapse-btn"
              type="button"
              aria-expanded="false"
              aria-controls="defaultFiltersCard"
              aria-label="Expand default filters"
              title="Expand default filters"
            >
              ▸
            </button>
            <h2><span class="section-icon">⚙</span>Default Plex Filters</h2>
          </div>
        </div>
        <div
          id="defaultFiltersCard"
          class="card collapsible-card collapsed"
          hidden
          aria-hidden="true"
        >
          <div id="defaultFilters" class="filters-container"></div>
          <button id="addDefaultFilter" class="secondary" type="button">＋ Add Default Filter</button>
          <details id="defaultBoostsPopout" class="boosts-popout">
            <summary aria-label="Toggle default popularity boost rules">
              ⚡ Popularity Boosts
            </summary>
            <div class="boosts-panel">
              <p>
                Boost multipliers adjust the popularity score of matching tracks. Uncheck
                Match All to treat comma-separated values as match-any.
              </p>
              <div
                id="defaultPopularityBoosts"
                class="boosts-container"
              ></div>
              <button id="addDefaultBoost" class="secondary" type="button">
                ＋ Add Boost Rule
              </button>
            </div>
          </details>
        </div>
      </section>

      <section>
        <div class="playlist-header">
          <h2><span class="section-icon">🎵</span>Playlists</h2>
          <div class="playlist-list-controls">
            <button id="expandAllPlaylists" class="secondary" type="button">
              Expand All
            </button>
            <button id="collapseAllPlaylists" class="secondary" type="button">
              Collapse All
            </button>
            <button id="addPlaylist" type="button">＋ Add Playlist</button>
          </div>
        </div>
        <div id="playlistsContainer"></div>
      </section>
    </main>

    <script>
      const state = {
        defaults: { plex_filter: [], popularity_boosts: [], extras: {} },
        playlists: [],
      };

      let options = {
        fields: [],
        operators: [],
        sort_fields: [],
      };

      const messageEl = document.getElementById("message");
      const playlistsContainer = document.getElementById("playlistsContainer");
      const expandAllPlaylistsBtn = document.getElementById("expandAllPlaylists");
      const collapseAllPlaylistsBtn = document.getElementById(
        "collapseAllPlaylists"
      );
      const defaultFiltersContainer = document.getElementById("defaultFilters");
      const defaultBoostsPopout = document.getElementById("defaultBoostsPopout");
      const defaultBoostsContainer = document.getElementById(
        "defaultPopularityBoosts"
      );
      const defaultFiltersCard = document.getElementById("defaultFiltersCard");
      const toggleDefaultFiltersBtn = document.getElementById("toggleDefaultFilters");
      const buildStatusIndicator = document.getElementById("buildStatusIndicator");
      const buildStatusText = document.getElementById("buildStatusText");
      const buildStatusMessage = document.getElementById("buildStatusMessage");
      const buildStatusMeta = document.getElementById("buildStatusMeta");
      const buildToggleBtn = document.getElementById("buildToggleBtn");
      const buildStatusPanel = document.getElementById("buildStatusPanel");
      const buildStatusLogs = document.getElementById("buildStatusLogs");
      const playlistActivityToggle = document.getElementById(
        "playlistActivityToggle"
      );
      const buildLogContainer = document.getElementById("buildLogContainer");
      const buildPopularityBtn = document.getElementById("buildPopularityBtn");
      const clearPopularityCacheBtn = document.getElementById("clearPopularityCacheBtn");
      const playlistMessageTimeouts = new WeakMap();
      let latestBuildStatus = null;
      let latestPopularityStatus = null;
      let buildStatusTimer = null;
      let popularityStatusTimer = null;
      let isActivityCollapsed = false;
      let isDefaultFiltersCollapsed = true;
      let isDefaultBoostsOpen = false;
      const rateLimitCountdownEntries = new Set();
      const dismissedActivityKeys = new Set();
      let pendingActivityStopRequest = null;
      let rateLimitCountdownTimer = null;
      const ACTIVITY_RETENTION_MS = 5 * 60 * 1000;
      const waitingPlaylistOrder = new Map();
      let nextWaitingOrderValue = 1;

      function clearRateLimitCountdowns(rootElement = null) {
        const entries = Array.from(rateLimitCountdownEntries);
        entries.forEach((entry) => {
          if (!entry?.element || !entry.element.isConnected) {
            rateLimitCountdownEntries.delete(entry);
            return;
          }
          if (!rootElement || rootElement.contains(entry.element)) {
            rateLimitCountdownEntries.delete(entry);
          }
        });
        scheduleRateLimitCountdownUpdates();
      }

      function scheduleRateLimitCountdownUpdates() {
        if (rateLimitCountdownEntries.size > 0) {
          if (!rateLimitCountdownTimer) {
            rateLimitCountdownTimer = setInterval(
              updateRateLimitCountdowns,
              1000
            );
          }
        } else if (rateLimitCountdownTimer) {
          clearInterval(rateLimitCountdownTimer);
          rateLimitCountdownTimer = null;
        }
      }

      function makeActivityKey(parts) {
        if (!Array.isArray(parts)) {
          return null;
        }
        const normalized = parts.map((part) => {
          if (part === null || part === undefined) {
            return "";
          }
          if (typeof part === "number") {
            if (!Number.isFinite(part)) {
              return "";
            }
            return String(part);
          }
          return String(part).trim();
        });
        if (normalized.every((part) => part.length === 0)) {
          return null;
        }
        return normalized.join("|");
      }

      function getPlaylistActivityKey(name, entry) {
        const trimmedName = typeof name === "string" ? name.trim() : "";
        if (!trimmedName) {
          return null;
        }
        const parts = [
          "playlist",
          trimmedName,
          entry?.type || "message",
          entry?.text || "",
        ];
        if (entry?.timestamp) {
          parts.push(entry.timestamp);
        }
        if (entry?.percent !== undefined) {
          parts.push(entry.percent);
        }
        if (entry?.current !== undefined || entry?.total !== undefined) {
          parts.push(entry?.current ?? "");
          parts.push(entry?.total ?? "");
        }
        const normalizedPercent = normalizeProgressPercent(entry);
        if (normalizedPercent !== null) {
          parts.push(normalizedPercent.toFixed(2));
        }
        return makeActivityKey(parts);
      }

      function getGeneralActivityKey(entry) {
        if (!entry) {
          return null;
        }
        return makeActivityKey([
          "general",
          entry.text || "",
          entry.timestamp || "",
        ]);
      }

      function getSpotifyActivityKey(type, value, extraParts = []) {
        if (!type) {
          return null;
        }
        const extras = Array.isArray(extraParts)
          ? extraParts.filter((part) => part !== undefined && part !== null)
          : [extraParts];
        return makeActivityKey(["spotify", type, value || "", ...extras]);
      }

      function markAndRemoveActivityEntry(entryEl) {
        if (!entryEl) {
          return null;
        }

        const activityKey = entryEl.dataset?.activityKey;
        if (activityKey) {
          dismissedActivityKeys.add(activityKey);
        }

        clearRateLimitCountdowns(entryEl);

        const listEl = entryEl.parentElement;
        entryEl.remove();

        const playlistBlock = listEl?.closest(".build-log-playlist");
        if (listEl && listEl.children.length === 0 && playlistBlock) {
          playlistBlock.remove();
        }

        return activityKey;
      }

      function createDismissButton(activityKey, options = {}) {
        const { playlistName } = options || {};
        const button = document.createElement("button");
        button.type = "button";
        button.className = "playlist-log-dismiss";
        button.setAttribute("aria-label", "Dismiss activity");
        button.innerHTML = "&times;";
        button.addEventListener("click", (event) => {
          event.preventDefault();
          event.stopPropagation();
          const entryEl = button.closest(".playlist-log-entry");
          if (activityKey) {
            dismissedActivityKeys.add(activityKey);
          }
          if (entryEl) {
            markAndRemoveActivityEntry(entryEl);
          }
          if (playlistName) {
            cancelPlaylistBuildFromActivity(playlistName);
          }
        });
        return button;
      }

      function dismissAllActivityEntries() {
        if (!buildLogContainer) {
          return;
        }

        const entries = Array.from(
          buildLogContainer.querySelectorAll(".playlist-log-entry")
        );

        entries.forEach((entryEl) => {
          markAndRemoveActivityEntry(entryEl);
        });

        if (!buildLogContainer.firstChild) {
          buildLogContainer.innerHTML = "";
        }
      }

      function cancelPlaylistBuildFromActivity(rawName) {
        const trimmedName =
          typeof rawName === "string" ? rawName.trim() : String(rawName ?? "").trim();
        if (!trimmedName) {
          return;
        }

        if (!latestBuildStatus?.running) {
          return;
        }

        const activePlaylistsSet = collectActivePlaylistSet(latestBuildStatus);
        if (!activePlaylistsSet.has(trimmedName)) {
          return;
        }

        if (pendingActivityStopRequest) {
          return;
        }

        pendingActivityStopRequest = (async () => {
          try {
            const response = await fetch("/api/build/stop", { method: "POST" });
            const result = await response.json().catch(() => ({}));
            if (!response.ok) {
              throw new Error(result.message || "Failed to stop playlist build.");
            }

            if (result.status) {
              updateBuildStatusUi(result.status);
            } else {
              await refreshBuildStatus();
            }

            if (result.message) {
              showMessage(result.message);
            } else {
              showMessage(`Stopping '${trimmedName}'...`);
            }

            setTimeout(() => {
              const refreshPromise = refreshBuildStatus();
              if (refreshPromise && typeof refreshPromise.catch === "function") {
                refreshPromise.catch(() => {});
              }
            }, 1000);
          } catch (error) {
            console.error(error);
            const message = error?.message || "Failed to stop playlist build.";
            showMessage(message, true);
          } finally {
            pendingActivityStopRequest = null;
          }
        })();
      }

      function formatDurationShort(totalSeconds) {
        const secondsNumeric = Number(totalSeconds);
        if (!Number.isFinite(secondsNumeric)) {
          return "";
        }
        let remaining = Math.max(0, Math.floor(secondsNumeric));
        const parts = [];
        const units = [
          [86400, "d"],
          [3600, "h"],
          [60, "m"],
        ];

        for (const [unitSeconds, label] of units) {
          if (remaining >= unitSeconds) {
            const value = Math.floor(remaining / unitSeconds);
            remaining -= value * unitSeconds;
            parts.push(`${value}${label}`);
          }
        }

        if (remaining > 0 || parts.length === 0) {
          parts.push(`${remaining}s`);
        }

        return parts.join(" ");
      }

      function formatRateLimitMessage(baseText, remainingSeconds) {
        const safeText =
          typeof baseText === "string" ? baseText : String(baseText ?? "");
        const seconds = Math.max(0, Number.isFinite(remainingSeconds)
          ? Math.floor(remainingSeconds)
          : 0);
        const displayValue = seconds <= 0 ? "now" : formatDurationShort(seconds);
        const pattern = /(Retry will occur after:\s*)([0-9]+(?:\.[0-9]+)?)(.*)/i;

        if (pattern.test(safeText)) {
          return safeText.replace(
            pattern,
            (_, prefix, _value, suffix) => `${prefix}${displayValue}${suffix ?? ""}`
          );
        }

        if (seconds <= 0) {
          return `${safeText} (Retrying now)`;
        }

        return `${safeText} (Retry in ${formatDurationShort(seconds)})`;
      }

      function updateRateLimitCountdownEntry(entry) {
        if (!entry || !entry.element || !entry.element.isConnected) {
          if (entry) {
            rateLimitCountdownEntries.delete(entry);
          }
          return;
        }

        const now = Date.now();
        const remainingMs = entry.resumeMs - now;
        const remainingSeconds = Math.ceil(remainingMs / 1000);
        const formatted = formatRateLimitMessage(
          entry.baseText,
          remainingSeconds
        );

        if (entry.element.textContent !== formatted) {
          entry.element.textContent = formatted;
        }

        if (remainingMs <= 0) {
          rateLimitCountdownEntries.delete(entry);
        }
      }

      function updateRateLimitCountdowns() {
        const entries = Array.from(rateLimitCountdownEntries);
        entries.forEach((entry) => updateRateLimitCountdownEntry(entry));
        scheduleRateLimitCountdownUpdates();
      }

      function unregisterRateLimitCountdown(element) {
        if (!element) {
          return;
        }

        const entries = Array.from(rateLimitCountdownEntries);
        let removed = false;
        entries.forEach((entry) => {
          if (!entry?.element || entry.element === element) {
            rateLimitCountdownEntries.delete(entry);
            removed = true;
          }
        });

        if (element.dataset) {
          delete element.dataset.resumeAt;
          delete element.dataset.loggedAt;
        }

        if (typeof element.removeAttribute === "function") {
          element.removeAttribute("title");
        }

        if (removed) {
          scheduleRateLimitCountdownUpdates();
        }
      }

      function registerRateLimitCountdown(element, entry) {
        if (!element || !entry) {
          return;
        }

        unregisterRateLimitCountdown(element);

        let resumeMs = Number(entry.rate_limit_resume_epoch) * 1000;
        if (!Number.isFinite(resumeMs) || resumeMs <= 0) {
          const parsed = entry.rate_limit_resume
            ? Date.parse(entry.rate_limit_resume)
            : NaN;
          if (!Number.isNaN(parsed)) {
            resumeMs = parsed;
          }
        }

        if (!Number.isFinite(resumeMs) || resumeMs <= 0) {
          return;
        }

        const countdownEntry = {
          element,
          baseText: entry.text || "",
          resumeMs,
        };

        if (entry.rate_limit_resume) {
          element.dataset.resumeAt = entry.rate_limit_resume;
        }
        if (entry.timestamp) {
          element.dataset.loggedAt = entry.timestamp;
        }

        const resumeDate = new Date(resumeMs);
        if (!Number.isNaN(resumeDate.getTime())) {
          element.title = `Retry scheduled for ${resumeDate.toLocaleString()}`;
        }

        updateRateLimitCountdownEntry(countdownEntry);
        rateLimitCountdownEntries.add(countdownEntry);
        scheduleRateLimitCountdownUpdates();
      }

      function setActivityCollapsed(collapsed) {
        isActivityCollapsed = Boolean(collapsed);
        if (playlistActivityToggle) {
          playlistActivityToggle.setAttribute(
            "aria-expanded",
            String(!isActivityCollapsed)
          );
        }
        if (buildStatusLogs) {
          buildStatusLogs.classList.toggle("collapsed", isActivityCollapsed);
        }
        if (buildLogContainer) {
          if (isActivityCollapsed) {
            dismissAllActivityEntries();
            buildLogContainer.setAttribute("hidden", "");
          } else {
            buildLogContainer.removeAttribute("hidden");
          }
          buildLogContainer.setAttribute(
            "aria-hidden",
            isActivityCollapsed ? "true" : "false"
          );
        }
      }

      if (playlistActivityToggle) {
        playlistActivityToggle.addEventListener("click", () => {
          setActivityCollapsed(!isActivityCollapsed);
        });
      }

      setActivityCollapsed(false);

      function showMessage(text, isError = false) {
        if (!text) {
          messageEl.classList.remove("show");
          return;
        }
        messageEl.textContent = text;
        messageEl.style.background = isError
          ? "rgba(229, 65, 70, 0.25)"
          : "rgba(229, 160, 13, 0.2)";
        messageEl.classList.add("show");
        setTimeout(() => messageEl.classList.remove("show"), 4000);
      }

      function showPlaylistInlineMessage(playlist, text, options = {}) {
        if (!playlist) {
          return;
        }

        const inlineMessageEl = playlist._inlineMessageEl;
        if (!inlineMessageEl) {
          return;
        }

        const { isError = false, persist = false } = options;
        const existingTimeout = playlistMessageTimeouts.get(inlineMessageEl);
        if (existingTimeout) {
          clearTimeout(existingTimeout);
          playlistMessageTimeouts.delete(inlineMessageEl);
        }

        if (!text) {
          inlineMessageEl.textContent = "";
          inlineMessageEl.classList.remove("show", "error");
          return;
        }

        inlineMessageEl.textContent = text;
        inlineMessageEl.classList.toggle("error", Boolean(isError));
        inlineMessageEl.classList.add("show");

        if (!persist) {
          const timeout = setTimeout(() => {
            if (inlineMessageEl.textContent === text) {
              inlineMessageEl.classList.remove("show");
              inlineMessageEl.textContent = "";
            }
            playlistMessageTimeouts.delete(inlineMessageEl);
          }, 4000);
          playlistMessageTimeouts.set(inlineMessageEl, timeout);
        }
      }

      function formatTimestamp(isoString) {
        if (!isoString) {
          return "";
        }
        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) {
          return isoString;
        }
        return `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
      }

      function parseTimestampMs(value) {
        if (!value) {
          return null;
        }
        const parsed = Date.parse(value);
        return Number.isNaN(parsed) ? null : parsed;
      }

      function resolveResumeTimestampMs(entry) {
        if (!entry) {
          return null;
        }

        let resumeMs = Number(entry.rate_limit_resume_epoch);
        if (Number.isFinite(resumeMs) && resumeMs > 0) {
          resumeMs *= 1000;
        } else {
          resumeMs = NaN;
        }

        if (!Number.isFinite(resumeMs) || resumeMs <= 0) {
          const parsed = entry.rate_limit_resume
            ? Date.parse(entry.rate_limit_resume)
            : NaN;
          if (!Number.isNaN(parsed)) {
            resumeMs = parsed;
          }
        }

        if (!Number.isFinite(resumeMs) || resumeMs <= 0) {
          return null;
        }

        return resumeMs;
      }

      function updateDefaultFiltersCollapse() {
        if (!defaultFiltersCard || !toggleDefaultFiltersBtn) {
          return;
        }

        const collapsed = Boolean(isDefaultFiltersCollapsed);
        defaultFiltersCard.classList.toggle("collapsed", collapsed);
        if (collapsed) {
          defaultFiltersCard.setAttribute("hidden", "");
        } else {
          defaultFiltersCard.removeAttribute("hidden");
        }
        defaultFiltersCard.setAttribute(
          "aria-hidden",
          collapsed ? "true" : "false"
        );
        toggleDefaultFiltersBtn.setAttribute(
          "aria-expanded",
          String(!collapsed)
        );
        const label = collapsed
          ? "Expand default filters"
          : "Collapse default filters";
        toggleDefaultFiltersBtn.setAttribute("aria-label", label);
        toggleDefaultFiltersBtn.setAttribute("title", label);
        toggleDefaultFiltersBtn.textContent = collapsed ? "▸" : "▾";
      }

      function getSpotifyStatusHeadline(status) {
        const statusLabel = (status?.status || "").toLowerCase();

        if (status?.cache_enabled === false) {
          return "Popularity cache disabled";
        }

        if (status?.running) {
          return "Populating Spotify popularity…";
        }

        if (statusLabel === "success") {
          return "Popularity cache up to date";
        }

        if (statusLabel === "error") {
          return "Popularity cache encountered an error";
        }

        if (statusLabel === "stopped") {
          return "Popularity cache stopped";
        }

        return "Popularity cache idle";
      }

      function updatePopularityStatus(status) {
        latestPopularityStatus = status || null;

        const running = Boolean(status?.running);

        if (buildPopularityBtn) {
          buildPopularityBtn.disabled = !status?.cache_enabled || running;
        }

        if (clearPopularityCacheBtn) {
          clearPopularityCacheBtn.disabled = status?.cache_enabled === false;
        }

        if (latestBuildStatus) {
          updateBuildLogsUi(latestBuildStatus);
        }
      }

      async function refreshPopularityStatus() {
        try {
          const response = await fetch("/api/cache/popularity/status");
          if (!response.ok) {
            throw new Error("Failed to retrieve popularity cache status.");
          }
          const status = await response.json().catch(() => ({}));
          updatePopularityStatus(status);
        } catch (error) {
          console.error(error);
          updatePopularityStatus({
            status: "error",
            message: error?.message || "Failed to retrieve popularity cache status.",
          });
        }
      }

      function normalizeProgressPercent(entry) {
        if (!entry || typeof entry !== "object") {
          return null;
        }

        if (typeof entry.percent === "number" && Number.isFinite(entry.percent)) {
          return entry.percent;
        }

        const percentCandidate = Number(entry.percent);
        if (Number.isFinite(percentCandidate)) {
          return percentCandidate;
        }

        const progressCandidate = Number(entry.progress);
        if (Number.isFinite(progressCandidate)) {
          if (progressCandidate >= 0 && progressCandidate <= 1) {
            return progressCandidate * 100;
          }
          if (progressCandidate >= 0) {
            return progressCandidate;
          }
        }

        const currentCandidate = Number(entry.current);
        const totalCandidate = Number(entry.total);
        if (
          Number.isFinite(currentCandidate) &&
          Number.isFinite(totalCandidate) &&
          totalCandidate > 0
        ) {
          return (currentCandidate / totalCandidate) * 100;
        }

        return null;
      }

      function normalizeGeneralLogEntry(entry) {
        if (entry === null || entry === undefined) {
          return { text: "" };
        }

        if (typeof entry === "string") {
          return { text: entry };
        }

        const normalized = {
          text: "",
        };

        if (typeof entry.text === "string") {
          normalized.text = entry.text;
        } else if (entry.text !== null && entry.text !== undefined) {
          normalized.text = String(entry.text);
        }

        if (entry.timestamp) {
          normalized.timestamp = entry.timestamp;
        }

        const resumeEpoch = Number(entry.rate_limit_resume_epoch);
        if (Number.isFinite(resumeEpoch)) {
          normalized.rate_limit_resume_epoch = resumeEpoch;
        }

        if (entry.rate_limit_resume) {
          normalized.rate_limit_resume = entry.rate_limit_resume;
        }

        const retrySeconds = Number(entry.rate_limit_seconds);
        if (Number.isFinite(retrySeconds)) {
          normalized.rate_limit_seconds = retrySeconds;
        }

        return normalized;
      }

      function addPlaylistName(targetSet, value) {
        if (!targetSet || value === null || value === undefined) {
          return;
        }

        const normalized = String(value).trim();
        if (normalized) {
          targetSet.add(normalized);
        }
      }

      function collectActivePlaylistSet(status) {
        const names = new Set();
        if (!status || typeof status !== "object") {
          return names;
        }

        if (Array.isArray(status.active_playlists)) {
          status.active_playlists.forEach((name) => addPlaylistName(names, name));
        }

        const job = status.job;
        if (job && typeof job === "object") {
          addPlaylistName(names, job.playlist);
          if (Array.isArray(job.active_playlists)) {
            job.active_playlists.forEach((name) => addPlaylistName(names, name));
          }
        }

        return names;
      }

      function getActivePlaylistNames(status) {
        return Array.from(collectActivePlaylistSet(status)).sort((a, b) =>
          a.localeCompare(b)
        );
      }

      function parseDurationToMs(value) {
        if (value === null || value === undefined) {
          return null;
        }

        if (typeof value === "number" && Number.isFinite(value)) {
          return value * 1000;
        }

        if (typeof value !== "string") {
          value = String(value);
        }

        const trimmed = value.trim();
        if (!trimmed) {
          return null;
        }

        if (/^\d+(?::\d+){1,2}$/.test(trimmed)) {
          const parts = trimmed.split(":").map((part) => Number(part));
          if (parts.some((part) => Number.isNaN(part))) {
            return null;
          }
          while (parts.length < 3) {
            parts.unshift(0);
          }
          const [hours, minutes, seconds] = parts;
          return ((hours * 60 + minutes) * 60 + seconds) * 1000;
        }

        if (/^\d+(?:\.\d+)?$/.test(trimmed)) {
          const numeric = Number(trimmed);
          return Number.isFinite(numeric) ? numeric * 1000 : null;
        }

        let totalSeconds = 0;
        let matched = false;
        const regex =
          /(\d+(?:\.\d+)?)\s*(h(?:ours?)?|hr|hrs|m(?:in(?:ute)?s?)?|s(?:ec(?:ond)?s?)?)/gi;
        let match;
        while ((match = regex.exec(trimmed)) !== null) {
          matched = true;
          const quantity = parseFloat(match[1]);
          if (Number.isNaN(quantity)) {
            continue;
          }
          const unit = match[2].toLowerCase();
          if (unit.startsWith("h")) {
            totalSeconds += quantity * 3600;
          } else if (unit.startsWith("m")) {
            totalSeconds += quantity * 60;
          } else if (unit.startsWith("s")) {
            totalSeconds += quantity;
          }
        }

        if (matched && totalSeconds > 0) {
          return totalSeconds * 1000;
        }

        return null;
      }

      function computeProjectedFinishDate(jobProgress) {
        if (!jobProgress || typeof jobProgress !== "object") {
          return null;
        }

        const etaValue =
          jobProgress.eta !== undefined && jobProgress.eta !== null
            ? jobProgress.eta
            : jobProgress.ETA;
        const etaMs = parseDurationToMs(etaValue);
        if (etaMs === null) {
          return null;
        }

        const projected = new Date(Date.now() + etaMs);
        return Number.isNaN(projected.getTime()) ? null : projected;
      }

      function updatePlaylistBuildUi(playlist) {
        if (!playlist || !playlist._statusElements) {
          return;
        }

        const { indicator, line, message, button } = playlist._statusElements;
        const playlistName = (playlist.name || "").trim();
        const status = latestBuildStatus;
        const activeJob = status?.job || null;
        const activePlaylistName =
          activeJob && activeJob.type === "playlist"
            ? (activeJob.playlist || "").trim()
            : "";
        const activePlaylistsSet = collectActivePlaylistSet(status);
        const activePlaylistNames = Array.from(activePlaylistsSet);
        let isRunningThisPlaylist = Boolean(
          status?.running && playlistName && activePlaylistsSet.has(playlistName)
        );
        const isAllRunning = Boolean(status?.running && activeJob?.type === "all");
        const otherActiveNames = activePlaylistNames.filter(
          (name) => name !== playlistName
        );
        const normalizeWaitingNames = (names) =>
          Array.isArray(names)
            ? names
                .map((name) =>
                  name === null || name === undefined ? "" : String(name).trim()
                )
                .filter((name) => name.length > 0)
            : [];

        const waitingPlaylists = [
          ...normalizeWaitingNames(status?.waiting_playlists),
          ...normalizeWaitingNames(activeJob?.waiting_playlists),
        ];
        const waitingSet = new Set(waitingPlaylists);

        const isWaitingThisPlaylist = Boolean(
          playlistName &&
            !isRunningThisPlaylist &&
            waitingSet.has(playlistName)
        );

        if (isWaitingThisPlaylist) {
          isRunningThisPlaylist = false;
        }

        const coerceInteger = (value) => {
          if (typeof value === "number" && Number.isFinite(value)) {
            return value;
          }
          if (typeof value === "string") {
            const trimmed = value.trim();
            if (trimmed) {
              const parsed = Number.parseInt(trimmed, 10);
              if (Number.isFinite(parsed)) {
                return parsed;
              }
            }
          }
          return null;
        };

        let runningWorkers = coerceInteger(status?.running_workers);
        if (!Number.isFinite(runningWorkers) || runningWorkers < 0) {
          runningWorkers = 0;
        }

        let parallelLimit = coerceInteger(status?.parallel_limit);
        if (!Number.isFinite(parallelLimit) || parallelLimit < 1) {
          parallelLimit = 1;
        }

        let pendingJobs = coerceInteger(status?.pending_jobs);
        if (!Number.isFinite(pendingJobs) || pendingJobs < 0) {
          pendingJobs = 0;
        }

        const hasWorkerCapacity = runningWorkers < parallelLimit;
        const shouldShowQueueButton = Boolean(
          status?.running &&
            playlistName &&
            !isRunningThisPlaylist &&
            (isWaitingThisPlaylist || isAllRunning || !hasWorkerCapacity)
        );

        const playlistResults = status?.results?.playlists || {};
        const lastResult = playlistName ? playlistResults[playlistName] : undefined;

        let indicatorState = "idle";
        if (isRunningThisPlaylist) {
          indicatorState = "running";
        } else if (isWaitingThisPlaylist) {
          indicatorState = "waiting";
        } else if (lastResult) {
          if (lastResult.state === "success") {
            indicatorState = "success";
          } else if (lastResult.state === "error") {
            indicatorState = "error";
          } else if (lastResult.state === "stopped") {
            indicatorState = "stopped";
          }
        } else {
          indicatorState = "idle";
        }

        indicator.classList.remove(
          "running",
          "waiting",
          "idle",
          "error",
          "success",
          "stopped"
        );
        indicator.classList.add(indicatorState);

        let statusLineText = playlistName ? "Idle" : "Name required to build";
        if (isRunningThisPlaylist) {
          statusLineText = "Building now…";
        } else if (isWaitingThisPlaylist) {
          statusLineText = "Queued – waiting";
        }
        line.textContent = statusLineText;

        let detailText = "";
        if (isRunningThisPlaylist && status?.since) {
          detailText = `Started ${formatTimestamp(status.since)}`;
        }
        message.textContent = detailText;

        let buttonIcon = "▶";
        let baseTitle = playlistName
          ? "Build this playlist"
          : "Enter a playlist name to build it individually";

        if (isRunningThisPlaylist) {
          buttonIcon = "⏹";
          baseTitle = "Stop building this playlist";
          button.classList.add("danger");
          button.classList.remove("secondary");
        } else if (shouldShowQueueButton) {
          buttonIcon = "⏳";
          baseTitle = "Queue this playlist to build after the current jobs finish";
          button.classList.remove("danger");
          button.classList.add("secondary");
        } else {
          buttonIcon = "▶";
          button.classList.remove("danger");
          button.classList.remove("secondary");
        }

        button.textContent = buttonIcon;

        const disableButton = !playlistName;
        button.disabled = Boolean(disableButton);
        if (!playlistName) {
          const disabledTitle = "Enter a playlist name to build it individually.";
          button.title = disabledTitle;
          button.setAttribute("aria-label", disabledTitle);
        } else if (shouldShowQueueButton) {
          const queueHints = [];
          if (otherActiveNames.length === 1) {
            queueHints.push(`Currently building '${otherActiveNames[0]}'`);
          } else if (otherActiveNames.length > 1) {
            queueHints.push(`Currently building ${otherActiveNames.length} playlists`);
          } else if (isAllRunning) {
            queueHints.push("Currently building all playlists");
          } else if (activePlaylistName) {
            queueHints.push(`Currently building '${activePlaylistName}'`);
          }
          if (!hasWorkerCapacity) {
            if (parallelLimit === 1) {
              queueHints.push("Maximum simultaneous build reached");
            } else {
              queueHints.push(
                `Maximum of ${parallelLimit} concurrent builds already running`
              );
            }
          }
          if (pendingJobs > 0) {
            queueHints.push(
              `${pendingJobs} job${pendingJobs === 1 ? "" : "s"} already queued`
            );
          }
          queueHints.unshift(baseTitle);
          queueHints.push("Click to queue this playlist");
          const queueTitle = `${queueHints.join(". ")}.`;
          button.title = queueTitle;
          button.setAttribute("aria-label", queueTitle);
        } else {
          const baseTitleText = `${baseTitle}.`;
          button.title = baseTitleText;
          button.setAttribute("aria-label", baseTitleText);
        }

      }

      function updateBuildLogsUi(status) {
        if (!buildStatusPanel || !buildLogContainer) {
          return;
        }

        clearRateLimitCountdowns(buildLogContainer);

        const nowMs = Date.now();
        const running = Boolean(status?.running);
        const activePlaylists = getActivePlaylistNames(status);
        const activePlaylistsSet = new Set(activePlaylists);

        const normalizeWaitingNames = (names) =>
          Array.isArray(names)
            ? names
                .map((name) =>
                  name === null || name === undefined ? "" : String(name).trim()
                )
                .filter((name) => name.length > 0)
            : [];

        const waitingPlaylists = Array.from(
          new Set([
            ...normalizeWaitingNames(status?.waiting_playlists),
            ...normalizeWaitingNames(status?.job?.waiting_playlists),
          ])
        );
        const waitingSet = new Set(waitingPlaylists);

        if (waitingSet.size === 0) {
          waitingPlaylistOrder.clear();
          nextWaitingOrderValue = 1;
        } else {
          Array.from(waitingPlaylistOrder.keys()).forEach((name) => {
            if (!waitingSet.has(name)) {
              waitingPlaylistOrder.delete(name);
            }
          });
        }

        waitingPlaylists.forEach((name) => {
          if (!waitingPlaylistOrder.has(name)) {
            waitingPlaylistOrder.set(name, nextWaitingOrderValue++);
          }
        });
        const waitingOrder = new Map();
        waitingPlaylists.forEach((name, index) => {
          const orderValue = waitingPlaylistOrder.get(name);
          if (!waitingOrder.has(name)) {
            waitingOrder.set(
              name,
              orderValue !== undefined ? orderValue : index
            );
          }
        });

        const activeOrder = new Map();
        activePlaylists.forEach((name, index) => {
          if (!activeOrder.has(name)) {
            activeOrder.set(name, index);
          }
        });

        buildStatusPanel.classList.toggle("running", running);

        const rawLogsByPlaylist = status?.logs?.playlists || {};
        const logsByPlaylist = {};
        Object.entries(rawLogsByPlaylist).forEach(([rawName, rawEntries]) => {
          const trimmedName =
            typeof rawName === "string" ? rawName.trim() : "";
          if (!trimmedName) {
            return;
          }
          logsByPlaylist[trimmedName] = rawEntries;
        });
        const generalLogs = status?.logs?.general || [];

        const combinedNames = Object.keys(logsByPlaylist);
        activePlaylists.forEach((name) => {
          if (!combinedNames.includes(name)) {
            combinedNames.push(name);
          }
        });
        waitingPlaylists.forEach((name) => {
          if (!combinedNames.includes(name)) {
            combinedNames.push(name);
          }
        });

        const activeActivityKeys = new Set();

        const playlistNames = [];
        const seenNames = new Set();
        combinedNames.forEach((name) => {
          const trimmedName = (name || "").trim();
          if (!trimmedName || seenNames.has(trimmedName)) {
            return;
          }
          seenNames.add(trimmedName);
          playlistNames.push(trimmedName);
        });

        const getGroupRank = (name) => {
          if (activeOrder.has(name)) {
            return 0;
          }
          if (waitingOrder.has(name)) {
            return 1;
          }
          return 2;
        };

        playlistNames.sort((a, b) => {
          const groupDiff = getGroupRank(a) - getGroupRank(b);
          if (groupDiff !== 0) {
            return groupDiff;
          }

          if (activeOrder.has(a) && activeOrder.has(b)) {
            return activeOrder.get(a) - activeOrder.get(b);
          }

          if (waitingOrder.has(a) && waitingOrder.has(b)) {
            return waitingOrder.get(a) - waitingOrder.get(b);
          }

          return a.localeCompare(b);
        });

        buildLogContainer.innerHTML = "";

        const blocksToRender = [];
        let renderedGroups = 0;

        const playlistBlocks = [];

        playlistNames.forEach((trimmedName) => {
          const entries = logsByPlaylist[trimmedName] || [];
          const isWaiting = waitingSet.has(trimmedName);
          if (!entries.length && !running && !isWaiting) {
            return;
          }

          const block = document.createElement("div");
          block.className = "build-log-playlist";
          const isActivePlaylist =
            running &&
            activePlaylistsSet.has(trimmedName) &&
            !waitingSet.has(trimmedName);
          if (isActivePlaylist) {
            block.classList.add("is-active");
          }
          if (isWaiting) {
            block.classList.add("is-waiting");
          }

          const title = document.createElement("div");
          title.className = "build-log-playlist-title";
          title.textContent = trimmedName || "Unnamed Playlist";
          block.appendChild(title);

          const listEl = document.createElement("div");
          listEl.className = "build-log-playlist-entries";

          const normalizedEntries = Array.isArray(entries)
            ? entries.map((entry) => {
                if (entry && typeof entry === "object") {
                  return entry;
                }
                return {
                  type: "message",
                  text: typeof entry === "string" ? entry : String(entry ?? ""),
                };
              })
            : [];

          let hasContent = false;

          if (normalizedEntries.length) {
            const entry = normalizedEntries[normalizedEntries.length - 1];
            const entryKey = getPlaylistActivityKey(trimmedName, entry);
            if (entryKey) {
              activeActivityKeys.add(entryKey);
            }
            if (!entryKey || !dismissedActivityKeys.has(entryKey)) {
              const item = document.createElement("div");
              item.className = "playlist-log-entry";
              if (entryKey) {
                item.dataset.activityKey = entryKey;
              }

              const percentValue = normalizeProgressPercent(entry);
              const isProgressEntry =
                entry && entry.type === "progress" && percentValue !== null;
              const showSpinner =
                (isActivePlaylist || (isWaiting && running)) &&
                !isProgressEntry &&
                entry?.is_final !== true;

              if (isProgressEntry) {
                item.classList.add("progress-entry");
                const progressWrapper = document.createElement("div");
                progressWrapper.className = "playlist-log-bar";
                progressWrapper.setAttribute("role", "progressbar");
                progressWrapper.setAttribute("aria-valuemin", "0");
                progressWrapper.setAttribute("aria-valuemax", "100");
                const progressFill = document.createElement("span");
                const sanitizedPercent = Math.max(0, Math.min(100, percentValue));
                progressWrapper.setAttribute(
                  "aria-valuenow",
                  String(Math.round(sanitizedPercent))
                );
                progressFill.style.setProperty(
                  "--progress",
                  `${sanitizedPercent}%`
                );
                progressFill.style.width = `${sanitizedPercent}%`;
                progressWrapper.appendChild(progressFill);
                item.appendChild(progressWrapper);
              }

              const messageRow = document.createElement("div");
              messageRow.className = "playlist-log-message";

              if (showSpinner) {
                item.classList.add("is-active-step");
                const spinner = document.createElement("div");
                spinner.className = "playlist-log-spinner";
                messageRow.appendChild(spinner);
              }

              const text = document.createElement("div");
              text.className = "playlist-log-text";
              text.textContent = entry?.text || "";
              messageRow.appendChild(text);

              if (entryKey) {
                messageRow.appendChild(
                  createDismissButton(entryKey, { playlistName: trimmedName })
                );
              }

              item.appendChild(messageRow);
              listEl.appendChild(item);
              hasContent = true;
            }
          } else {
            const placeholder = document.createElement("div");
            placeholder.className = "playlist-log-entry";
            const showPlaceholderSpinner = isActivePlaylist || (isWaiting && running);
            if (showPlaceholderSpinner) {
              placeholder.classList.add("is-active-step");
            }

            const messageRow = document.createElement("div");
            messageRow.className = "playlist-log-message";

            if (showPlaceholderSpinner) {
              const spinner = document.createElement("div");
              spinner.className = "playlist-log-spinner";
              messageRow.appendChild(spinner);
            }

            const text = document.createElement("div");
            text.className = "playlist-log-text";
            if (isWaiting) {
              text.textContent = running
                ? "Queued – waiting to start…"
                : "Queued – waiting to start";
            } else {
              text.textContent = running
                ? "Waiting for playlist activity…"
                : "No recent activity.";
            }

            messageRow.appendChild(text);
            placeholder.appendChild(messageRow);
            listEl.appendChild(placeholder);
            hasContent = true;
          }

          if (!hasContent) {
            return;
          }

          block.appendChild(listEl);
          playlistBlocks.push(block);
        });

        if (playlistBlocks.length) {
          renderedGroups += playlistBlocks.length;
          playlistBlocks.forEach((block) => blocksToRender.push(block));
        }

        const normalizedGeneralEntries = generalLogs
          .map((entry) => normalizeGeneralLogEntry(entry))
          .filter((entry) => {
            if (!entry) {
              return false;
            }
            const textValue =
              typeof entry.text === "string" ? entry.text.trim() : "";
            if (!textValue) {
              return false;
            }
            entry.text = textValue;
            const timestampMs = parseTimestampMs(entry.timestamp);
            if (timestampMs === null) {
              return true;
            }
            return nowMs - timestampMs <= ACTIVITY_RETENTION_MS;
          })
          .slice(-3);

        if (normalizedGeneralEntries.length) {
          const block = document.createElement("div");
          block.className = "build-log-playlist general-activity";
          const title = document.createElement("div");
          title.className = "build-log-playlist-title";
          title.textContent = "General Activity";
          block.appendChild(title);

          const listEl = document.createElement("div");
          listEl.className = "build-log-playlist-entries";

          normalizedGeneralEntries.forEach((entry) => {
            const entryKey = getGeneralActivityKey(entry);
            if (entryKey) {
              activeActivityKeys.add(entryKey);
              if (dismissedActivityKeys.has(entryKey)) {
                return;
              }
            }

            const item = document.createElement("div");
            item.className = "playlist-log-entry general-entry";
            if (entryKey) {
              item.dataset.activityKey = entryKey;
            }
            const messageRow = document.createElement("div");
            messageRow.className = "playlist-log-message";

            const text = document.createElement("div");
            text.className = "playlist-log-text";
            text.textContent = entry.text || "";
            if (
              entry.rate_limit_resume_epoch !== undefined ||
              entry.rate_limit_resume
            ) {
              registerRateLimitCountdown(text, entry);
            }
            messageRow.appendChild(text);

            if (entryKey) {
              messageRow.appendChild(createDismissButton(entryKey));
            }

            item.appendChild(messageRow);
            listEl.appendChild(item);
          });

          if (listEl.childElementCount > 0) {
            block.appendChild(listEl);
            blocksToRender.push(block);
            renderedGroups += 1;
          }
        }

        const spotifyStatus = latestPopularityStatus || {};
        const spotifyHeadline = getSpotifyStatusHeadline(spotifyStatus);
        const spotifyMessage = (spotifyStatus.message || "").trim();
        const spotifyResumeMs = resolveResumeTimestampMs(spotifyStatus);
        const hasRateLimit = Boolean(
          spotifyStatus &&
            (spotifyStatus.rate_limit_resume_epoch ||
              spotifyStatus.rate_limit_resume)
        );
        const shouldShowSpotifyMessage = Boolean(spotifyMessage || hasRateLimit);
        const hasActiveRateLimitCountdown =
          spotifyResumeMs !== null && spotifyResumeMs > nowMs;
        const hasRunningSpotify = Boolean(spotifyStatus?.running);
        const lastSpotifyActivityMs =
          parseTimestampMs(spotifyStatus.last_log_at) ??
          parseTimestampMs(spotifyStatus.finished_at) ??
          parseTimestampMs(spotifyStatus.started_at);
        const isSpotifyStale =
          !hasRunningSpotify &&
          !hasActiveRateLimitCountdown &&
          lastSpotifyActivityMs !== null &&
          nowMs - lastSpotifyActivityMs > ACTIVITY_RETENTION_MS;

        if ((spotifyHeadline || shouldShowSpotifyMessage) && !isSpotifyStale) {
          const block = document.createElement("div");
          block.className = "build-log-playlist spotify-activity";
          const title = document.createElement("div");
          title.className = "build-log-playlist-title";
          title.textContent = "Spotify Activity";
          block.appendChild(title);

          const listEl = document.createElement("div");
          listEl.className = "build-log-playlist-entries";

          if (spotifyHeadline) {
            const headlineKey = getSpotifyActivityKey("headline", spotifyHeadline, [
              spotifyStatus.started_at,
              spotifyStatus.finished_at,
              spotifyStatus.last_log_at,
            ]);
            if (headlineKey) {
              activeActivityKeys.add(headlineKey);
            }
            if (!headlineKey || !dismissedActivityKeys.has(headlineKey)) {
              const statusEntry = document.createElement("div");
              statusEntry.className = "playlist-log-entry general-entry";
              if (headlineKey) {
                statusEntry.dataset.activityKey = headlineKey;
              }
              const statusRow = document.createElement("div");
              statusRow.className = "playlist-log-message";
              const statusText = document.createElement("div");
              statusText.className = "playlist-log-text";
              statusText.textContent = spotifyHeadline;
              statusRow.appendChild(statusText);
              if (headlineKey) {
                statusRow.appendChild(createDismissButton(headlineKey));
              }
              statusEntry.appendChild(statusRow);
              listEl.appendChild(statusEntry);
            }
          }

          if (shouldShowSpotifyMessage) {
            const baseText = spotifyMessage || "Spotify rate limit reached.";
            const messageKey = getSpotifyActivityKey("message", baseText, [
              spotifyStatus.rate_limit_resume_epoch,
              spotifyStatus.rate_limit_resume,
              spotifyStatus.last_log_at,
            ]);
            if (messageKey) {
              activeActivityKeys.add(messageKey);
            }
            if (!messageKey || !dismissedActivityKeys.has(messageKey)) {
              const messageEntry = document.createElement("div");
              messageEntry.className = "playlist-log-entry general-entry";
              if (messageKey) {
                messageEntry.dataset.activityKey = messageKey;
              }
              const messageRow = document.createElement("div");
              messageRow.className = "playlist-log-message";
              const messageTextEl = document.createElement("div");
              messageTextEl.className = "playlist-log-text";
              messageTextEl.textContent = baseText;
              messageRow.appendChild(messageTextEl);
              if (messageKey) {
                messageRow.appendChild(createDismissButton(messageKey));
              }
              messageEntry.appendChild(messageRow);
              listEl.appendChild(messageEntry);

              if (hasRateLimit) {
                registerRateLimitCountdown(messageTextEl, {
                  text: baseText,
                  rate_limit_resume_epoch: spotifyStatus.rate_limit_resume_epoch,
                  rate_limit_resume: spotifyStatus.rate_limit_resume,
                  timestamp: spotifyStatus.last_log_at,
                });
              }
            }
          }

          if (listEl.childElementCount > 0) {
            block.appendChild(listEl);
            blocksToRender.push(block);
            renderedGroups += 1;
          }
        }

        blocksToRender.forEach((block) => buildLogContainer.appendChild(block));

        if (dismissedActivityKeys.size) {
          dismissedActivityKeys.forEach((key) => {
            if (!activeActivityKeys.has(key)) {
              dismissedActivityKeys.delete(key);
            }
          });
        }

        if (!renderedGroups) {
          const empty = document.createElement("div");
          empty.className = "playlist-log-empty";
          empty.textContent = running
            ? "Waiting for playlist activity…"
            : "No playlist activity recorded yet.";
          buildLogContainer.appendChild(empty);
        }
      }

      function updateBuildStatusUi(status) {
        if (!status) {
          return;
        }

        latestBuildStatus = status;
        updateBuildLogsUi(status);
        const isRunning = Boolean(status.running);
        const activeJob = status.job || null;
        const isAllRunning = Boolean(isRunning && activeJob?.type === "all");
        let indicatorState = "idle";
        if (isRunning) {
          indicatorState = "running";
        } else if (status.status === "error") {
          indicatorState = "error";
        } else if (status.status === "success") {
          indicatorState = "success";
        } else if (status.status === "stopped") {
          indicatorState = "stopped";
        }

        buildStatusIndicator.classList.remove(
          "running",
          "waiting",
          "idle",
          "error",
          "success",
          "stopped"
        );
        buildStatusIndicator.classList.add(indicatorState);

        let statusTextValue = "Idle";
        if (indicatorState === "running") {
          statusTextValue = "Building";
        } else if (indicatorState === "success") {
          statusTextValue = "Completed";
        } else if (indicatorState === "stopped") {
          statusTextValue = "Stopped";
        } else if (indicatorState === "error") {
          statusTextValue = "Error";
        }
        buildStatusText.textContent = statusTextValue;

        const jobProgress = activeJob?.progress;
        let statusMessageValue = status.message || "";
        const normalizedJobPercent = jobProgress
          ? normalizeProgressPercent(jobProgress)
          : null;
        if (
          isRunning &&
          jobProgress &&
          normalizedJobPercent !== null
        ) {
          const percentValue = normalizedJobPercent;
          const currentCandidate = Number(jobProgress.current);
          const totalCandidate = Number(jobProgress.total);
          const currentValue = Number.isFinite(currentCandidate)
            ? Math.max(0, Math.floor(currentCandidate))
            : null;
          const totalValue = Number.isFinite(totalCandidate)
            ? Math.max(0, Math.floor(totalCandidate))
            : null;
          const percentDisplay = Math.round(Math.max(0, Math.min(100, percentValue)));
          const totalText =
            currentValue !== null && totalValue !== null
              ? `${currentValue}/${totalValue}`
              : currentValue !== null
              ? `${currentValue}`
              : null;

          statusMessageValue = totalText
            ? `Filtering tracks… ${totalText} (${percentDisplay}%)`
            : `Filtering tracks… ${percentDisplay}%`;

          if (jobProgress.rate) {
            statusMessageValue = `${statusMessageValue} – ${jobProgress.rate}`;
          } else if (jobProgress.details) {
            statusMessageValue = `${statusMessageValue} ${jobProgress.details}`;
          }
        }

        buildStatusMessage.textContent = statusMessageValue;

        const projectedFinish = isRunning
          ? computeProjectedFinishDate(jobProgress)
          : null;
        const metaParts = [];
        if (isRunning && status.pid) {
          metaParts.push(`PID ${status.pid}`);
        }
        if (isRunning && status.since) {
          metaParts.push(`Started ${formatTimestamp(status.since)}`);
        }
        if (isRunning && projectedFinish) {
          metaParts.push(
            `Projected finish ${formatTimestamp(projectedFinish.toISOString())}`
          );
        }
        if (!isRunning) {
          const lastAllResult = status.results?.all;
          const lastFinishedIso = status.last_finished;
          if (
            lastAllResult?.finished_at &&
            (!lastFinishedIso || lastAllResult.finished_at === lastFinishedIso)
          ) {
            let label = "Last build finished";
            if (lastAllResult.state === "success") {
              label = "Last build completed";
            } else if (lastAllResult.state === "stopped") {
              label = "Last build stopped";
            } else if (lastAllResult.state === "error") {
              label = "Last build failed";
            }
            metaParts.push(`${label} ${formatTimestamp(lastAllResult.finished_at)}`);
          } else if (status.last_finished) {
            metaParts.push(`Last finished ${formatTimestamp(status.last_finished)}`);
          }
          if (typeof status.exit_code === "number") {
            metaParts.push(`Last exit code ${status.exit_code}`);
          }
        }
        buildStatusMeta.textContent = metaParts.join(" • ");

        buildToggleBtn.textContent = isAllRunning ? "⏹" : "▶";
        buildToggleBtn.classList.toggle("danger", isAllRunning);
        buildToggleBtn.disabled = Boolean(status.transitioning || (isRunning && !isAllRunning));
        let toggleTitle = "Build all playlists.";
        if (isRunning && !isAllRunning) {
          toggleTitle = "A playlist build is currently running.";
        } else if (isAllRunning) {
          toggleTitle = "Stop building all playlists.";
        }
        buildToggleBtn.title = toggleTitle;
        buildToggleBtn.setAttribute("aria-label", toggleTitle);

        if (Array.isArray(state.playlists)) {
          state.playlists.forEach((playlist) => updatePlaylistBuildUi(playlist));
        }
      }

      async function refreshBuildStatus(showErrors = false) {
        try {
          const response = await fetch("/api/build/status");
          if (!response.ok) {
            throw new Error("Unable to retrieve build status");
          }
          const status = await response.json();
          updateBuildStatusUi(status);
        } catch (error) {
          console.error(error);
          if (showErrors) {
            showMessage(error.message, true);
          }
        }
      }

      async function toggleBuild() {
        const isRunningAll = Boolean(
          latestBuildStatus?.running && latestBuildStatus?.job?.type === "all"
        );
        const anotherJobRunning = Boolean(
          latestBuildStatus?.running && !isRunningAll
        );
        if (anotherJobRunning) {
          showMessage("A playlist build is currently running. Stop it before starting a full build.", true);
          return;
        }

        const endpoint = isRunningAll ? "/api/build/stop" : "/api/build/start";

        buildToggleBtn.disabled = true;
        try {
          if (!isRunningAll) {
            await saveData({ showSuccessMessage: false, rethrowOnError: true });
          }

          const response = await fetch(endpoint, { method: "POST" });
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(
              result.message ||
                (isRunningAll ? "Failed to stop build." : "Failed to start build.")
            );
          }

          if (result.status) {
            updateBuildStatusUi(result.status);
          } else {
            await refreshBuildStatus();
          }

          if (result.message) {
            showMessage(result.message, false);
          } else {
            showMessage(isRunningAll ? "Build stopping..." : "Build starting...");
          }

          setTimeout(() => {
            refreshBuildStatus();
          }, 1000);
        } catch (error) {
          console.error(error);
          if (!error?._fromSaveData) {
            showMessage(error.message, true);
          }
        } finally {
          buildToggleBtn.disabled = false;
        }
      }

      async function togglePlaylistBuild(playlist) {
        const playlistName = (playlist?.name || "").trim();
        if (!playlistName) {
          showMessage("Please name the playlist before building it.", true);
          return;
        }

        const activePlaylistsSet = collectActivePlaylistSet(latestBuildStatus);
        const isRunningThisPlaylist = Boolean(
          latestBuildStatus?.running &&
            activePlaylistsSet.has(playlistName)
        );

        const elements = playlist._statusElements || {};
        if (elements.button) {
          elements.button.disabled = true;
        }

        const endpoint = isRunningThisPlaylist ? "/api/build/stop" : "/api/build/start";
        const options = { method: "POST" };
        if (!isRunningThisPlaylist) {
          options.headers = { "Content-Type": "application/json" };
          options.body = JSON.stringify({ playlist: playlistName });
        }

        try {
          if (!isRunningThisPlaylist) {
            await savePlaylist(
              playlist,
              undefined,
              elements.headerTitle,
              elements.nameInput,
              { showSuccessMessage: false, rethrowOnError: true }
            );
          }

          const response = await fetch(endpoint, options);
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(
              result.message ||
                (isRunningThisPlaylist
                  ? "Failed to stop playlist build."
                  : "Failed to start playlist build.")
            );
          }

          if (result.status) {
            updateBuildStatusUi(result.status);
          } else {
            await refreshBuildStatus();
          }

          if (result.message) {
            showMessage(result.message);
          } else {
            showMessage(
              isRunningThisPlaylist
                ? `Stopping '${playlistName}'...`
                : `Starting '${playlistName}'...`
            );
          }

          setTimeout(() => {
            refreshBuildStatus();
          }, 1000);
        } catch (error) {
          console.error(error);
          if (!error?._fromSavePlaylist) {
            showMessage(error.message, true);
          }
        } finally {
          if (elements.button) {
            elements.button.disabled = false;
          }
          updatePlaylistBuildUi(playlist);
        }
      }

      function ensureExtras(target) {
        if (!target.extras || typeof target.extras !== "object") {
          target.extras = {};
        }
        return target.extras;
      }

      function sanitizeExtras(extras) {
        const sanitized = {};
        Object.entries(extras || {}).forEach(([key, value]) => {
          if (value === undefined || value === null) {
            return;
          }
          const trimmed = String(value).trim();
          if (trimmed) {
            sanitized[key] = trimmed;
          }
        });
        return sanitized;
      }

      function setupPathAutocomplete(inputEl, suggestionsEl, playlist, extrasKey) {
        const extras = ensureExtras(playlist);
        let debounceTimer = null;
        let controller = null;

        function hideSuggestions() {
          suggestionsEl.classList.remove("show");
          suggestionsEl.innerHTML = "";
        }

        function renderSuggestions(entries) {
          if (!entries.length) {
            hideSuggestions();
            return;
          }
          suggestionsEl.innerHTML = "";
          entries.forEach((entry) => {
            const optionBtn = document.createElement("button");
            optionBtn.type = "button";
            optionBtn.textContent = entry.display;
            optionBtn.addEventListener("mousedown", (event) => {
              event.preventDefault();
              const suggestion = entry.suggestion;
              inputEl.value = suggestion;
              extras[extrasKey] = suggestion;
              hideSuggestions();
            });
            suggestionsEl.appendChild(optionBtn);
          });
          suggestionsEl.classList.add("show");
        }

        async function requestSuggestions(value) {
          if (controller) {
            controller.abort();
          }

          controller = new AbortController();
          const { signal } = controller;

          const params = new URLSearchParams();
          if (value) {
            params.set("path", value);
          }
          const query = params.toString();
          const url = query
            ? `/api/list_directory?${query}`
            : "/api/list_directory";

          try {
            const response = await fetch(url, {
              signal,
            });
            if (!response.ok) {
              throw new Error("Unable to fetch directory suggestions");
            }
            const data = await response.json();
            if (signal.aborted) {
              return;
            }
            renderSuggestions(data.entries || []);
          } catch (error) {
            if (signal.aborted) {
              return;
            }
            console.error(error);
            hideSuggestions();
          }
        }

        function scheduleSuggestions(value) {
          if (debounceTimer) {
            clearTimeout(debounceTimer);
          }
          debounceTimer = setTimeout(() => {
            requestSuggestions(value);
          }, 180);
        }

        inputEl.addEventListener("input", (event) => {
          const value = event.target.value;
          extras[extrasKey] = value;
          scheduleSuggestions(value);
        });

        inputEl.addEventListener("focus", () => {
          scheduleSuggestions(inputEl.value);
        });

        inputEl.addEventListener("blur", () => {
          setTimeout(hideSuggestions, 150);
        });
      }

      function createOptionElements(selectEl, opts, selectedValue = "") {
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select...";
        selectEl.appendChild(placeholder);

        opts.forEach((opt) => {
          const option = document.createElement("option");
          option.value = opt.value;
          option.textContent = opt.label;
          if (opt.value === selectedValue) {
            option.selected = true;
          }
          selectEl.appendChild(option);
        });
      }

      function renderFilters(containerEl, filters, onRemove) {
        containerEl.innerHTML = "";

        if (!filters.length) {
          const emptyState = document.createElement("p");
          emptyState.className = "no-filters";
          emptyState.textContent = "No filters configured.";
          containerEl.appendChild(emptyState);
        }

        filters.forEach((filter, index) => {
          const row = document.createElement("div");
          row.className = "filter-row";

          const fieldSelect = document.createElement("select");
          createOptionElements(fieldSelect, options.fields, filter.field || "");
          fieldSelect.value = filter.field || "";
          fieldSelect.addEventListener("change", (event) => {
            filter.field = event.target.value;
          });

          const operatorSelect = document.createElement("select");
          createOptionElements(operatorSelect, options.operators, filter.operator || "equals");
          operatorSelect.value = filter.operator || "";
          operatorSelect.addEventListener("change", (event) => {
            filter.operator = event.target.value;
          });

          const valueWrapper = document.createElement("div");
          valueWrapper.className = "value-input";
          const valueInput = document.createElement("input");
          valueInput.type = "text";
          valueInput.placeholder = "Value (comma separated for multiple)";
          valueInput.value = filter.value || "";
          valueInput.addEventListener("input", (event) => {
            filter.value = event.target.value;
          });

          const flagsWrapper = document.createElement("div");
          flagsWrapper.className = "filter-flags";

          const matchAllLabel = document.createElement("label");
          matchAllLabel.className = "filter-flag";
          const matchAllInput = document.createElement("input");
          matchAllInput.type = "checkbox";
          matchAllInput.checked = filter.match_all !== undefined ? !!filter.match_all : true;
          matchAllInput.setAttribute("aria-label", "Match all values");
          matchAllInput.addEventListener("change", (event) => {
            filter.match_all = event.target.checked;
          });
          matchAllLabel.appendChild(matchAllInput);
          matchAllLabel.appendChild(document.createTextNode("Match All"));
          flagsWrapper.appendChild(matchAllLabel);

          const wildcardLabel = document.createElement("label");
          wildcardLabel.className = "filter-flag";
          const wildcardInput = document.createElement("input");
          wildcardInput.type = "checkbox";
          wildcardInput.checked = !!filter.wildcard;
          wildcardInput.setAttribute(
            "aria-label",
            "Wildcard (ignore other filters)"
          );
          wildcardInput.addEventListener("change", (event) => {
            filter.wildcard = event.target.checked;
          });
          wildcardLabel.appendChild(wildcardInput);
          wildcardLabel.appendChild(document.createTextNode("🔥"));
          flagsWrapper.appendChild(wildcardLabel);

          valueWrapper.appendChild(valueInput);

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "icon-only danger";
          removeBtn.textContent = "✕";
          removeBtn.title = "Remove filter";
          removeBtn.addEventListener("click", () => onRemove(index));

          row.appendChild(fieldSelect);
          row.appendChild(operatorSelect);
          row.appendChild(valueWrapper);
          row.appendChild(flagsWrapper);
          row.appendChild(removeBtn);

          containerEl.appendChild(row);
        });
      }

      function renderPopularityBoosts(containerEl, boosts, onRemove) {
        containerEl.innerHTML = "";

        if (!Array.isArray(boosts) || boosts.length === 0) {
          const emptyState = document.createElement("p");
          emptyState.className = "no-filters";
          emptyState.textContent = "No boost rules configured.";
          containerEl.appendChild(emptyState);
          return;
        }

        boosts.forEach((boost, index) => {
          const row = document.createElement("div");
          row.className = "filter-row boost-row";

          const fieldSelect = document.createElement("select");
          createOptionElements(fieldSelect, options.fields, boost.field || "");
          fieldSelect.value = boost.field || "";
          fieldSelect.addEventListener("change", (event) => {
            boost.field = event.target.value;
          });
          row.appendChild(fieldSelect);

          const operatorSelect = document.createElement("select");
          createOptionElements(
            operatorSelect,
            options.operators,
            boost.operator || "equals"
          );
          operatorSelect.value = boost.operator || "equals";
          operatorSelect.addEventListener("change", (event) => {
            boost.operator = event.target.value;
          });
          row.appendChild(operatorSelect);

          const valueWrapper = document.createElement("div");
          valueWrapper.className = "value-input";
          const valueInput = document.createElement("input");
          valueInput.type = "text";
          valueInput.placeholder = "Value";
          valueInput.value = boost.value || "";
          valueInput.addEventListener("input", (event) => {
            boost.value = event.target.value;
          });
          valueWrapper.appendChild(valueInput);
          row.appendChild(valueWrapper);

          const flagsWrapper = document.createElement("div");
          flagsWrapper.className = "filter-flags";
          const matchAllLabel = document.createElement("label");
          matchAllLabel.className = "filter-flag";
          const matchAllInput = document.createElement("input");
          matchAllInput.type = "checkbox";
          const normalizedMatchAll =
            boost.match_all !== undefined ? !!boost.match_all : true;
          matchAllInput.checked = normalizedMatchAll;
          matchAllInput.setAttribute(
            "aria-label",
            "Require a track to match every listed value"
          );
          boost.match_all = normalizedMatchAll;
          matchAllInput.addEventListener("change", (event) => {
            boost.match_all = event.target.checked;
          });
          matchAllLabel.appendChild(matchAllInput);
          matchAllLabel.appendChild(document.createTextNode("Match All"));
          flagsWrapper.appendChild(matchAllLabel);
          row.appendChild(flagsWrapper);

          const boostWrapper = document.createElement("div");
          boostWrapper.className = "boost-input";
          const boostInput = document.createElement("input");
          boostInput.type = "number";
          boostInput.min = "0";
          boostInput.step = "0.1";
          boostInput.placeholder = "Multiplier";
          const hasExistingMultiplier =
            boost.boost !== undefined && boost.boost !== null && boost.boost !== "";
          if (hasExistingMultiplier) {
            const normalized = normalizePopularityBoostMultiplier(boost.boost);
            boost.boost = normalized;
            boostInput.value = String(normalized);
          } else {
            boost.boost = undefined;
          }
          boostInput.addEventListener("input", (event) => {
            const { value } = event.target;
            const parsed = Number.parseFloat(value);
            if (Number.isFinite(parsed) && parsed >= 0) {
              boost.boost = parsed;
            } else if (value.trim() === "") {
              boost.boost = undefined;
            }
          });
          boostInput.addEventListener("blur", (event) => {
            const { value } = event.target;
            const trimmed = value.trim();
            if (trimmed === "") {
              boost.boost = undefined;
              event.target.value = "";
              return;
            }
            const parsed = Number.parseFloat(value);
            if (!Number.isFinite(parsed) || parsed < 0) {
              const normalized = normalizePopularityBoostMultiplier(value);
              boost.boost = normalized;
              event.target.value = String(normalized);
            } else {
              boost.boost = parsed;
              event.target.value = String(parsed);
            }
          });
          boostWrapper.appendChild(boostInput);
          row.appendChild(boostWrapper);

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "icon-only danger";
          removeBtn.textContent = "✕";
          removeBtn.title = "Remove popularity boost rule";
          removeBtn.addEventListener("click", () => {
            if (typeof onRemove === "function") {
              onRemove(index);
            }
          });
          row.appendChild(removeBtn);

          containerEl.appendChild(row);
        });
      }

      function updatePlaylistCollapseUi(playlist) {
        if (!playlist || typeof playlist !== "object") {
          return;
        }

        const elements = playlist._collapseElements || {};
        const { card, toggleButton } = elements;
        const isCollapsed = !!playlist._collapsed;
        const label = isCollapsed
          ? "Expand playlist details"
          : "Collapse playlist details";

        if (card) {
          card.classList.toggle("is-collapsed", isCollapsed);
        }

        if (toggleButton) {
          toggleButton.textContent = isCollapsed ? "▸" : "▾";
          toggleButton.setAttribute("aria-expanded", isCollapsed ? "false" : "true");
          toggleButton.setAttribute("aria-label", label);
          toggleButton.title = label;
        }
      }

      function scrollPlaylistIntoView(playlist) {
        if (!playlist) {
          return;
        }

        const schedule =
          (typeof window !== "undefined" && window.requestAnimationFrame) ||
          ((callback) => setTimeout(callback, 16));

        schedule(() => {
          const card = playlist._collapseElements?.card;
          if (card && typeof card.scrollIntoView === "function") {
            card.scrollIntoView({ behavior: "smooth", block: "start" });
          }
        });
      }

      function normalizeTop5Boost(value) {
        const parsed = Number.parseFloat(value);
        if (!Number.isFinite(parsed) || parsed < 0) {
          return 1.0;
        }
        return parsed;
      }

      function normalizePopularityBoostMultiplier(value) {
        const parsed = Number.parseFloat(value);
        if (!Number.isFinite(parsed) || parsed < 0) {
          return 1.0;
        }
        return parsed;
      }

      function createPlaylistDuplicate(sourcePlaylist) {
        const duplicate = {};

        if (sourcePlaylist && typeof sourcePlaylist === "object") {
          Object.entries(sourcePlaylist).forEach(([key, value]) => {
            if (
              key === "name" ||
              key === "_originalName" ||
              key === "_statusElements" ||
              key === "_collapseElements"
            ) {
              return;
            }

            if (key === "plex_filter") {
              if (Array.isArray(value)) {
                duplicate.plex_filter = value.map((filter) => {
                  const clonedFilter = { ...filter };
                  if (Array.isArray(filter?.value)) {
                    clonedFilter.value = [...filter.value];
                  } else if (
                    filter &&
                    typeof filter.value === "object" &&
                    filter.value !== null
                  ) {
                    clonedFilter.value = JSON.parse(JSON.stringify(filter.value));
                  }
                  return clonedFilter;
                });
              }
              return;
            }

            if (key === "popularity_boosts") {
              if (Array.isArray(value)) {
                duplicate.popularity_boosts = value.map((boost) => {
                  const clonedBoost = { ...boost };
                  if (
                    boost &&
                    typeof boost.value === "object" &&
                    boost.value !== null
                  ) {
                    clonedBoost.value = JSON.parse(JSON.stringify(boost.value));
                  }
                  return clonedBoost;
                });
              }
              return;
            }

            if (key === "extras") {
              if (value && typeof value === "object") {
                duplicate.extras = JSON.parse(JSON.stringify(value));
              }
              return;
            }

            if (typeof value === "object" && value !== null) {
              try {
                duplicate[key] = JSON.parse(JSON.stringify(value));
              } catch (error) {
                duplicate[key] = value;
              }
            } else {
              duplicate[key] = value;
            }
          });
        }

        duplicate.name = "New Playlist";
        duplicate._originalName = "";
        duplicate.limit = duplicate.limit ?? 0;
        duplicate.artist_limit = duplicate.artist_limit ?? 0;
        duplicate.album_limit = duplicate.album_limit ?? 0;
        duplicate.sort_by = duplicate.sort_by || "";
        duplicate.top_5_boost = normalizeTop5Boost(
          duplicate.top_5_boost ?? 1.0
        );
        if (!Array.isArray(duplicate.plex_filter)) {
          duplicate.plex_filter = [];
        }
        if (!Array.isArray(duplicate.popularity_boosts)) {
          duplicate.popularity_boosts = [];
        }
        if (!duplicate.extras || typeof duplicate.extras !== "object") {
          duplicate.extras = {};
        }

        duplicate._collapsed = false;

        return duplicate;
      }


      function renderPlaylists() {
        playlistsContainer.innerHTML = "";

        const hasPlaylists = state.playlists.length > 0;

        if (expandAllPlaylistsBtn) {
          expandAllPlaylistsBtn.disabled = !hasPlaylists;
        }

        if (collapseAllPlaylistsBtn) {
          collapseAllPlaylistsBtn.disabled = !hasPlaylists;
        }

        if (!hasPlaylists) {
          const empty = document.createElement("p");
          empty.className = "no-filters";
          empty.textContent = "No playlists yet. Add one to get started.";
          playlistsContainer.appendChild(empty);
          return;
        }

        state.playlists.forEach((playlist, index) => {
          if (typeof playlist._collapsed !== "boolean") {
            playlist._collapsed = false;
          }

          if (!Array.isArray(playlist.popularity_boosts)) {
            playlist.popularity_boosts = [];
          }
          if (typeof playlist._boostsOpen !== "boolean") {
            playlist._boostsOpen = false;
          }

          const card = document.createElement("div");
          card.className = "card playlist-card";

          const header = document.createElement("div");
          header.className = "playlist-header";

          const titleWrapper = document.createElement("div");
          titleWrapper.className = "playlist-header-title";

          const toggleBtn = document.createElement("button");
          toggleBtn.type = "button";
          toggleBtn.className = "icon-only secondary playlist-collapse-btn";

          const title = document.createElement("h3");
          title.textContent = playlist.name || "Untitled Playlist";

          titleWrapper.appendChild(toggleBtn);
          titleWrapper.appendChild(title);

          const statusGroup = document.createElement("div");
          statusGroup.className = "playlist-status";

          const statusIndicator = document.createElement("span");
          statusIndicator.className = "status-indicator idle";

          const statusTextWrapper = document.createElement("div");
          statusTextWrapper.className = "playlist-status-text";

          const statusLine = document.createElement("div");
          statusLine.className = "playlist-status-line";
          statusLine.textContent = "Not built yet";

          const statusMessage = document.createElement("div");
          statusMessage.className = "playlist-status-message";

          statusTextWrapper.appendChild(statusLine);
          statusTextWrapper.appendChild(statusMessage);
          statusGroup.appendChild(statusIndicator);
          statusGroup.appendChild(statusTextWrapper);

          const saveBtn = document.createElement("button");
          saveBtn.type = "button";
          saveBtn.className = "icon-only";
          saveBtn.textContent = "💾";
          saveBtn.setAttribute("aria-label", "Save playlist");
          saveBtn.title = "Save this playlist to playlists.yml";

          const buildBtn = document.createElement("button");
          buildBtn.type = "button";
          buildBtn.className = "playlist-build-btn icon-only";
          buildBtn.textContent = "▶";
          buildBtn.setAttribute("aria-label", "Build this playlist");
          buildBtn.title = "Build this playlist.";
          buildBtn.addEventListener("click", () => togglePlaylistBuild(playlist));

          const duplicateBtn = document.createElement("button");
          duplicateBtn.type = "button";
          duplicateBtn.className = "icon-only secondary";
          duplicateBtn.textContent = "⧉";
          duplicateBtn.setAttribute("aria-label", "Duplicate playlist");
          duplicateBtn.title = "Duplicate playlist";
          duplicateBtn.addEventListener("click", () => {
            const duplicate = createPlaylistDuplicate(playlist);
            state.playlists.splice(index + 1, 0, duplicate);
            renderPlaylists();
            scrollPlaylistIntoView(duplicate);
          });

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "icon-only danger";
          removeBtn.textContent = "✕";
          removeBtn.setAttribute("aria-label", "Delete playlist");
          removeBtn.title = "Delete playlist";
          removeBtn.addEventListener("click", () => {
            const playlistName = (playlist.name || "").trim();
            const confirmationMessage = playlistName
              ? `Are you sure you want to delete "${playlistName}"?\nThis action cannot be undone.`
              : `Are you sure you want to delete this playlist?\nThis action cannot be undone.`;
            if (!confirm(confirmationMessage)) {
              return;
            }

            delete playlist._statusElements;
            delete playlist._collapseElements;
            state.playlists.splice(index, 1);
            renderPlaylists();
          });

          header.appendChild(titleWrapper);
          header.appendChild(statusGroup);
          const actionButtons = document.createElement("div");
          actionButtons.className = "playlist-action-buttons";
          actionButtons.appendChild(saveBtn);
          actionButtons.appendChild(buildBtn);
          actionButtons.appendChild(duplicateBtn);
          actionButtons.appendChild(removeBtn);
          header.appendChild(actionButtons);
          const inlineMessage = document.createElement("div");
          inlineMessage.className = "playlist-inline-message";
          header.appendChild(inlineMessage);
          card.appendChild(header);

          const details = document.createElement("div");
          details.className = "playlist-details";
          card.appendChild(details);

          const extras = ensureExtras(playlist);

          const grid = document.createElement("div");
          grid.className = "input-grid";

          const nameLabel = document.createElement("label");
          nameLabel.textContent = "Playlist Name";
          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.value = playlist.name || "";
          nameInput.addEventListener("input", (event) => {
            playlist.name = event.target.value;
            title.textContent = event.target.value || "Untitled Playlist";
            updatePlaylistBuildUi(playlist);
          });
          nameLabel.appendChild(nameInput);

          playlist._statusElements = {
            indicator: statusIndicator,
            line: statusLine,
            message: statusMessage,
            button: buildBtn,
            headerTitle: title,
            nameInput,
            inlineMessage,
          };
          playlist._inlineMessageEl = inlineMessage;
          updatePlaylistBuildUi(playlist);

          saveBtn.addEventListener("click", () =>
            savePlaylist(playlist, saveBtn, title, nameInput)
          );

          const limitLabel = document.createElement("label");
          limitLabel.textContent = "Limit";
          const limitInput = document.createElement("input");
          limitInput.type = "number";
          limitInput.min = "0";
          limitInput.value = playlist.limit ?? 0;
          limitInput.addEventListener("input", (event) => {
            playlist.limit = event.target.value;
          });
          limitLabel.appendChild(limitInput);

          const artistLimitLabel = document.createElement("label");
          artistLimitLabel.textContent = "Artist Limit";
          const artistLimitInput = document.createElement("input");
          artistLimitInput.type = "number";
          artistLimitInput.min = "0";
          artistLimitInput.value = playlist.artist_limit ?? 0;
          artistLimitInput.addEventListener("input", (event) => {
            playlist.artist_limit = event.target.value;
          });
          artistLimitLabel.appendChild(artistLimitInput);

          const albumLimitLabel = document.createElement("label");
          albumLimitLabel.textContent = "Album Limit";
          const albumLimitInput = document.createElement("input");
          albumLimitInput.type = "number";
          albumLimitInput.min = "0";
          albumLimitInput.value = playlist.album_limit ?? 0;
          albumLimitInput.addEventListener("input", (event) => {
            playlist.album_limit = event.target.value;
          });
          albumLimitLabel.appendChild(albumLimitInput);

          const sortLabel = document.createElement("label");
          sortLabel.textContent = "Sort By";
          const sortSelect = document.createElement("select");
          const sortFieldValues = options.sort_fields.map((opt) => opt.value);
          if (
            (!playlist.sort_by || !sortFieldValues.includes(playlist.sort_by)) &&
            options.sort_fields.length
          ) {
            playlist.sort_by = options.sort_fields[0].value;
          }
          options.sort_fields.forEach((opt) => {
            const option = document.createElement("option");
            option.value = opt.value;
            option.textContent = opt.label;
            sortSelect.appendChild(option);
          });
          sortSelect.value = playlist.sort_by || "";
          sortSelect.addEventListener("change", (event) => {
            playlist.sort_by = event.target.value;
          });
          sortLabel.appendChild(sortSelect);

          const top5BoostLabel = document.createElement("label");
          top5BoostLabel.textContent = "Top 5 Boost";
          const top5BoostInput = document.createElement("input");
          top5BoostInput.type = "number";
          top5BoostInput.min = "0";
          top5BoostInput.step = "0.1";
          const normalizedBoost = normalizeTop5Boost(
            playlist.top_5_boost ?? 1.0
          );
          playlist.top_5_boost = normalizedBoost;
          top5BoostInput.value = normalizedBoost;
          top5BoostInput.placeholder = "1.0";
          top5BoostInput.addEventListener("input", (event) => {
            const parsed = Number.parseFloat(event.target.value);
            if (Number.isFinite(parsed) && parsed >= 0) {
              playlist.top_5_boost = parsed;
            } else {
              playlist.top_5_boost = undefined;
            }
          });
          top5BoostLabel.appendChild(top5BoostInput);

          const coverLabel = document.createElement("label");
          coverLabel.textContent = "Cover Image Path";
          const coverWrapper = document.createElement("div");
          coverWrapper.className = "path-input";
          const coverInput = document.createElement("input");
          coverInput.type = "text";
          coverInput.placeholder = "/images/cover.png";
          coverInput.value = extras.cover || "";
          coverInput.addEventListener("input", (event) => {
            extras.cover = event.target.value;
          });
          const suggestionsList = document.createElement("div");
          suggestionsList.className = "path-suggestions";
          coverWrapper.appendChild(coverInput);
          coverWrapper.appendChild(suggestionsList);
          coverLabel.appendChild(coverWrapper);

          grid.appendChild(nameLabel);
          grid.appendChild(limitLabel);
          grid.appendChild(artistLimitLabel);
          grid.appendChild(albumLimitLabel);
          grid.appendChild(sortLabel);
          grid.appendChild(top5BoostLabel);
          grid.appendChild(coverLabel);

          details.appendChild(grid);

          const filtersWrapper = document.createElement("div");
          filtersWrapper.className = "filters-container";
          renderFilters(filtersWrapper, playlist.plex_filter, (filterIndex) => {
            playlist.plex_filter.splice(filterIndex, 1);
            renderPlaylists();
          });

          details.appendChild(filtersWrapper);

          const addFilterBtn = document.createElement("button");
          addFilterBtn.type = "button";
          addFilterBtn.className = "secondary";
          addFilterBtn.textContent = "＋ Add Filter";
          addFilterBtn.addEventListener("click", () => {
            playlist.plex_filter.push({
              field: "",
              operator: "equals",
              value: "",
              match_all: true,
              wildcard: false,
            });
            renderPlaylists();
          });

          details.appendChild(addFilterBtn);

          const boostsPopout = document.createElement("details");
          boostsPopout.className = "boosts-popout";
          if (playlist._boostsOpen) {
            boostsPopout.open = true;
          }

          const boostsSummary = document.createElement("summary");
          boostsSummary.textContent = "⚡ Popularity Boosts";
          boostsSummary.setAttribute(
            "aria-label",
            "Toggle popularity boost rules"
          );
          boostsPopout.appendChild(boostsSummary);

          const boostsPanel = document.createElement("div");
          boostsPanel.className = "boosts-panel";

          const boostsDescription = document.createElement("p");
          boostsDescription.textContent =
            "Boost multipliers adjust the popularity score of matching tracks. Uncheck Match All to treat comma-separated values as match-any.";
          boostsPanel.appendChild(boostsDescription);

          const boostsContainer = document.createElement("div");
          boostsContainer.className = "boosts-container";
          renderPopularityBoosts(
            boostsContainer,
            playlist.popularity_boosts,
            (boostIndex) => {
              playlist._boostsOpen = true;
              playlist.popularity_boosts.splice(boostIndex, 1);
              renderPlaylists();
            }
          );
          boostsPanel.appendChild(boostsContainer);

          const addBoostBtn = document.createElement("button");
          addBoostBtn.type = "button";
          addBoostBtn.className = "secondary";
          addBoostBtn.textContent = "＋ Add Boost Rule";
          addBoostBtn.addEventListener("click", () => {
            playlist.popularity_boosts.push({
              field: "",
              operator: "equals",
              value: "",
              match_all: true,
            });
            playlist._boostsOpen = true;
            renderPlaylists();
          });
          boostsPanel.appendChild(addBoostBtn);

          boostsPopout.appendChild(boostsPanel);
          boostsPopout.addEventListener("toggle", () => {
            playlist._boostsOpen = boostsPopout.open;
          });

          details.appendChild(boostsPopout);

          playlist._collapseElements = {
            card,
            toggleButton: toggleBtn,
          };
          updatePlaylistCollapseUi(playlist);

          toggleBtn.addEventListener("click", () => {
            playlist._collapsed = !playlist._collapsed;
            updatePlaylistCollapseUi(playlist);
          });

          setupPathAutocomplete(coverInput, suggestionsList, playlist, "cover");

          playlistsContainer.appendChild(card);
        });
      }

      function renderDefaultFilters() {
        if (!Array.isArray(state.defaults.plex_filter)) {
          state.defaults.plex_filter = [];
        }

        if (defaultFiltersContainer) {
          renderFilters(
            defaultFiltersContainer,
            state.defaults.plex_filter,
            (index) => {
              state.defaults.plex_filter.splice(index, 1);
              renderDefaultFilters();
            }
          );
        }

        if (!Array.isArray(state.defaults.popularity_boosts)) {
          state.defaults.popularity_boosts = [];
        }

        if (defaultBoostsContainer) {
          renderPopularityBoosts(
            defaultBoostsContainer,
            state.defaults.popularity_boosts,
            (index) => {
              isDefaultBoostsOpen = true;
              state.defaults.popularity_boosts.splice(index, 1);
              renderDefaultFilters();
            }
          );
        }

        if (defaultBoostsPopout) {
          if (defaultBoostsPopout.open !== isDefaultBoostsOpen) {
            defaultBoostsPopout.open = isDefaultBoostsOpen;
          }
        }
      }

      function renderAll() {
        renderDefaultFilters();
        renderPlaylists();
      }

      async function loadData() {
        try {
          const response = await fetch("/api/playlists");
          if (!response.ok) {
            throw new Error("Unable to load playlists.");
          }
          const data = await response.json();
          options = data.options || options;

          state.defaults.plex_filter = (data.defaults?.plex_filter || []).map((filter) => ({
            field: filter.field || "",
            operator: filter.operator || "equals",
            value: filter.value || "",
            match_all: filter.match_all !== undefined ? filter.match_all : true,
            wildcard: filter.wildcard !== undefined ? !!filter.wildcard : false,
          }));
          state.defaults.extras = data.defaults?.extras || {};
          state.defaults.popularity_boosts = (
            data.defaults?.popularity_boosts || []
          ).map((boost) => ({
            field: boost.field || "",
            operator: boost.operator || "equals",
            value: boost.value || "",
            match_all:
              boost.match_all !== undefined ? !!boost.match_all : true,
            boost: normalizePopularityBoostMultiplier(
              boost.boost !== undefined ? boost.boost : 1.0
            ),
          }));

          isDefaultBoostsOpen = state.defaults.popularity_boosts.length > 0;

          state.playlists = (data.playlists || []).map((playlist) => {
            const playlistName = playlist.name || "";
            const entry = {
              name: playlistName,
              limit: playlist.limit ?? 0,
              artist_limit: playlist.artist_limit ?? 0,
              album_limit: playlist.album_limit ?? 0,
              sort_by: playlist.sort_by || "",
              top_5_boost: normalizeTop5Boost(
                playlist.top_5_boost ?? 1.0
              ),
              plex_filter: (playlist.plex_filter || []).map((filter) => ({
                field: filter.field || "",
                operator: filter.operator || "equals",
                value: filter.value || "",
                match_all:
                  filter.match_all !== undefined ? filter.match_all : true,
                wildcard: filter.wildcard !== undefined ? !!filter.wildcard : false,
              })),
              popularity_boosts: (playlist.popularity_boosts || []).map(
                (boost) => ({
                  field: boost.field || "",
                  operator: boost.operator || "equals",
                  value: boost.value || "",
                  match_all:
                    boost.match_all !== undefined ? !!boost.match_all : true,
                  boost: normalizePopularityBoostMultiplier(
                    boost.boost !== undefined ? boost.boost : 1.0
                  ),
                })
              ),
              extras: playlist.extras || {},
            };
            entry._originalName = playlistName;
            entry._collapsed = true;
            entry._boostsOpen = false;
            return entry;
          });

          renderAll();
        } catch (error) {
          console.error(error);
          showMessage(error.message, true);
        }
      }

      function prepareFiltersForSave(filters) {
        return filters.map((filter) => ({
          field: filter.field || "",
          operator: filter.operator || "equals",
          value: filter.value || "",
          match_all: filter.match_all !== undefined ? !!filter.match_all : true,
          wildcard: filter.wildcard !== undefined ? !!filter.wildcard : false,
        }));
      }

      function prepareBoostsForSave(boosts) {
        return (boosts || []).map((boost) => ({
          field: boost.field || "",
          operator: boost.operator || "equals",
          value: boost.value || "",
          match_all: boost.match_all !== undefined ? !!boost.match_all : true,
          boost: normalizePopularityBoostMultiplier(
            boost.boost !== undefined ? boost.boost : 1.0
          ),
        }));
      }

      async function saveData(options = {}) {
        if (options && typeof options.preventDefault === "function") {
          options.preventDefault();
          options = {};
        }

        if (!options || typeof options !== "object") {
          options = {};
        }

        const { showSuccessMessage = true, rethrowOnError = false } = options;

        const payload = {
          defaults: {
            plex_filter: prepareFiltersForSave(state.defaults.plex_filter),
            popularity_boosts: prepareBoostsForSave(
              state.defaults.popularity_boosts
            ),
            extras: sanitizeExtras(state.defaults.extras || {}),
          },
          playlists: state.playlists.map((playlist) => ({
            name: playlist.name || "",
            limit: playlist.limit ?? 0,
            artist_limit: playlist.artist_limit ?? 0,
            album_limit: playlist.album_limit ?? 0,
            sort_by: playlist.sort_by || "",
            top_5_boost: normalizeTop5Boost(
              playlist.top_5_boost ?? 1.0
            ),
            plex_filter: prepareFiltersForSave(playlist.plex_filter),
            popularity_boosts: prepareBoostsForSave(
              playlist.popularity_boosts
            ),
            extras: sanitizeExtras(playlist.extras || {}),
          })),
        };

        try {
          const response = await fetch("/api/playlists", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ error: "Unknown error" }));
            throw new Error(error.error || "Failed to save playlists.");
          }

          if (showSuccessMessage) {
            showMessage("Playlists saved successfully.");
          }
        } catch (error) {
          console.error(error);
          showMessage(error.message, true);
          if (rethrowOnError && error && typeof error === "object") {
            error._fromSaveData = true;
            throw error;
          }
        }
      }

      async function savePlaylist(
        playlist,
        triggerButton,
        titleEl,
        nameInputEl,
        options = {}
      ) {
        const trimmedName = (playlist.name || "").trim();
        if (!trimmedName) {
          showMessage("Playlist name is required before saving.", true);
          return;
        }

        if (!options || typeof options !== "object") {
          options = {};
        }

        const { showSuccessMessage = true, rethrowOnError = false } = options;

        const payload = {
          playlist: {
            name: trimmedName,
            limit: playlist.limit ?? 0,
            artist_limit: playlist.artist_limit ?? 0,
            album_limit: playlist.album_limit ?? 0,
            sort_by: playlist.sort_by || "",
            top_5_boost: normalizeTop5Boost(
              playlist.top_5_boost ?? 1.0
            ),
            plex_filter: prepareFiltersForSave(playlist.plex_filter),
            popularity_boosts: prepareBoostsForSave(
              playlist.popularity_boosts
            ),
            extras: sanitizeExtras(playlist.extras || {}),
          },
          original_name: playlist._originalName || "",
        };

        if (triggerButton) {
          triggerButton.disabled = true;
        }

        if (showSuccessMessage) {
          showPlaylistInlineMessage(playlist, "Saving…", { persist: true });
        }

        try {
          const response = await fetch("/api/playlists/save_single", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });

          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(result.error || "Failed to save playlist.");
          }

          const savedName = result.name || trimmedName;
          playlist._originalName = savedName;
          playlist.name = trimmedName;

          if (titleEl) {
            titleEl.textContent = trimmedName || "Untitled Playlist";
          }

          if (nameInputEl) {
            nameInputEl.value = trimmedName;
          }

          if (showSuccessMessage) {
            showPlaylistInlineMessage(
              playlist,
              `Playlist '${savedName}' saved.`,
              { isError: false }
            );
            showMessage(`Playlist '${savedName}' saved.`);
          }
        } catch (error) {
          console.error(error);
          const errorMessage = error?.message || "Failed to save playlist.";
          showPlaylistInlineMessage(playlist, errorMessage, true);
          showMessage(errorMessage, true);
          if (rethrowOnError && error && typeof error === "object") {
            error._fromSavePlaylist = true;
            throw error;
          }
        } finally {
          if (triggerButton) {
            triggerButton.disabled = false;
          }
        }
      }

      if (toggleDefaultFiltersBtn) {
        toggleDefaultFiltersBtn.addEventListener("click", () => {
          isDefaultFiltersCollapsed = !isDefaultFiltersCollapsed;
          updateDefaultFiltersCollapse();
        });
      }

      updateDefaultFiltersCollapse();

      document.getElementById("addDefaultFilter").addEventListener("click", () => {
        state.defaults.plex_filter.push({
          field: "",
          operator: "equals",
          value: "",
          match_all: true,
          wildcard: false,
        });
        renderDefaultFilters();
      });

      const addDefaultBoostBtn = document.getElementById("addDefaultBoost");
      if (addDefaultBoostBtn) {
        addDefaultBoostBtn.addEventListener("click", () => {
          if (!Array.isArray(state.defaults.popularity_boosts)) {
            state.defaults.popularity_boosts = [];
          }

          state.defaults.popularity_boosts.push({
            field: "",
            operator: "equals",
            value: "",
            match_all: true,
          });
          isDefaultBoostsOpen = true;
          renderDefaultFilters();
        });
      }

      if (defaultBoostsPopout) {
        defaultBoostsPopout.addEventListener("toggle", () => {
          isDefaultBoostsOpen = defaultBoostsPopout.open;
        });
      }

      if (expandAllPlaylistsBtn) {
        expandAllPlaylistsBtn.addEventListener("click", () => {
          if (!state.playlists.length) {
            return;
          }

          state.playlists.forEach((playlist) => {
            if (!playlist) {
              return;
            }
            playlist._collapsed = false;
            updatePlaylistCollapseUi(playlist);
          });
        });
      }

      if (collapseAllPlaylistsBtn) {
        collapseAllPlaylistsBtn.addEventListener("click", () => {
          if (!state.playlists.length) {
            return;
          }

          state.playlists.forEach((playlist) => {
            if (!playlist) {
              return;
            }
            playlist._collapsed = true;
            updatePlaylistCollapseUi(playlist);
          });
        });
      }

      document.getElementById("addPlaylist").addEventListener("click", () => {
        const defaultSort = options.sort_fields?.[0]?.value || "";
        const newPlaylist = {
          name: "New Playlist",
          limit: 0,
          artist_limit: 0,
          album_limit: 0,
          sort_by: defaultSort,
          top_5_boost: 1.0,
          plex_filter: [],
          popularity_boosts: [],
          extras: {},
          _originalName: "",
          _collapsed: false,
          _boostsOpen: false,
        };
        state.playlists.push(newPlaylist);
        renderPlaylists();
        scrollPlaylistIntoView(newPlaylist);
      });

      document.getElementById("reloadBtn").addEventListener("click", () => {
        loadData().then(() => showMessage("Reloaded from playlists.yml"));
      });

      if (buildPopularityBtn) {
        buildPopularityBtn.addEventListener("click", async () => {
          buildPopularityBtn.disabled = true;
          try {
            const response = await fetch("/api/cache/popularity/build", {
              method: "POST",
            });
            const result = await response.json().catch(() => ({}));

            if (!response.ok) {
              throw new Error(
                result.message || result.error || "Failed to start popularity cache build."
              );
            }

            if (result.message) {
              showMessage(result.message);
            } else {
              showMessage("Started Spotify popularity cache build.");
            }
          } catch (error) {
            console.error(error);
            showMessage(error.message, true);
          } finally {
            setTimeout(() => refreshPopularityStatus(), 500);
          }
        });
      }

      if (clearPopularityCacheBtn) {
        clearPopularityCacheBtn.addEventListener("click", async () => {
          try {
            const response = await fetch("/api/cache/popularity/clear", {
              method: "POST",
            });
            const result = await response.json().catch(() => ({}));

            if (!response.ok) {
              throw new Error(
                result.error || "Failed to clear popularity cache."
              );
            }

            if (result.status === "cleared") {
              showMessage("Popularity cache cleared.");
            } else {
              showMessage("Popularity cache already clear.");
            }
          } catch (error) {
            console.error(error);
            showMessage(error.message, true);
          } finally {
            refreshPopularityStatus();
          }
        });
      }

      document.getElementById("saveBtn").addEventListener("click", saveData);

      if (buildToggleBtn) {
        buildToggleBtn.addEventListener("click", toggleBuild);
      }

      refreshBuildStatus();
      refreshPopularityStatus();
      buildStatusTimer = setInterval(() => refreshBuildStatus(), 5000);
      popularityStatusTimer = setInterval(() => refreshPopularityStatus(), 30000);
      loadData();
    </script>
  </body>
</html>
