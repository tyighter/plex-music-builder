<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Plex Playlist Builder</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --plex-orange: #e5a00d;
        --plex-orange-dark: #d48c07;
        --plex-dark: #1a1a1a;
        --plex-gray: #2b2b2b;
        --plex-light: #f5f5f5;
        --card-bg: rgba(34, 34, 34, 0.92);
        --border-radius: 14px;
      }

      * {
        box-sizing: border-box;
      }

      .visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      body {
        margin: 0;
        font-family: "Roboto", sans-serif;
        background: radial-gradient(circle at top, #2a2a2a 0%, #111 70%);
        color: var(--plex-light);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      body.no-scroll {
        overflow: hidden;
      }

      header {
        background: linear-gradient(135deg, var(--plex-dark), #0d0d0d);
        padding: 24px 48px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }

      header h1 {
        margin: 0;
        font-size: 28px;
        letter-spacing: 0.04em;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      header h1 span.icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 42px;
        height: 42px;
        border-radius: 50%;
        background: var(--plex-orange);
        color: #111;
        font-size: 22px;
        box-shadow: 0 8px 20px rgba(229, 160, 13, 0.45);
      }

      .action-bar {
        display: flex;
        gap: 12px;
        flex-wrap: nowrap;
        align-items: center;
        margin-left: auto;
        justify-content: flex-end;
      }

      .action-bar button {
        flex: 0 0 auto;
      }

      .defaults-popover {
        position: fixed;
        top: 96px;
        right: 48px;
        width: min(420px, calc(100% - 32px));
        background: var(--card-bg);
        border-radius: 18px;
        border: 1px solid rgba(229, 160, 13, 0.22);
        box-shadow: 0 24px 50px rgba(0, 0, 0, 0.55);
        display: none;
        flex-direction: column;
        z-index: 1600;
        overflow: hidden;
      }

      .defaults-popover.show {
        display: flex;
      }

      .defaults-popover-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 18px 20px;
        border-bottom: 1px solid rgba(229, 160, 13, 0.16);
        background: rgba(14, 14, 14, 0.6);
      }

      .defaults-popover-header h2 {
        margin: 0;
        font-size: 18px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .defaults-popover-body {
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: 20px;
        max-height: min(60vh, 480px);
        overflow-y: auto;
      }

      .defaults-description {
        margin: 0;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.72);
      }

      .config-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.55);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 24px;
        z-index: 2000;
      }

      .config-overlay.show {
        display: flex;
      }

      .config-panel {
        background: var(--card-bg);
        border-radius: 20px;
        padding: 0;
        width: min(720px, 100%);
        max-width: 720px;
        max-height: 85vh;
        display: flex;
        flex-direction: column;
        border: 1px solid rgba(229, 160, 13, 0.22);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.55);
        overflow: hidden;
      }

      .cover-picker-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 24px;
        z-index: 2300;
      }

      .cover-picker-overlay.show {
        display: flex;
      }

      .cover-picker-panel {
        background: var(--card-bg);
        border-radius: 24px;
        width: min(1040px, 100%);
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        border: 1px solid rgba(229, 160, 13, 0.24);
        box-shadow: 0 28px 60px rgba(0, 0, 0, 0.6);
        overflow: hidden;
      }

      .cover-picker-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 20px 24px;
        border-bottom: 1px solid rgba(229, 160, 13, 0.16);
        background: rgba(14, 14, 14, 0.7);
      }

      .cover-picker-header h2 {
        margin: 0;
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 20px;
      }

      .cover-picker-body {
        padding: 20px 24px 24px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        flex: 1;
        min-height: 0;
      }

      .cover-picker-controls {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .cover-picker-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
      }

      .cover-picker-action-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: flex-end;
      }

      .cover-picker-path {
        flex: 1;
        width: 100%;
        min-width: 200px;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(229, 160, 13, 0.18);
        border-radius: 12px;
        padding: 10px 12px;
        word-break: break-all;
      }

      .cover-picker-directory-list {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        max-height: 120px;
        overflow-y: auto;
        padding-right: 4px;
      }

      .cover-picker-directory-list button {
        border-radius: 999px;
        padding: 10px 16px;
        font-size: 15px;
        background: rgba(229, 160, 13, 0.18);
        color: var(--plex-light);
        border: 1px solid rgba(229, 160, 13, 0.32);
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .cover-picker-directory-list button:hover,
      .cover-picker-directory-list button:focus {
        background: rgba(229, 160, 13, 0.32);
        border-color: rgba(229, 160, 13, 0.5);
        outline: none;
      }

      .cover-picker-content {
        display: flex;
        gap: 18px;
        flex: 1;
        min-height: 0;
        align-items: stretch;
      }

      .cover-picker-grid {
        flex: 3;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 14px;
        overflow-y: auto;
        padding-right: 6px;
      }

      .cover-picker-grid button {
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid transparent;
        border-radius: 16px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
        color: var(--plex-light);
        font-size: 14px;
        transition: border 0.2s ease, transform 0.2s ease,
          background 0.2s ease;
      }

      .cover-picker-grid button:hover,
      .cover-picker-grid button:focus {
        border-color: rgba(229, 160, 13, 0.6);
        background: rgba(229, 160, 13, 0.22);
        outline: none;
      }

      .cover-picker-grid button:active {
        transform: translateY(1px);
      }

      .cover-picker-grid img {
        width: 100%;
        aspect-ratio: 1;
        object-fit: cover;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.45);
        pointer-events: none;
      }

      .cover-picker-grid span {
        width: 100%;
        text-align: center;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.72);
        word-break: break-word;
      }

      .cover-picker-preview {
        flex: 0 1 240px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(229, 160, 13, 0.18);
        border-radius: 16px;
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: stretch;
        min-width: 0;
        max-width: 260px;
        align-self: flex-start;
      }

      .cover-picker-preview-frame {
        position: relative;
        width: min(180px, 100%);
        padding-top: 70%;
        border-radius: 14px;
        overflow: hidden;
        background: rgba(0, 0, 0, 0.45);
        margin: 0 auto;
      }

      .cover-picker-preview-frame img {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: none;
      }

      .cover-picker-preview.has-image .cover-picker-preview-frame img {
        display: block;
      }

      .cover-picker-preview-placeholder {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 12px;
        text-align: center;
        color: rgba(255, 255, 255, 0.68);
        font-size: 13px;
      }

      .cover-picker-preview.has-image .cover-picker-preview-placeholder {
        display: none;
      }

      .cover-picker-preview-label {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.72);
        word-break: break-all;
      }

      .cover-picker-status {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.68);
      }

      .cover-picker-empty {
        grid-column: 1 / -1;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.7);
        text-align: center;
        padding: 24px 12px;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 16px;
      }

      .config-panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 20px 24px;
        border-bottom: 1px solid rgba(229, 160, 13, 0.16);
        background: rgba(14, 14, 14, 0.6);
      }

      .config-panel-header h2 {
        margin: 0;
        font-size: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .config-panel-body {
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        overflow-y: auto;
      }

      .config-panel-body p {
        margin: 0;
        color: rgba(255, 255, 255, 0.75);
        line-height: 1.6;
      }

      .config-panel-footer {
        padding: 20px 24px;
        border-top: 1px solid rgba(229, 160, 13, 0.16);
        background: rgba(14, 14, 14, 0.6);
      }

      @media (max-width: 1024px) {
        .cover-picker-content {
          flex-direction: column;
        }

        .cover-picker-preview {
          min-width: 0;
        }
      }

      @media (max-width: 720px) {
        .cover-picker-body {
          padding: 16px 18px 20px;
        }

        .cover-picker-content {
          gap: 12px;
          align-items: stretch;
        }

        .cover-picker-grid {
          order: 1;
        }

        .cover-picker-preview {
          order: 2;
          flex-direction: row;
          align-items: center;
          width: 100%;
          max-width: none;
          padding: 12px 14px;
          gap: 12px;
        }

        .cover-picker-preview-frame {
          width: 96px;
          padding-top: 96px;
          margin: 0;
        }

        .cover-picker-preview-label,
        .cover-picker-status {
          flex: 1 1 auto;
        }
      }

      main {
        flex: 1;
        padding: 32px 48px 120px;
        overflow-y: auto;
      }

      section {
        margin-bottom: 32px;
      }

      .section-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
        margin-bottom: 16px;
      }

      .section-header h2 {
        margin: 0;
      }

      .section-header .section-actions {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      h2 {
        margin: 0 0 16px;
        font-size: 22px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      h2 .section-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border-radius: 12px;
        background: rgba(229, 160, 13, 0.2);
        color: var(--plex-orange);
        font-size: 16px;
      }

      .card {
        background: var(--card-bg);
        border-radius: var(--border-radius);
        padding: 20px;
        margin-bottom: 18px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(229, 160, 13, 0.18);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .card:hover {
        transform: translateY(-3px);
        box-shadow: 0 24px 45px rgba(0, 0, 0, 0.55);
      }

      .build-status-panel {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .build-status-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 24px;
        flex-wrap: wrap;
      }

      .status-info {
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex: 1;
      }

      .status-headline {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 18px;
        font-weight: 600;
      }

      .status-text {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .status-indicator {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.35);
        box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.08);
        flex-shrink: 0;
      }

      .status-indicator.running {
        background: #4caf50;
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.25);
      }

      .status-indicator.waiting {
        background: #f5c150;
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.25);
      }

      .status-indicator.idle {
        background: #9e9e9e;
        box-shadow: 0 0 0 3px rgba(158, 158, 158, 0.25);
      }

      .status-indicator.error {
        background: #e94146;
        box-shadow: 0 0 0 3px rgba(233, 65, 70, 0.3);
      }

      .status-indicator.success {
        background: #3fbf61;
        box-shadow: 0 0 0 3px rgba(63, 191, 97, 0.25);
      }

      .status-indicator.stopped {
        background: #9e9e9e;
        box-shadow: 0 0 0 3px rgba(158, 158, 158, 0.25);
      }

      .status-message {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.75);
      }

      .status-meta {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.6);
      }

      .status-actions {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .status-actions button {
        white-space: nowrap;
      }

      .playlist-header {
        display: grid;
        grid-template-columns: minmax(0, 1fr) minmax(200px, 260px) minmax(0, 1fr);
        grid-template-areas:
          "title search actions"
          "status search actions"
          "message message message";
        align-items: start;
        gap: 12px 16px;
        margin-bottom: 18px;
      }

      .playlist-search {
        grid-area: search;
        align-self: stretch;
        display: flex;
        align-items: center;
      }

      .playlist-search input {
        width: 100%;
      }

      .playlist-list-controls {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 12px;
        flex-wrap: wrap;
      }

      #addPlaylist {
        position: fixed;
        bottom: 32px;
        right: 48px;
        z-index: 1100;
        box-shadow: 0 18px 36px rgba(0, 0, 0, 0.5);
      }

      #addPlaylist:hover,
      #addPlaylist:focus-visible {
        transform: translateY(-2px);
      }

      .playlist-header h3 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
      }

      .playlist-header-title {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
        flex: 1 1 220px;
        grid-area: title;
      }

      .playlist-status {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
        flex: 1 1 240px;
        grid-area: status;
      }

      .playlist-action-buttons {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
        justify-self: end;
        align-self: start;
        grid-area: actions;
      }

      .playlist-inline-message {
        display: none;
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 13px;
        background: rgba(229, 160, 13, 0.18);
        color: var(--plex-light);
        margin-top: 0;
        grid-area: message;
        justify-self: end;
        margin-left: auto;
        text-align: right;
      }

      .playlist-inline-message.show {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .playlist-inline-message.error {
        background: rgba(229, 65, 70, 0.28);
        color: #fff;
      }

      .playlist-details {
        display: flex;
        flex-direction: column;
        gap: 18px;
        margin-top: 18px;
      }

      .playlist-card.is-collapsed .playlist-details {
        display: none;
      }

      .playlist-collapse-btn {
        font-size: 18px;
        line-height: 1;
      }

      .playlist-status-text {
        display: flex;
        flex-direction: column;
        gap: 2px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 13px;
        min-width: 0;
      }

      .playlist-status-line {
        font-size: 14px;
        font-weight: 500;
        color: var(--plex-light);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .playlist-status-message {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.55);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .playlist-build-btn {
        white-space: nowrap;
      }

      .input-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 12px;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.8);
      }

      input[type="text"],
      input[type="search"],
      input[type="number"],
      input[type="url"],
      select,
      textarea {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(229, 160, 13, 0.25);
        background: rgba(17, 17, 17, 0.6);
        color: var(--plex-light);
        font-size: 15px;
        transition: border 0.2s ease, box-shadow 0.2s ease;
      }

      input:focus,
      select:focus,
      textarea:focus {
        outline: none;
        border-color: var(--plex-orange);
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.25);
      }

      textarea {
        min-height: 42px;
        resize: vertical;
      }

      .filter-row {
        display: grid;
        grid-template-columns: 1.1fr 1fr 1fr auto;
        gap: 12px;
        align-items: start;
        margin-bottom: 10px;
      }

      .boosts-popout {
        margin-top: 18px;
      }

      .boosts-popout summary {
        list-style: none;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 18px;
        border-radius: 999px;
        background: rgba(229, 160, 13, 0.16);
        border: 1px solid rgba(229, 160, 13, 0.35);
        color: var(--plex-light);
        font-size: 15px;
        font-weight: 500;
        box-shadow: none;
        transition: background 0.2s ease, transform 0.2s ease;
      }

      .boosts-popout summary::-webkit-details-marker {
        display: none;
      }

      .boosts-popout[open] summary {
        background: rgba(229, 160, 13, 0.28);
        transform: translateY(-1px);
      }

      .boosts-panel {
        margin-top: 14px;
        padding: 18px;
        border-radius: 12px;
        background: rgba(14, 14, 14, 0.65);
        border: 1px solid rgba(229, 160, 13, 0.22);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);
      }

      .boosts-panel p {
        margin: 0 0 14px;
        color: rgba(255, 255, 255, 0.75);
        font-size: 14px;
      }

      .boosts-container {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .boost-row {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px;
        border-radius: 12px;
        background: rgba(229, 160, 13, 0.08);
      }

      .boost-row .boost-input {
        display: flex;
        align-items: center;
      }

      .boost-row .boost-input input {
        width: 100%;
        min-width: 0;
      }

      .boost-conditions {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .boost-condition {
        display: grid;
        grid-template-columns: 1.1fr 1fr minmax(200px, 1fr) auto;
        gap: 12px;
        align-items: start;
      }

      .boost-condition .value-input {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .boost-condition .value-input input {
        width: 100%;
        min-width: 0;
      }

      .boost-condition .filter-flags {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: flex-start;
      }

      .boost-row-footer {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .boost-row-footer .boost-input {
        flex: 0 0 160px;
      }

      .filter-row .value-input {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .filter-row .value-input input {
        width: 100%;
        min-width: 180px;
      }

      .filter-row .filter-flags {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: flex-start;
      }

      .filter-row .filter-flag {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.7);
        white-space: nowrap;
        cursor: pointer;
      }

      .boost-condition .filter-flag {
        cursor: pointer;
      }

      .filter-flags button.remove-control {
        margin-left: auto;
      }

      .filter-row button.icon-only,
      .boost-condition button.icon-only {
        align-self: center;
      }

      .cover-field {
        display: flex;
        flex-direction: column;
        gap: 10px;
        color: rgba(255, 255, 255, 0.8);
        font-size: 14px;
        align-self: stretch;
      }

      .cover-field-label {
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      button.cover-preview {
        position: relative;
        width: 96px;
        height: 96px;
        border-radius: 14px;
        overflow: hidden;
        border: 1px solid rgba(229, 160, 13, 0.24);
        background: rgba(0, 0, 0, 0.45);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        padding: 0;
        transition: border 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
        margin-top: auto;
      }

      button.cover-preview:hover,
      button.cover-preview:focus-visible {
        border-color: rgba(229, 160, 13, 0.55);
        box-shadow: 0 0 0 2px rgba(229, 160, 13, 0.25);
        outline: none;
      }

      button.cover-preview:active {
        transform: translateY(1px);
      }

      .cover-preview-frame {
        position: absolute;
        inset: 0;
        border-radius: inherit;
        overflow: hidden;
      }

      .cover-preview-frame img {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: none;
      }

      .cover-preview.has-image .cover-preview-frame img {
        display: block;
      }

      .cover-preview-placeholder {
        color: rgba(255, 255, 255, 0.7);
        font-size: 12px;
        text-align: center;
        padding: 0 8px;
        line-height: 1.3;
      }

      .cover-preview-caption {
        display: none;
      }

      .limit-control {
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.8);
        align-self: stretch;
      }

      button.limit-button {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        padding: 10px 14px;
        border-radius: 10px;
        border: 1px solid rgba(229, 160, 13, 0.25);
        background: rgba(14, 14, 14, 0.6);
        color: var(--plex-light);
        font-size: 15px;
        font-weight: 500;
        box-shadow: none;
        gap: 10px;
        transition: border 0.2s ease, box-shadow 0.2s ease, background 0.2s ease,
          transform 0.2s ease;
      }

      button.limit-button::after {
        content: "▾";
        font-size: 12px;
        opacity: 0.7;
      }

      button.limit-button:hover,
      button.limit-button:focus-visible {
        border-color: rgba(229, 160, 13, 0.55);
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.25);
        outline: none;
        background: rgba(229, 160, 13, 0.08);
        transform: none;
      }

      button.limit-button:active {
        transform: translateY(1px);
        background: rgba(229, 160, 13, 0.12);
      }

      button.limit-button:disabled {
        opacity: 0.65;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .limit-button-value {
        margin-left: auto;
        font-weight: 600;
        font-size: 15px;
      }

      .limit-summary {
        display: none;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.65);
        line-height: 1.4;
      }

      .limit-control.has-summary .limit-summary {
        display: block;
      }

      .limit-menu-backdrop {
        position: fixed;
        inset: 0;
        background: transparent;
        display: none;
        z-index: 1750;
      }

      .limit-menu {
        position: absolute;
        display: none;
        flex-direction: column;
        gap: 16px;
        padding: 18px;
        background: var(--card-bg);
        border-radius: 16px;
        border: 1px solid rgba(229, 160, 13, 0.22);
        box-shadow: 0 20px 48px rgba(0, 0, 0, 0.55);
        min-width: clamp(260px, 32vw, 340px);
        max-width: min(360px, 90vw);
        z-index: 1760;
      }

      .limit-menu.show {
        display: flex;
      }

      .limit-menu-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .limit-menu-header h3 {
        margin: 0;
        font-size: 18px;
      }

      .limit-menu-rows {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .limit-row-base label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.8);
      }

      .limit-row-extra {
        display: grid;
        grid-template-columns: minmax(140px, 1fr) minmax(80px, 120px) auto;
        gap: 10px;
        align-items: center;
      }

      .limit-row-extra select,
      .limit-row-extra input {
        width: 100%;
        border-radius: 10px;
        border: 1px solid rgba(229, 160, 13, 0.25);
        background: rgba(14, 14, 14, 0.6);
        color: var(--plex-light);
        padding: 10px 12px;
        font-size: 14px;
      }

      .limit-row-extra select:focus,
      .limit-row-extra input:focus {
        outline: none;
        border-color: var(--plex-orange);
        box-shadow: 0 0 0 2px rgba(229, 160, 13, 0.25);
      }

      .limit-row-extra button.limit-remove {
        width: 36px;
        height: 36px;
      }

      .limit-menu-footer {
        display: flex;
        justify-content: flex-start;
      }

      button.limit-add {
        border-radius: 999px;
        padding: 8px 16px;
        font-size: 14px;
      }

      .cover-picker-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0 16px;
        min-height: 40px;
        font-size: 14px;
        border-radius: 12px;
        background: rgba(229, 160, 13, 0.18);
        color: var(--plex-light);
        border: 1px solid rgba(229, 160, 13, 0.32);
        transition: background 0.2s ease, border 0.2s ease, transform 0.2s ease;
      }

      .cover-picker-button:hover,
      .cover-picker-button:focus {
        background: rgba(229, 160, 13, 0.32);
        border-color: rgba(229, 160, 13, 0.5);
        outline: none;
      }

      .cover-picker-button:active {
        transform: translateY(1px);
      }

      .cover-picker-button.danger {
        background: rgba(233, 65, 70, 0.18);
        border-color: rgba(233, 65, 70, 0.32);
      }

      .cover-picker-button.danger:hover,
      .cover-picker-button.danger:focus {
        background: rgba(233, 65, 70, 0.28);
        border-color: rgba(233, 65, 70, 0.45);
      }

      .cover-picker-button:disabled {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.12);
        cursor: not-allowed;
        opacity: 0.5;
      }

      .button,
      button {
        cursor: pointer;
        border: none;
        border-radius: 999px;
        padding: 10px 18px;
        font-size: 15px;
        font-weight: 500;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: #111;
        background: var(--plex-orange);
        transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 12px 24px rgba(229, 160, 13, 0.35);
      }

      button.secondary {
        background: rgba(229, 160, 13, 0.16);
        color: var(--plex-light);
        box-shadow: none;
        border: 1px solid rgba(229, 160, 13, 0.35);
      }

      button.danger {
        background: rgba(229, 65, 70, 0.85);
        color: #fff;
        box-shadow: 0 12px 24px rgba(229, 65, 70, 0.45);
      }

      button.icon-only {
        padding: 8px;
        border-radius: 12px;
        width: 40px;
        height: 40px;
        justify-content: center;
        font-size: 18px;
        line-height: 1;
      }

      button:hover {
        transform: translateY(-1px);
      }

      button:active {
        transform: scale(0.97);
        background: var(--plex-orange-dark);
      }

      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      button:disabled:active {
        transform: none;
      }

      .config-status-message {
        font-size: 14px;
        color: rgba(229, 160, 13, 0.9);
        min-height: 18px;
      }

      .config-status-message.error {
        color: rgba(229, 65, 70, 0.85);
      }

      .config-status-message:not(.show) {
        display: none;
      }

      .config-form-container {
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .config-active-path {
        background: rgba(229, 160, 13, 0.12);
        border-radius: 12px;
        padding: 12px 16px;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.85);
      }

      .config-active-path code {
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        color: var(--plex-light);
      }

      .config-search-paths {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.6);
      }

      .config-search-paths ol {
        margin: 8px 0 0;
        padding-left: 20px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .config-section {
        padding-top: 16px;
        border-top: 1px solid rgba(229, 160, 13, 0.16);
      }

      .config-section:first-of-type {
        border-top: none;
        padding-top: 0;
      }

      .config-section h3 {
        margin: 0 0 8px;
        font-size: 18px;
      }

      .config-section-description {
        margin: 0 0 16px;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.65);
        line-height: 1.5;
      }

      .config-section-fields {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .config-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .config-field label {
        font-weight: 500;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.85);
      }

      .config-field input,
      .config-field select {
        width: 100%;
        border-radius: 10px;
        border: 1px solid rgba(229, 160, 13, 0.25);
        background: rgba(14, 14, 14, 0.6);
        color: var(--plex-light);
        padding: 10px 12px;
        font-size: 14px;
      }

      .config-field input:focus,
      .config-field select:focus {
        outline: none;
        border-color: var(--plex-orange);
        box-shadow: 0 0 0 2px rgba(229, 160, 13, 0.25);
      }

      .config-field-helper {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.55);
        line-height: 1.4;
      }

      .config-field-checkbox {
        flex-direction: row;
        align-items: center;
        gap: 12px;
      }

      .config-checkbox {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        cursor: pointer;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.85);
      }

      .config-checkbox input,
      .filter-flag input {
        width: 18px;
        height: 18px;
        border-radius: 4px;
        border: 2px solid rgba(229, 160, 13, 0.35);
        appearance: none;
        background: transparent;
        position: relative;
        transition: background 0.2s ease, border-color 0.2s ease,
          box-shadow 0.2s ease;
      }

      .config-checkbox input::after,
      .filter-flag input::after {
        content: "";
        position: absolute;
        inset: 3px;
        border-radius: 2px;
        background: transparent;
        transition: background 0.2s ease;
      }

      .config-checkbox input:checked,
      .filter-flag input:checked {
        border-color: var(--plex-orange);
        box-shadow: 0 0 0 2px rgba(229, 160, 13, 0.2);
        background: rgba(229, 160, 13, 0.1);
      }

      .config-checkbox input:checked::after,
      .filter-flag input:checked::after {
        background: linear-gradient(135deg, var(--plex-orange), #ffce4a);
      }

      .config-checkbox input:focus-visible,
      .filter-flag input:focus-visible {
        outline: 2px solid rgba(229, 160, 13, 0.45);
        outline-offset: 2px;
      }

      .config-input-with-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .config-input-with-toggle input {
        flex: 1;
      }

      .config-visibility-toggle {
        border-radius: 10px;
        padding: 8px 12px;
        font-size: 13px;
        background: rgba(229, 160, 13, 0.18);
        color: var(--plex-light);
        border: 1px solid rgba(229, 160, 13, 0.3);
      }

      .config-visibility-toggle:hover {
        background: rgba(229, 160, 13, 0.28);
      }

      .config-empty {
        color: rgba(255, 255, 255, 0.6);
        font-size: 14px;
        padding: 12px 0;
      }

      .config-loading {
        color: rgba(255, 255, 255, 0.75);
        font-size: 14px;
      }

      .config-panel-footer .config-footer-actions {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .config-footer-actions .spacer {
        flex: 1;
      }

      button.secondary:active {
        background: rgba(229, 160, 13, 0.28);
      }

      button.danger:active {
        background: rgba(229, 65, 70, 0.95);
      }

      .filters-container {
        border: 1px dashed rgba(229, 160, 13, 0.25);
        border-radius: 12px;
        padding: 16px;
        background: rgba(14, 14, 14, 0.55);
      }

      .build-status-logs {
        padding: 16px;
        border-radius: 12px;
        background: linear-gradient(135deg, rgba(20, 20, 20, 0.85), rgba(12, 12, 12, 0.9));
        border: 1px solid rgba(229, 160, 13, 0.18);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
        transition: box-shadow 0.3s ease;
      }

      .build-status-panel.running .build-status-logs {
        box-shadow: inset 0 0 0 1px rgba(229, 160, 13, 0.2), 0 10px 30px rgba(229, 160, 13, 0.12);
      }

      .build-status-logs-toolbar {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .playlist-log-toggle {
        cursor: pointer;
        background: none;
        border: none;
        border-radius: 0;
        padding: 0;
        flex: 1 1 auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.6);
        transition: color 0.2s ease;
        box-shadow: none;
      }

      .playlist-log-clear {
        flex: 0 0 auto;
        padding: 6px 14px;
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .playlist-log-clear:disabled,
      .playlist-log-clear[aria-disabled="true"] {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .playlist-log-toggle:hover,
      .playlist-log-toggle:focus-visible {
        color: rgba(255, 255, 255, 0.85);
        outline: none;
      }

      .playlist-log-toggle:focus-visible {
        outline: 2px solid rgba(229, 160, 13, 0.6);
        outline-offset: 2px;
      }

      .playlist-log-toggle-label {
        pointer-events: none;
      }

      .playlist-log-toggle-icon {
        font-size: 14px;
        transition: transform 0.2s ease;
        pointer-events: none;
      }

      .build-status-logs.collapsed .playlist-log-toggle-icon {
        transform: rotate(-90deg);
      }

      .build-log-collapsible {
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .build-status-logs.collapsed .build-log-collapsible {
        display: none;
      }

      .build-log-actions {
        display: flex;
        justify-content: flex-end;
      }

      .playlist-log-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .playlist-log-entry {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 12px 14px;
        border-radius: 10px;
        background: rgba(229, 160, 13, 0.08);
        border: 1px solid rgba(229, 160, 13, 0.18);
        position: relative;
        overflow: hidden;
      }

      .playlist-log-entry.progress-entry {
        gap: 10px;
      }

      .playlist-log-entry::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at top right, rgba(229, 160, 13, 0.18), transparent 55%);
        pointer-events: none;
        opacity: 0.6;
      }

      .build-status-panel.running .playlist-log-entry::after {
        animation: filteringGlow 2.2s ease-in-out infinite;
      }

      .playlist-log-bar {
        width: 100%;
        height: 6px;
        border-radius: 999px;
        background: rgba(229, 160, 13, 0.16);
        overflow: hidden;
        position: relative;
      }

      .playlist-log-bar span {
        display: block;
        height: 100%;
        width: var(--progress, 0%);
        background: linear-gradient(90deg, var(--plex-orange), #ffce4a);
        box-shadow: 0 0 12px rgba(229, 160, 13, 0.4);
        transition: width 0.35s ease;
      }

      .build-status-panel.running .playlist-log-bar span {
        animation: filteringPulse 1.8s ease-in-out infinite;
      }

      .playlist-log-message {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .playlist-log-spinner {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 2px solid rgba(229, 160, 13, 0.25);
        border-top-color: var(--plex-orange);
        animation: spin 0.9s linear infinite;
        flex-shrink: 0;
      }

      .playlist-log-entry:not(.is-active-step) .playlist-log-spinner {
        display: none;
      }

      .playlist-log-text {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.85);
        position: relative;
        z-index: 1;
        flex: 1;
      }

      .playlist-log-dismiss {
        margin-left: auto;
        background: transparent;
        border: none;
        color: #ff6b6b;
        font-size: 16px;
        cursor: pointer;
        border-radius: 999px;
        width: 24px;
        height: 24px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        padding: 0;
        transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      }

      .playlist-log-dismiss:hover,
      .playlist-log-dismiss:focus-visible {
        background: rgba(255, 107, 107, 0.18);
        color: #ff8f8f;
      }

      .playlist-log-dismiss:focus-visible {
        outline: 2px solid rgba(255, 107, 107, 0.3);
        outline-offset: 2px;
      }

      .playlist-log-dismiss:active {
        transform: scale(0.92);
      }

      .playlist-log-empty {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.55);
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .playlist-log-entry.general-entry {
        background: rgba(120, 120, 120, 0.18);
        border-color: rgba(255, 255, 255, 0.16);
      }

      .playlist-log-entry.general-entry::after {
        background: radial-gradient(
          circle at top right,
          rgba(255, 255, 255, 0.18),
          transparent 55%
        );
      }

      .build-log-list {
        margin-top: 16px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .build-log-playlist {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .build-log-playlist-title {
        font-size: 15px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.78);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .build-log-playlist-title::before {
        content: "";
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: rgba(229, 160, 13, 0.6);
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.12);
      }

      .build-log-playlist.is-waiting .build-log-playlist-title::before {
        background: rgba(229, 160, 13, 0.4);
        box-shadow: 0 0 0 3px rgba(229, 160, 13, 0.08);
      }

      .build-log-playlist.is-active .build-log-playlist-title::before {
        background: #4caf50;
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.25);
      }

      .build-log-playlist.is-waiting .playlist-log-text {
        color: rgba(229, 160, 13, 0.82);
      }

      .build-log-playlist.is-waiting .playlist-log-spinner {
        border-top-color: rgba(229, 160, 13, 0.6);
      }

      .build-log-playlist-entries {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      @keyframes filteringPulse {
        0% {
          filter: brightness(0.95);
        }
        50% {
          filter: brightness(1.2);
        }
        100% {
          filter: brightness(0.95);
        }
      }

      @keyframes filteringGlow {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 0.9;
        }
      }

      .no-filters {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 12px;
      }

      .message {
        margin-left: auto;
        padding: 10px 16px;
        border-radius: 999px;
        font-size: 14px;
        background: rgba(229, 160, 13, 0.2);
        color: var(--plex-light);
        display: none;
      }

      .message.show {
        display: inline-flex;
      }

      .message.error {
        background: rgba(229, 65, 70, 0.28);
        color: #fff;
      }

      @media (max-width: 960px) {
        main {
          padding: 24px;
          padding-bottom: 120px;
        }

        header {
          flex-direction: column;
          align-items: flex-start;
          gap: 16px;
        }

        .action-bar {
          width: 100%;
          flex-wrap: wrap;
        }

        .config-overlay {
          padding: 16px;
        }

        .config-panel {
          width: 100%;
          max-width: none;
          max-height: 90vh;
        }

        #addPlaylist {
          bottom: 24px;
          right: 24px;
        }

        .defaults-popover {
          top: 140px;
          right: 24px;
          left: 24px;
          width: auto;
        }

        .playlist-header {
          grid-template-columns: minmax(0, 1fr);
          grid-template-areas:
            "title"
            "search"
            "status"
            "actions"
            "message";
        }

        .playlist-header-title,
        .playlist-status,
        .playlist-action-buttons,
        .playlist-search {
          align-items: flex-start;
        }

        .playlist-search {
          width: 100%;
        }

        .playlist-action-buttons {
          justify-content: flex-start;
        }

        .playlist-status-line,
        .playlist-status-message {
          white-space: normal;
        }

        .filter-row {
          grid-template-columns: 1fr;
        }

        .filter-row .filter-flags {
          width: 100%;
        }

        .filter-row .filter-flag {
          justify-content: flex-start;
        }

        .filter-row .value-input input {
          min-width: 0;
        }

        .boosts-popout summary {
          width: 100%;
          justify-content: center;
        }

        .boost-row {
          padding: 14px;
        }

        .boost-condition {
          grid-template-columns: 1fr;
        }

        .boost-condition .filter-flags {
          width: 100%;
        }

        .boost-row-footer {
          flex-direction: column;
          align-items: stretch;
        }

        .boost-row-footer .boost-input {
          flex: 1 1 auto;
        }

      }
    </style>
  </head>
  <body>
    <header>
      <h1><span class="icon">▶</span>Plex Playlist Builder</h1>
      <div class="action-bar">
        <button
          id="defaultsBtn"
          class="secondary"
          type="button"
          title="Open default playlist settings"
          aria-label="Open default playlist settings"
          aria-haspopup="dialog"
          aria-expanded="false"
        >
          Defaults
        </button>
        <button
          id="configBtn"
          class="icon-only secondary"
          type="button"
          title="Open configuration menu"
          aria-label="Open configuration menu"
          aria-haspopup="dialog"
          aria-expanded="false"
        >
          ⚙️
        </button>
        <button
          id="reloadBtn"
          class="icon-only secondary"
          type="button"
          title="Refresh playlists from playlists.yml"
          aria-label="Refresh playlists from playlists.yml"
        >
          ⟳
        </button>
        <button
          id="saveBtn"
          class="icon-only"
          type="button"
          title="Save all playlists to playlists.yml"
          aria-label="Save all playlists to playlists.yml"
        >
          💾
        </button>
        <button
          id="buildToggleBtn"
          class="icon-only"
          type="button"
          title="Build all playlists"
          aria-label="Build all playlists"
        >
          ▶
        </button>
        <span id="message" class="message"></span>
      </div>
    </header>
    <div
      id="defaultsPopover"
      class="defaults-popover"
      role="dialog"
      aria-modal="false"
      aria-hidden="true"
      hidden
    >
      <div class="defaults-popover-header">
        <h2><span class="section-icon">⚙</span>Defaults</h2>
        <button
          id="defaultsCloseBtn"
          class="icon-only secondary"
          type="button"
          title="Close defaults menu"
          aria-label="Close defaults menu"
          data-defaults-initial-focus
        >
          ✕
        </button>
      </div>
      <div class="defaults-popover-body">
        <p class="defaults-description">
          Configure filters and popularity boosts that apply to every playlist
          by default. Changes here are saved along with your playlists.
        </p>
        <div id="defaultFilters" class="filters-container"></div>
        <button id="addDefaultFilter" class="secondary" type="button">
          ＋ Add Default Filter
        </button>
        <details id="defaultBoostsPopout" class="boosts-popout">
          <summary aria-label="Toggle default popularity boost rules">
            ⚡ Popularity Boosts
          </summary>
          <div class="boosts-panel">
            <p>
              Boost multipliers adjust the popularity score of matching
              tracks. Uncheck Match All to treat comma-separated values as
              match-any.
            </p>
            <div id="defaultPopularityBoosts" class="boosts-container"></div>
            <button id="addDefaultBoost" class="secondary" type="button">
              ＋ Add Boost Rule
            </button>
          </div>
        </details>
      </div>
    </div>
    <div
      id="configOverlay"
      class="config-overlay"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
    >
      <div class="config-panel" role="document" tabindex="-1">
        <div class="config-panel-header">
          <h2><span class="section-icon">⚙️</span>Configuration</h2>
          <button
            id="configCloseBtn"
            class="icon-only secondary"
            type="button"
            title="Close configuration menu"
            aria-label="Close configuration menu"
            data-config-initial-focus
          >
            ✕
          </button>
        </div>
        <div class="config-panel-body">
          <p>
            Adjust application preferences and defaults from this menu. Future
            updates can surface additional controls without leaving the main
            builder screen.
          </p>
          <div
            id="configStatusMessage"
            class="config-status-message"
            role="status"
            aria-live="polite"
          ></div>
          <div id="configFormContainer" class="config-form-container">
            <div class="config-loading">Loading configuration…</div>
          </div>
        </div>
        <div class="config-panel-footer">
          <div class="config-footer-actions">
            <button id="configRestartBtn" class="danger" type="button">
              Restart Container
            </button>
            <div class="spacer"></div>
            <button id="configSaveBtn" type="button" disabled>
              Save Changes
            </button>
            <button id="configDismissBtn" class="secondary" type="button">
              Close
            </button>
          </div>
        </div>
      </div>
    </div>
    <div
      id="coverPickerOverlay"
      class="cover-picker-overlay"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
    >
      <div
        id="coverPickerPanel"
        class="cover-picker-panel"
        role="document"
        tabindex="-1"
      >
        <div class="cover-picker-header">
          <h2><span class="section-icon">🖼️</span>Choose Cover Image</h2>
          <button
            id="coverPickerCloseBtn"
            class="icon-only secondary"
            type="button"
            title="Close cover picker"
            aria-label="Close cover picker"
          >
            ✕
          </button>
        </div>
        <div class="cover-picker-body">
          <div class="cover-picker-controls">
            <div class="cover-picker-actions">
              <button
                id="coverPickerUpBtn"
                class="secondary"
                type="button"
                title="Go up one folder"
                aria-label="Go up one folder"
              >
                ⤴️ Up One Level
              </button>
              <div class="cover-picker-action-buttons">
                <button
                  id="coverPickerUploadBtn"
                  class="cover-picker-button"
                  type="button"
                  title="Upload a cover image"
                >
                  Upload Cover
                </button>
                <button
                  id="coverPickerClearBtn"
                  class="cover-picker-button danger"
                  type="button"
                  title="Clear the selected cover"
                >
                  Clear Cover
                </button>
              </div>
            </div>
            <input
              id="coverPickerUploadInput"
              type="file"
              accept="image/*"
              hidden
            />
            <div
              id="coverPickerPath"
              class="cover-picker-path"
              role="status"
              aria-live="polite"
            ></div>
          </div>
          <div
            id="coverPickerStatus"
            class="cover-picker-status"
            role="status"
            aria-live="polite"
          ></div>
          <div
            id="coverPickerDirectories"
            class="cover-picker-directory-list"
          ></div>
          <div class="cover-picker-content">
            <div id="coverPickerGrid" class="cover-picker-grid"></div>
            <div id="coverPickerPreview" class="cover-picker-preview">
              <div class="cover-picker-preview-frame">
                <img
                  id="coverPickerPreviewImage"
                  alt="Cover preview"
                  draggable="false"
                />
                <div class="cover-picker-preview-placeholder">
                  Select a cover to preview it.
                </div>
              </div>
              <div
                id="coverPickerPreviewLabel"
                class="cover-picker-preview-label"
              ></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <main>
      <section>
        <h2><span class="section-icon">🛠</span>Build Status</h2>
        <div id="buildStatusPanel" class="card build-status-panel">
          <div class="build-status-header">
            <div class="status-info">
              <div class="status-headline">
                <span id="buildStatusIndicator" class="status-indicator idle"></span>
                <div class="status-text">
                  <div id="buildStatusText">Checking build status…</div>
                  <div id="buildStatusMessage" class="status-message"></div>
                </div>
              </div>
              <div id="buildStatusMeta" class="status-meta"></div>
            </div>
          </div>
          <div id="buildStatusLogs" class="build-status-logs">
            <div class="build-status-logs-toolbar">
              <button
                id="playlistActivityToggle"
                class="playlist-log-toggle"
                type="button"
                aria-expanded="true"
              >
                <span class="playlist-log-toggle-label">Activity</span>
                <span class="playlist-log-toggle-icon" aria-hidden="true">▾</span>
              </button>
            </div>
            <div class="build-log-collapsible">
              <div class="build-log-actions">
                <button
                  id="clearActivityBtn"
                  class="playlist-log-clear secondary"
                  type="button"
                  title="Dismiss all activity messages"
                  aria-label="Dismiss all activity messages"
                  aria-disabled="true"
                  disabled
                >
                  Clear All
                </button>
              </div>
              <div id="buildLogContainer" class="build-log-list"></div>
            </div>
          </div>
        </div>
      </section>

      <section>
        <div class="playlist-header">
          <h2><span class="section-icon">🎵</span>Playlists</h2>
          <div class="playlist-search">
            <input
              id="playlistSearch"
              type="search"
              placeholder="Search playlists…"
              aria-label="Search playlists"
            />
          </div>
          <div class="playlist-list-controls">
            <button id="expandAllPlaylists" class="secondary" type="button">
              Expand All
            </button>
            <button id="collapseAllPlaylists" class="secondary" type="button">
              Collapse All
            </button>
            <button id="addPlaylist" type="button">＋ Add Playlist</button>
          </div>
        </div>
        <div id="playlistsContainer"></div>
      </section>
    </main>

    <script>
      const state = {
        defaults: { plex_filter: [], popularity_boosts: [], extras: {} },
        playlists: [],
      };

      let options = {
        fields: [],
        operators: [],
        sort_fields: [],
      };

      const messageEl = document.getElementById("message");
      const playlistsContainer = document.getElementById("playlistsContainer");
      const expandAllPlaylistsBtn = document.getElementById("expandAllPlaylists");
      const collapseAllPlaylistsBtn = document.getElementById(
        "collapseAllPlaylists"
      );
      const configBtn = document.getElementById("configBtn");
      const configOverlay = document.getElementById("configOverlay");
      const configCloseBtn = document.getElementById("configCloseBtn");
      const configDismissBtn = document.getElementById("configDismissBtn");
      const configFormContainer = document.getElementById("configFormContainer");
      const configStatusMessage = document.getElementById("configStatusMessage");
      const configSaveBtn = document.getElementById("configSaveBtn");
      const configRestartBtn = document.getElementById("configRestartBtn");
      const defaultFiltersContainer = document.getElementById("defaultFilters");
      const defaultBoostsPopout = document.getElementById("defaultBoostsPopout");
      const defaultBoostsContainer = document.getElementById(
        "defaultPopularityBoosts"
      );
      const defaultsBtn = document.getElementById("defaultsBtn");
      const defaultsPopover = document.getElementById("defaultsPopover");
      const defaultsCloseBtn = document.getElementById("defaultsCloseBtn");
      const playlistSearchInput = document.getElementById("playlistSearch");
      const buildStatusIndicator = document.getElementById("buildStatusIndicator");
      const buildStatusText = document.getElementById("buildStatusText");
      const buildStatusMessage = document.getElementById("buildStatusMessage");
      const buildStatusMeta = document.getElementById("buildStatusMeta");
      const buildToggleBtn = document.getElementById("buildToggleBtn");
      const buildStatusPanel = document.getElementById("buildStatusPanel");
      const buildStatusLogs = document.getElementById("buildStatusLogs");
      const playlistActivityToggle = document.getElementById(
        "playlistActivityToggle"
      );
      const clearActivityBtn = document.getElementById("clearActivityBtn");
      const buildLogContainer = document.getElementById("buildLogContainer");
      const playlistMessageTimeouts = new WeakMap();
      let latestBuildStatus = null;
      let buildStatusTimer = null;
      const ACTIVITY_COLLAPSED_STORAGE_KEY =
        "plexMusicBuilder.activityCollapsed";
      const DISMISSED_ACTIVITY_STORAGE_KEY =
        "plexMusicBuilder.dismissedActivity";
      const MAX_DISMISSED_ACTIVITY_KEYS = 500;
      let isActivityCollapsed = Boolean(
        loadActivityCollapsedState() ?? false
      );
      let isDefaultBoostsOpen = false;
      let isDefaultsPopoverOpen = false;
      const playlistCancellationMessages = new Map();
      const playlistCancellationCutoffs = new Map();
      const playlistActivityOrder = new Map();
      let nextPlaylistActivityOrder = 1;
      const pendingActivityStopRequests = new Map();
      const GENERAL_ACTIVITY_RETENTION_MS = 5 * 60 * 1000;
      const MESSAGE_DISPLAY_DURATION = 5 * 1000;
      const PLAYLIST_INLINE_MESSAGE_DURATION = 4 * 1000;
      const PLAYLIST_CANCELLATION_MESSAGE_TTL = 2 * 60 * 1000;
      const ACTIVITY_ENTRY_TTL_MS = 30 * 1000;
      let messageHideTimeout = null;
      const waitingPlaylistOrder = new Map();
      let nextWaitingOrderValue = 1;
      const coverPickerOverlay = document.getElementById("coverPickerOverlay");
      const coverPickerPanel = document.getElementById("coverPickerPanel");
      const coverPickerCloseBtn = document.getElementById("coverPickerCloseBtn");
      const coverPickerUpBtn = document.getElementById("coverPickerUpBtn");
      const coverPickerUploadBtn = document.getElementById("coverPickerUploadBtn");
      const coverPickerUploadInput = document.getElementById(
        "coverPickerUploadInput"
      );
      const coverPickerClearBtn = document.getElementById("coverPickerClearBtn");
      const coverPickerPath = document.getElementById("coverPickerPath");
      const coverPickerStatus = document.getElementById("coverPickerStatus");
      const coverPickerDirectories = document.getElementById(
        "coverPickerDirectories"
      );
      const coverPickerGrid = document.getElementById("coverPickerGrid");
      const coverPickerPreview = document.getElementById("coverPickerPreview");
      const coverPickerPreviewImage = document.getElementById(
        "coverPickerPreviewImage"
      );
      const coverPickerPreviewLabel = document.getElementById(
        "coverPickerPreviewLabel"
      );
      const COVER_PICKER_DEFAULT_DIRECTORY = "/images/";
      const CARD_COVER_PREVIEW_TEXTS = {
        empty: "Select a cover",
        loading: "Loading preview…",
        error: "Preview unavailable",
      };
      const COVER_PICKER_PREVIEW_TEXTS = {
        empty: "Select a cover to preview it.",
        loading: "Loading preview…",
        error: "Preview unavailable",
      };
      const LIMIT_MENU_TITLE_ID = "limitMenuTitle";
      const LIMIT_TYPE_OPTIONS = [
        { key: "artist", label: "Artist", field: "artist_limit" },
        { key: "album", label: "Album", field: "album_limit" },
        { key: "year", label: "Year", field: "year_limit" },
      ];
      const limitMenuState = {
        container: null,
        backdrop: null,
        playlist: null,
        anchor: null,
        updateDisplay: null,
        repositionHandler: null,
        toggleButton: null,
      };
      const coverPickerState = {
        playlist: null,
        inputEl: null,
        extrasKey: "",
        previewContainer: null,
        previewImage: null,
        previewLabel: null,
        selectedPath: "",
        currentRawPath: "",
        currentDirectory: "",
        lastFocus: null,
        directoryController: null,
        scrollLocked: false,
      };
      let lastFocusedBeforeConfig = null;
      let defaultsLastFocused = null;
      const configFieldElements = new Map();
      const configOriginalValues = new Map();
      let configSectionsPayload = [];
      let configActivePath = "";
      let configSearchPaths = [];
      let configSupportsRestart = true;
      let configLoading = false;
      const dismissedActivityKeys = new Set(loadDismissedActivityKeys());
      const activityEntryLastSeen = new Map();
      let playlistSearchTerm = "";

      function updateActivityCollapseUi() {
        const collapsed = Boolean(isActivityCollapsed);
        if (buildStatusLogs) {
          buildStatusLogs.classList.toggle("collapsed", collapsed);
          const collapsible = buildStatusLogs.querySelector(
            ".build-log-collapsible"
          );
          if (collapsible) {
            collapsible.hidden = collapsed;
            collapsible.setAttribute(
              "aria-hidden",
              collapsed ? "true" : "false"
            );
            collapsible.style.display = collapsed ? "none" : "";
            collapsible.style.maxHeight = collapsed ? "0px" : "";
          }
        }
        if (playlistActivityToggle) {
          playlistActivityToggle.setAttribute(
            "aria-expanded",
            collapsed ? "false" : "true"
          );
          const icon = playlistActivityToggle.querySelector(
            ".playlist-log-toggle-icon"
          );
          if (icon) {
            icon.textContent = collapsed ? "▸" : "▾";
          }
        }
      }

      function setActivityCollapsed(collapsed) {
        isActivityCollapsed = Boolean(collapsed);
        persistActivityCollapsedState(isActivityCollapsed);
        updateActivityCollapseUi();
      }

      function loadActivityCollapsedState() {
        if (typeof window === "undefined") {
          return null;
        }

        try {
          const storage = window.localStorage;
          if (!storage) {
            return null;
          }
          const rawValue = storage.getItem(ACTIVITY_COLLAPSED_STORAGE_KEY);
          if (rawValue === null || rawValue === undefined) {
            return null;
          }
          if (rawValue === "1" || rawValue === "true") {
            return true;
          }
          if (rawValue === "0" || rawValue === "false") {
            return false;
          }
          return null;
        } catch (error) {
          console.warn("Unable to load activity collapse state", error);
          return null;
        }
      }

      function persistActivityCollapsedState(collapsed) {
        if (typeof window === "undefined") {
          return;
        }

        try {
          const storage = window.localStorage;
          if (!storage) {
            return;
          }
          if (collapsed) {
            storage.setItem(ACTIVITY_COLLAPSED_STORAGE_KEY, "1");
          } else {
            storage.removeItem(ACTIVITY_COLLAPSED_STORAGE_KEY);
          }
        } catch (error) {
          console.warn("Unable to persist activity collapse state", error);
        }
      }

      function setConfigStatusMessage(text, isError = false) {
        if (!configStatusMessage) {
          return;
        }

        const normalized =
          typeof text === "string" ? text.trim() : String(text ?? "").trim();
        if (normalized) {
          configStatusMessage.textContent = normalized;
          configStatusMessage.classList.add("show");
        } else {
          configStatusMessage.textContent = "";
          configStatusMessage.classList.remove("show");
        }
        configStatusMessage.classList.toggle("error", Boolean(normalized && isError));
      }

      function clearConfigStatusMessage() {
        setConfigStatusMessage("");
      }

      function loadDismissedActivityKeys() {
        if (typeof window === "undefined") {
          return [];
        }

        try {
          const storage = window.localStorage;
          if (!storage) {
            return [];
          }
          const rawValue = storage.getItem(DISMISSED_ACTIVITY_STORAGE_KEY);
          if (!rawValue) {
            return [];
          }
          const parsed = JSON.parse(rawValue);
          if (!Array.isArray(parsed)) {
            return [];
          }
          return parsed.filter((key) => typeof key === "string" && key.length);
        } catch (error) {
          console.warn("Unable to load dismissed activity keys", error);
          return [];
        }
      }

      function persistDismissedActivityKeys() {
        if (typeof window === "undefined") {
          return;
        }

        try {
          const storage = window.localStorage;
          if (!storage) {
            return;
          }
          const values = Array.from(dismissedActivityKeys);
          let keysToStore = values;
          if (values.length > MAX_DISMISSED_ACTIVITY_KEYS) {
            keysToStore = values.slice(
              values.length - MAX_DISMISSED_ACTIVITY_KEYS
            );
            dismissedActivityKeys.clear();
            keysToStore.forEach((key) => dismissedActivityKeys.add(key));
          }
          storage.setItem(
            DISMISSED_ACTIVITY_STORAGE_KEY,
            JSON.stringify(keysToStore)
          );
        } catch (error) {
          console.warn("Unable to persist dismissed activity keys", error);
        }
      }

      function dismissAllActivityEntries(status = latestBuildStatus) {
        if (!buildLogContainer) {
          return;
        }

        const entries = Array.from(
          buildLogContainer.querySelectorAll(".playlist-log-entry")
        );

        let shouldPersist = false;
        const cancelledPlaylists = new Set();
        entries.forEach((entry) => {
          const activityKey = entry?.dataset?.activityKey;
          if (activityKey && !dismissedActivityKeys.has(activityKey)) {
            dismissedActivityKeys.add(activityKey);
            shouldPersist = true;
          }

          if (entry?.classList?.contains("cancellation-entry")) {
            const playlistName = entry?.dataset?.playlistName;
            if (playlistName) {
              cancelledPlaylists.add(playlistName);
            }
          }
        });

        const statusKeys = collectActivityKeysFromStatus(status);
        if (statusKeys.size) {
          statusKeys.forEach((key) => {
            if (key && !dismissedActivityKeys.has(key)) {
              dismissedActivityKeys.add(key);
              shouldPersist = true;
            }
          });
        }

        activityEntryLastSeen.clear();
        buildLogContainer.innerHTML = "";

        if (cancelledPlaylists.size) {
          cancelledPlaylists.forEach((name) => {
            playlistCancellationMessages.delete(name);
            playlistCancellationCutoffs.delete(name);
          });
        }

        if (shouldPersist) {
          persistDismissedActivityKeys();
        }
      }

      function collectActivityKeysFromStatus(status) {
        const keys = new Set();
        if (!status || typeof status !== "object") {
          return keys;
        }

        const playlistLogs = status?.logs?.playlists;
        if (playlistLogs && typeof playlistLogs === "object") {
          Object.entries(playlistLogs).forEach(([playlistName, entries]) => {
            if (!Array.isArray(entries)) {
              return;
            }
            entries.forEach((entry) => {
              const key = getPlaylistActivityKey(playlistName, entry);
              if (key) {
                keys.add(key);
              }
            });
          });
        }

        const generalLogs = status?.logs?.general;
        if (Array.isArray(generalLogs)) {
          generalLogs.forEach((entry) => {
            const key = getGeneralActivityKey(entry);
            if (key) {
              keys.add(key);
            }
          });
        }

        return keys;
      }

      function buildConfigFieldKey(sectionId, fieldKey) {
        return `${sectionId}.${fieldKey}`;
      }

      function coerceBoolean(value) {
        if (typeof value === "boolean") {
          return value;
        }
        const normalized = String(value ?? "").trim().toLowerCase();
        if (!normalized) {
          return false;
        }
        return ["1", "true", "yes", "on", "y"].includes(normalized);
      }

      function normalizeConfigValueForCompare(field, value) {
        if (!field) {
          return "";
        }
        if ((field.input || "") === "checkbox") {
          return coerceBoolean(value) ? "true" : "false";
        }
        if (value === null || value === undefined) {
          return "";
        }
        return String(value).trim();
      }

      function getConfigFieldEntryValue(entry) {
        if (!entry || !entry.input) {
          return "";
        }
        const { input, field } = entry;
        if ((field.input || "") === "checkbox") {
          return input.checked ? "true" : "false";
        }
        if ((field.input || "") === "select") {
          return String(input.value ?? "").trim();
        }
        if (field.input === "number") {
          return String(input.value ?? "").trim();
        }
        return String(input.value ?? "").trim();
      }

      function updateConfigDirtyState() {
        let dirty = false;
        configFieldElements.forEach((entry, key) => {
          const current = getConfigFieldEntryValue(entry);
          const original = configOriginalValues.get(key) ?? "";
          if (current !== original) {
            dirty = true;
          }
        });

        if (configSaveBtn) {
          configSaveBtn.disabled = !dirty;
        }

        return dirty;
      }

      function createConfigField(sectionId, field) {
        if (!field || !field.key) {
          return null;
        }

        const container = document.createElement("div");
        container.className = "config-field";
        container.dataset.sectionId = sectionId;
        container.dataset.fieldKey = field.key;

        const fieldKey = buildConfigFieldKey(sectionId, field.key);
        const inputType = field.input || field.type || "text";
        const fieldId = `config-${sectionId}-${field.key}`;
        let input = null;

        if (inputType === "checkbox") {
          container.classList.add("config-field-checkbox");
          const checkboxLabel = document.createElement("label");
          checkboxLabel.className = "config-checkbox";
          input = document.createElement("input");
          input.type = "checkbox";
          input.id = fieldId;
          input.checked = coerceBoolean(field.value);
          checkboxLabel.appendChild(input);
          const labelText = document.createElement("span");
          labelText.textContent = field.label || field.key;
          checkboxLabel.appendChild(labelText);
          container.appendChild(checkboxLabel);
        } else {
          const labelEl = document.createElement("label");
          labelEl.className = "config-field-label";
          labelEl.htmlFor = fieldId;
          labelEl.textContent = field.label || field.key;
          container.appendChild(labelEl);

          if (inputType === "select") {
            input = document.createElement("select");
            input.id = fieldId;
            const optionsList = Array.isArray(field.options)
              ? field.options
              : [];
            optionsList.forEach((option) => {
              if (!option || option.value === undefined) {
                return;
              }
              const optionEl = document.createElement("option");
              optionEl.value = String(option.value);
              optionEl.textContent = option.label || String(option.value);
              input.appendChild(optionEl);
            });
            const normalizedValue = String(field.value ?? "");
            input.value = normalizedValue;
          } else {
            input = document.createElement("input");
            let htmlInputType = "text";
            if (inputType === "password") {
              htmlInputType = "password";
            } else if (inputType === "number" || field.type === "integer" || field.type === "float") {
              htmlInputType = "number";
            }
            input.type = htmlInputType;
            input.id = fieldId;
            if (field.placeholder) {
              input.placeholder = field.placeholder;
            }
            if (field.min !== undefined) {
              input.min = String(field.min);
            }
            if (field.max !== undefined) {
              input.max = String(field.max);
            }
            if (field.step !== undefined) {
              input.step = String(field.step);
            }
            input.value = String(field.value ?? "");

            if (field.sensitive) {
              const wrapper = document.createElement("div");
              wrapper.className = "config-input-with-toggle";
              wrapper.appendChild(input);
              const toggleBtn = document.createElement("button");
              toggleBtn.type = "button";
              toggleBtn.className = "config-visibility-toggle";
              toggleBtn.textContent = input.type === "password" ? "Show" : "Hide";
              toggleBtn.addEventListener("click", () => {
                if (input.type === "password") {
                  input.type = "text";
                  toggleBtn.textContent = "Hide";
                } else {
                  input.type = "password";
                  toggleBtn.textContent = "Show";
                }
              });
              wrapper.appendChild(toggleBtn);
              container.appendChild(wrapper);
            } else {
              container.appendChild(input);
            }
          }
        }

        if (!input) {
          return null;
        }

        if (inputType === "select") {
          // Select added directly above.
          container.appendChild(input);
        }

        if (field.helper) {
          const helper = document.createElement("div");
          helper.className = "config-field-helper";
          helper.textContent = field.helper;
          container.appendChild(helper);
        }

        const entry = { sectionId, field, input };
        configFieldElements.set(fieldKey, entry);
        const originalValue = normalizeConfigValueForCompare(field, field.value);
        configOriginalValues.set(fieldKey, originalValue);

        const listenEvent = inputType === "checkbox" ? "change" : inputType === "select" ? "change" : "input";
        input.addEventListener(listenEvent, () => {
          updateConfigDirtyState();
        });

        return container;
      }

      function renderConfigForm() {
        if (!configFormContainer) {
          return;
        }

        configFieldElements.clear();
        configOriginalValues.clear();
        configFormContainer.innerHTML = "";

        if (configActivePath) {
          const pathInfo = document.createElement("div");
          pathInfo.className = "config-active-path";
          const label = document.createElement("div");
          label.textContent = "Active configuration:";
          const code = document.createElement("code");
          code.textContent = configActivePath;
          pathInfo.appendChild(label);
          pathInfo.appendChild(code);
          configFormContainer.appendChild(pathInfo);
        }

        if (Array.isArray(configSearchPaths) && configSearchPaths.length) {
          const searchContainer = document.createElement("div");
          searchContainer.className = "config-search-paths";
          const title = document.createElement("div");
          title.textContent = "Search order:";
          const list = document.createElement("ol");
          configSearchPaths.forEach((path) => {
            const item = document.createElement("li");
            item.textContent = String(path);
            list.appendChild(item);
          });
          searchContainer.appendChild(title);
          searchContainer.appendChild(list);
          configFormContainer.appendChild(searchContainer);
        }

        if (!Array.isArray(configSectionsPayload) || !configSectionsPayload.length) {
          const empty = document.createElement("div");
          empty.className = "config-empty";
          empty.textContent = "No configurable settings available.";
          configFormContainer.appendChild(empty);
        } else {
          configSectionsPayload.forEach((section) => {
            if (!section || !section.id) {
              return;
            }
            const sectionEl = document.createElement("section");
            sectionEl.className = "config-section";
            const heading = document.createElement("h3");
            heading.textContent = section.label || section.id;
            sectionEl.appendChild(heading);

            if (section.description) {
              const description = document.createElement("p");
              description.className = "config-section-description";
              description.textContent = section.description;
              sectionEl.appendChild(description);
            }

            const fieldsWrapper = document.createElement("div");
            fieldsWrapper.className = "config-section-fields";

            let renderedField = false;
            (section.fields || []).forEach((field) => {
              const fieldEl = createConfigField(section.id, field);
              if (fieldEl) {
                fieldsWrapper.appendChild(fieldEl);
                renderedField = true;
              }
            });

            if (renderedField) {
              sectionEl.appendChild(fieldsWrapper);
            } else {
              const empty = document.createElement("div");
              empty.className = "config-empty";
              empty.textContent = "No fields available for this section.";
              sectionEl.appendChild(empty);
            }

            configFormContainer.appendChild(sectionEl);
          });
        }

        if (configRestartBtn) {
          configRestartBtn.disabled = !configSupportsRestart;
        }

        updateConfigDirtyState();
      }

      async function loadConfigSettings() {
        if (configLoading) {
          return;
        }

        if (!configFormContainer) {
          return;
        }

        configLoading = true;
        setConfigStatusMessage("Loading configuration…");
        configFieldElements.clear();
        configOriginalValues.clear();
        configFormContainer.innerHTML =
          '<div class="config-loading">Loading configuration…</div>';

        if (configSaveBtn) {
          configSaveBtn.disabled = true;
        }
        if (configRestartBtn) {
          configRestartBtn.disabled = true;
        }

        try {
          const response = await fetch("/api/config");
          if (!response.ok) {
            throw new Error("Unable to load configuration.");
          }
          const payload = await response.json();
          configSectionsPayload = Array.isArray(payload.sections)
            ? payload.sections
            : [];
          configActivePath = typeof payload.path === "string" ? payload.path : "";
          configSearchPaths = Array.isArray(payload.search_paths)
            ? payload.search_paths
            : [];
          configSupportsRestart = Boolean(payload.supports_restart);
          renderConfigForm();
          if (configActivePath) {
            setConfigStatusMessage(`Editing ${configActivePath}`);
          } else {
            clearConfigStatusMessage();
          }
        } catch (error) {
          console.error(error);
          const message =
            error && error.message
              ? error.message
              : "Unable to load configuration.";
          setConfigStatusMessage(message, true);
          showMessage(message, true);
          if (configFormContainer) {
            configFormContainer.innerHTML = "";
            const errorEl = document.createElement("div");
            errorEl.className = "config-empty";
            errorEl.textContent = message;
            configFormContainer.appendChild(errorEl);
          }
        } finally {
          configLoading = false;
          updateConfigDirtyState();
        }
      }

      function collectConfigPayload() {
        const sections = {};
        configFieldElements.forEach((entry, key) => {
          if (!entry) {
            return;
          }
          const { sectionId, field, input } = entry;
          if (!sections[sectionId]) {
            sections[sectionId] = {};
          }
          if ((field.input || "") === "checkbox") {
            sections[sectionId][field.key] = Boolean(input.checked);
          } else {
            sections[sectionId][field.key] = String(input.value ?? "");
          }
        });
        return { sections };
      }

      async function saveConfigSettings() {
        const payload = collectConfigPayload();
        setConfigStatusMessage("Saving configuration…");
        if (configSaveBtn) {
          configSaveBtn.disabled = true;
        }

        try {
          const response = await fetch("/api/config", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(
              (result && result.error) || "Unable to save configuration."
            );
          }

          if (Array.isArray(result.sections)) {
            configSectionsPayload = result.sections;
          }
          if (typeof result.path === "string") {
            configActivePath = result.path;
          }
          if (Array.isArray(result.search_paths)) {
            configSearchPaths = result.search_paths;
          }
          if (result.supports_restart !== undefined) {
            configSupportsRestart = Boolean(result.supports_restart);
          }

          renderConfigForm();
          const message =
            typeof result.message === "string" && result.message.trim()
              ? result.message.trim()
              : "Configuration updated successfully.";
          setConfigStatusMessage(message);
          showMessage(message, false);
        } catch (error) {
          console.error(error);
          const message =
            error && error.message
              ? error.message
              : "Unable to save configuration.";
          setConfigStatusMessage(message, true);
          showMessage(message, true);
        } finally {
          updateConfigDirtyState();
        }
      }

      async function requestContainerRestart() {
        if (!configSupportsRestart) {
          return;
        }

        const confirmed = window.confirm(
          "Restarting will stop the application. Continue?"
        );
        if (!confirmed) {
          return;
        }

        if (configRestartBtn) {
          configRestartBtn.disabled = true;
        }
        setConfigStatusMessage("Restart requested…");

        try {
          const response = await fetch("/api/runtime/restart", { method: "POST" });
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(
              (result && result.message) || "Failed to request restart."
            );
          }
          const message =
            typeof result.message === "string" && result.message.trim()
              ? result.message.trim()
              : "Restart requested. The application will exit shortly.";
          setConfigStatusMessage(message);
          showMessage(message, false);
          dismissAllNotifications({ keepBanner: true, keepConfigStatus: true });
        } catch (error) {
          console.error(error);
          const message =
            error && error.message
              ? error.message
              : "Failed to request restart.";
          setConfigStatusMessage(message, true);
          showMessage(message, true);
          if (configRestartBtn) {
            configRestartBtn.disabled = false;
          }
        }
      }

      function openConfigMenu() {
        if (!configOverlay) {
          return;
        }

        lastFocusedBeforeConfig = document.activeElement;
        configOverlay.classList.add("show");
        configOverlay.setAttribute("aria-hidden", "false");

        if (configBtn) {
          configBtn.setAttribute("aria-expanded", "true");
        }

        loadConfigSettings();

        const focusTarget =
          configOverlay.querySelector("[data-config-initial-focus]") ||
          configOverlay.querySelector(".config-panel") ||
          configCloseBtn ||
          configOverlay;

        window.requestAnimationFrame(() => {
          if (focusTarget && typeof focusTarget.focus === "function") {
            focusTarget.focus();
          }
        });
      }

      function closeConfigMenu() {
        if (!configOverlay) {
          return;
        }

        configOverlay.classList.remove("show");
        configOverlay.setAttribute("aria-hidden", "true");

        if (configBtn) {
          configBtn.setAttribute("aria-expanded", "false");
        }

        if (
          lastFocusedBeforeConfig &&
          typeof lastFocusedBeforeConfig.focus === "function"
        ) {
          lastFocusedBeforeConfig.focus();
        }

        lastFocusedBeforeConfig = null;
        clearConfigStatusMessage();
      }

      function parseTimestampMs(value) {
        if (value === null || value === undefined) {
          return null;
        }

        if (value instanceof Date) {
          const msValue = value.getTime();
          return Number.isNaN(msValue) ? null : msValue;
        }

        if (typeof value === "number") {
          if (!Number.isFinite(value)) {
            return null;
          }
          const normalized = value < 1e12 ? value * 1000 : value;
          return Number.isFinite(normalized) ? normalized : null;
        }

        if (typeof value === "string") {
          const trimmed = value.trim();
          if (!trimmed) {
            return null;
          }

          if (/^\d+$/.test(trimmed)) {
            const numeric = Number(trimmed);
            if (Number.isFinite(numeric)) {
              const normalized = trimmed.length <= 10 ? numeric * 1000 : numeric;
              return normalized;
            }
          }

          const parsed = Date.parse(trimmed);
          if (!Number.isNaN(parsed)) {
            return parsed;
          }
        }

        return null;
      }

      function getPlaylistActivityKey(playlistName, entry) {
        if (!entry || typeof entry !== "object") {
          return null;
        }

        const trimmedName =
          typeof playlistName === "string" ? playlistName.trim() : "";
        if (!trimmedName) {
          return null;
        }

        const type = typeof entry.type === "string" ? entry.type : "message";
        const timestampMs = parseTimestampMs(entry.timestamp);
        const textValue =
          typeof entry.text === "string" ? entry.text.trim() : "";
        const percentValue = normalizeProgressPercent(entry);

        const parts = [
          "playlist",
          encodeURIComponent(trimmedName),
          type,
        ];

        if (timestampMs !== null) {
          parts.push(`ts:${timestampMs}`);
        }

        if (textValue) {
          parts.push(`msg:${encodeURIComponent(textValue)}`);
        }

        if (percentValue !== null) {
          const normalizedPercent = Math.round(percentValue * 10) / 10;
          parts.push(`pct:${normalizedPercent}`);
        }

        if (timestampMs === null && !textValue) {
          const currentCandidate = Number(entry.current);
          const totalCandidate = Number(entry.total);
          if (
            Number.isFinite(currentCandidate) ||
            Number.isFinite(totalCandidate)
          ) {
            const currentValue = Number.isFinite(currentCandidate)
              ? Math.max(0, Math.floor(currentCandidate))
              : "";
            const totalValue = Number.isFinite(totalCandidate)
              ? Math.max(0, Math.floor(totalCandidate))
              : "";
            parts.push(`counts:${currentValue}/${totalValue}`);
          }

          if (entry.details) {
            parts.push(`details:${encodeURIComponent(String(entry.details))}`);
          }
        }

        const key = parts.filter(Boolean).join("|");
        return key || null;
      }

      function getGeneralActivityKey(entry) {
        if (!entry || typeof entry !== "object") {
          return null;
        }

        const textValue =
          typeof entry.text === "string" ? entry.text.trim() : "";
        if (!textValue) {
          return null;
        }

        const timestampMs = parseTimestampMs(entry.timestamp);
        const parts = ["general"];
        if (timestampMs !== null) {
          parts.push(`ts:${timestampMs}`);
        }
        parts.push(`msg:${encodeURIComponent(textValue)}`);

        return parts.join("|");
      }

      function createDismissButton(activityKey, options = {}) {
        if (!activityKey) {
          return document.createComment("dismiss-unavailable");
        }

        const button = document.createElement("button");
        button.type = "button";
        button.className = "playlist-log-dismiss";
        button.textContent = "×";

        const playlistLabel =
          typeof options.playlistName === "string"
            ? options.playlistName.trim()
            : "";
        const labelParts = ["Dismiss this message"];
        if (playlistLabel) {
          labelParts.push(`for '${playlistLabel}'`);
        }
        const label = labelParts.join(" ");
        button.title = label;
        button.setAttribute("aria-label", label);

        button.addEventListener("click", (event) => {
          event.preventDefault();
          dismissedActivityKeys.add(activityKey);
          persistDismissedActivityKeys();

          const entryEl = button.closest(".playlist-log-entry");
          if (entryEl && entryEl.parentElement) {
            entryEl.parentElement.removeChild(entryEl);
          }

          if (options && typeof options.onDismiss === "function") {
            try {
              options.onDismiss(activityKey, playlistLabel);
            } catch (error) {
              console.error(error);
            }
          }
        });

        return button;
      }

      function formatTimestamp(value) {
        if (value === null || value === undefined) {
          return "";
        }

        let candidateDate = null;
        if (value instanceof Date) {
          candidateDate = value;
        } else if (typeof value === "number" && Number.isFinite(value)) {
          const normalizedValue = value < 1e12 ? value * 1000 : value;
          candidateDate = new Date(normalizedValue);
        } else if (typeof value === "string") {
          const trimmed = value.trim();
          if (trimmed) {
            const parsed = Date.parse(trimmed);
            if (!Number.isNaN(parsed)) {
              candidateDate = new Date(parsed);
            }
          }
        }

        if (!(candidateDate instanceof Date) || Number.isNaN(candidateDate.getTime())) {
          return "";
        }

        const now = new Date();
        const diffMs = now.getTime() - candidateDate.getTime();
        const absDiffMs = Math.abs(diffMs);

        let relativeText = "";
        const minuteMs = 60 * 1000;
        const hourMs = 60 * minuteMs;
        const dayMs = 24 * hourMs;

        if (absDiffMs < minuteMs) {
          relativeText = "just now";
        } else if (absDiffMs < hourMs) {
          const minutes = Math.round(absDiffMs / minuteMs);
          relativeText = `${minutes} minute${minutes === 1 ? "" : "s"} ${
            diffMs >= 0 ? "ago" : "from now"
          }`;
        } else if (absDiffMs < dayMs) {
          const hours = Math.round(absDiffMs / hourMs);
          relativeText = `${hours} hour${hours === 1 ? "" : "s"} ${
            diffMs >= 0 ? "ago" : "from now"
          }`;
        } else {
          const days = Math.round(absDiffMs / dayMs);
          relativeText = `${days} day${days === 1 ? "" : "s"} ${
            diffMs >= 0 ? "ago" : "from now"
          }`;
        }

        const formattedDate = candidateDate.toLocaleString(undefined, {
          dateStyle: "medium",
          timeStyle: "short",
        });

        return `${formattedDate} (${relativeText})`;
      }

      function hideMessage() {
        if (!messageEl) {
          return;
        }

        if (messageHideTimeout !== null) {
          window.clearTimeout(messageHideTimeout);
          messageHideTimeout = null;
        }

        messageEl.textContent = "";
        messageEl.classList.remove("show");
        messageEl.classList.remove("error");
      }

      function showMessage(text, isError = false) {
        if (!messageEl) {
          return;
        }

        const rawText =
          text === null || text === undefined ? "" : String(text);
        const trimmedText = rawText.trim();
        if (!trimmedText) {
          hideMessage();
          return;
        }

        if (messageHideTimeout !== null) {
          window.clearTimeout(messageHideTimeout);
        }

        messageEl.textContent = trimmedText;
        messageEl.classList.toggle("error", Boolean(isError));
        messageEl.classList.add("show");

        messageHideTimeout = window.setTimeout(() => {
          hideMessage();
        }, MESSAGE_DISPLAY_DURATION);
      }

      function clearPlaylistInlineMessageTimer(playlist) {
        if (!playlist || typeof playlist !== "object") {
          return;
        }

        const timeoutId = playlistMessageTimeouts.get(playlist);
        if (timeoutId !== undefined) {
          window.clearTimeout(timeoutId);
          playlistMessageTimeouts.delete(playlist);
        }
      }

      function hidePlaylistInlineMessage(playlist) {
        if (!playlist || typeof playlist !== "object") {
          return;
        }

        const inlineEl = playlist._inlineMessageEl;
        if (!inlineEl) {
          return;
        }

        clearPlaylistInlineMessageTimer(playlist);
        inlineEl.textContent = "";
        inlineEl.classList.remove("show");
        inlineEl.classList.remove("error");
      }

      function showPlaylistInlineMessage(playlist, text, options = {}) {
        if (!playlist || typeof playlist !== "object") {
          return;
        }

        const inlineEl = playlist._inlineMessageEl;
        if (!inlineEl) {
          return;
        }

        if (!options || typeof options !== "object") {
          options = {};
        }

        clearPlaylistInlineMessageTimer(playlist);

        const rawText =
          text === null || text === undefined ? "" : String(text);
        const trimmedText = rawText.trim();

        if (!trimmedText) {
          hidePlaylistInlineMessage(playlist);
          return;
        }

        inlineEl.textContent = trimmedText;
        inlineEl.classList.toggle("error", Boolean(options.isError));
        inlineEl.classList.add("show");

        const persist = Boolean(options.persist);
        if (!persist) {
          const durationCandidate = Number(options.duration);
          const duration = Number.isFinite(durationCandidate) && durationCandidate > 0
            ? durationCandidate
            : PLAYLIST_INLINE_MESSAGE_DURATION;
          const timeoutId = window.setTimeout(() => {
            hidePlaylistInlineMessage(playlist);
          }, duration);
          playlistMessageTimeouts.set(playlist, timeoutId);
        }
      }

      function dismissAllNotifications(options = {}) {
        const keepBanner = Boolean(options?.keepBanner);
        const keepConfigStatus = Boolean(options?.keepConfigStatus);
        if (!keepBanner) {
          hideMessage();
        }
        if (!keepConfigStatus) {
          clearConfigStatusMessage();
        }

        if (Array.isArray(state.playlists)) {
          state.playlists.forEach((playlist) => {
            hidePlaylistInlineMessage(playlist);
          });
        }

        dismissAllActivityEntries();
      }

      function registerPlaylistCancellation(playlistName, customMessage) {
        const trimmedName =
          typeof playlistName === "string" ? playlistName.trim() : "";
        if (!trimmedName) {
          return;
        }

        const nowMs = Date.now();
        const normalizedMessage =
          typeof customMessage === "string" && customMessage.trim()
            ? customMessage.trim()
            : `Cancellation requested for '${trimmedName}'.`;

        playlistCancellationMessages.set(trimmedName, {
          message: normalizedMessage,
          expiresAt: nowMs + PLAYLIST_CANCELLATION_MESSAGE_TTL,
        });
        playlistCancellationCutoffs.set(trimmedName, nowMs);
      }

      async function requestStopPlaylistFromActivity(
        playlistName,
        activityKey,
        options = {}
      ) {
        const trimmedName =
          typeof playlistName === "string" ? playlistName.trim() : "";
        if (!trimmedName) {
          return;
        }

        const pendingKey = trimmedName.toLowerCase();
        if (pendingActivityStopRequests.has(pendingKey)) {
          return;
        }

        const wasAlreadyCancelled = playlistCancellationMessages.has(trimmedName);
        const isWaiting = Boolean(options && options.isWaiting);

        pendingActivityStopRequests.set(pendingKey, true);

        const cancellationMessage = isWaiting
          ? `Cancellation requested for '${trimmedName}'.`
          : undefined;
        registerPlaylistCancellation(trimmedName, cancellationMessage);
        updateBuildLogsUi(latestBuildStatus);

        try {
          const response = await fetch("/api/build/stop_playlist", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ playlist: trimmedName }),
          });
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(
              result.message || "Failed to stop playlist build."
            );
          }

          if (result.status) {
            updateBuildStatusUi(result.status);
          } else {
            await refreshBuildStatus();
          }

          if (result.message) {
            showMessage(result.message);
          } else {
            showMessage(
              isWaiting
                ? `Cancelling queued build for '${trimmedName}'...`
                : `Stopping '${trimmedName}'...`
            );
          }
        } catch (error) {
          console.error(error);
          const errorMessage =
            (error && error.message) || `Failed to stop '${trimmedName}'.`;
          showMessage(errorMessage, true);
          if (!wasAlreadyCancelled) {
            playlistCancellationMessages.delete(trimmedName);
            playlistCancellationCutoffs.delete(trimmedName);
          }
          if (activityKey) {
            dismissedActivityKeys.delete(activityKey);
            persistDismissedActivityKeys();
          }
          updateBuildLogsUi(latestBuildStatus);
        } finally {
          pendingActivityStopRequests.delete(pendingKey);
        }
      }

      async function stopPlaylistBuildSilently(playlistName) {
        const trimmedName =
          typeof playlistName === "string" ? playlistName.trim() : "";
        if (!trimmedName) {
          return null;
        }

        try {
          const response = await fetch("/api/build/stop_playlist", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ playlist: trimmedName }),
          });
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            const message =
              result?.message ||
              `Failed to stop playlist build for '${trimmedName}'.`;
            const isNoActiveBuild =
              response.status === 404 &&
              typeof message === "string" &&
              message.startsWith("No active build found for playlist");
            if (isNoActiveBuild) {
              return result?.status || null;
            }
            throw new Error(message);
          }

          return result?.status || null;
        } catch (error) {
          const message =
            (error && error.message) ||
            `Failed to stop playlist build for '${trimmedName}'.`;
          throw new Error(message);
        }
      }

      async function stopAllBuildSilently() {
        try {
          const response = await fetch("/api/build/stop", { method: "POST" });
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            const message =
              result?.message || "Failed to stop build.";
            const builderIdle =
              response.status === 409 &&
              typeof message === "string" &&
              message === "Builder is not running.";
            if (builderIdle) {
              return result?.status || null;
            }
            throw new Error(message);
          }

          return result?.status || null;
        } catch (error) {
          const message =
            (error && error.message) || "Failed to stop build.";
          throw new Error(message);
        }
      }

      async function cancelActiveBuilds() {
        const statusSnapshot = latestBuildStatus;
        if (!statusSnapshot || !statusSnapshot.running) {
          return;
        }

        const waitingSet = collectWaitingPlaylistSet(statusSnapshot);
        const activeSet = collectActivePlaylistSet(statusSnapshot);

        const playlistTargets = [];
        activeSet.forEach((name) => {
          if (name) {
            playlistTargets.push(name);
          }
        });
        waitingSet.forEach((name) => {
          if (name && !activeSet.has(name)) {
            playlistTargets.push(name);
          }
        });

        let updatedStatus = null;

        for (const name of playlistTargets) {
          try {
            const resultStatus = await stopPlaylistBuildSilently(name);
            if (resultStatus && typeof resultStatus === "object") {
              updatedStatus = resultStatus;
            }
          } catch (error) {
            console.error(error);
            if (error?.message) {
              showMessage(error.message, true);
            }
          }
        }

        const jobType = statusSnapshot?.job?.type;
        const shouldStopAll =
          jobType === "all" ||
          jobType === "parallel_playlists" ||
          (!playlistTargets.length && statusSnapshot.running);

        if (shouldStopAll) {
          try {
            const resultStatus = await stopAllBuildSilently();
            if (resultStatus && typeof resultStatus === "object") {
              updatedStatus = resultStatus;
            }
          } catch (error) {
            console.error(error);
            if (error?.message) {
              showMessage(error.message, true);
            }
          }
        }

        if (updatedStatus) {
          updateBuildStatusUi(updatedStatus);
        } else {
          await refreshBuildStatus();
        }
      }

      function normalizeProgressPercent(entry) {
        if (!entry || typeof entry !== "object") {
          return null;
        }

        if (typeof entry.percent === "number" && Number.isFinite(entry.percent)) {
          return entry.percent;
        }

        const percentCandidate = Number(entry.percent);
        if (Number.isFinite(percentCandidate)) {
          return percentCandidate;
        }

        const progressCandidate = Number(entry.progress);
        if (Number.isFinite(progressCandidate)) {
          if (progressCandidate >= 0 && progressCandidate <= 1) {
            return progressCandidate * 100;
          }
          if (progressCandidate >= 0) {
            return progressCandidate;
          }
        }

        const currentCandidate = Number(entry.current);
        const totalCandidate = Number(entry.total);
        if (
          Number.isFinite(currentCandidate) &&
          Number.isFinite(totalCandidate) &&
          totalCandidate > 0
        ) {
          return (currentCandidate / totalCandidate) * 100;
        }

        return null;
      }

      function normalizeGeneralLogEntry(entry) {
        if (entry === null || entry === undefined) {
          return { text: "" };
        }

        if (typeof entry === "string") {
          return { text: entry };
        }

        const normalized = {
          text: "",
        };

        if (typeof entry.text === "string") {
          normalized.text = entry.text;
        } else if (entry.text !== null && entry.text !== undefined) {
          normalized.text = String(entry.text);
        }

        if (entry.timestamp) {
          normalized.timestamp = entry.timestamp;
        }

        return normalized;
      }

      function addPlaylistName(targetSet, value) {
        if (!targetSet || value === null || value === undefined) {
          return;
        }

        const normalized = String(value).trim();
        if (normalized) {
          targetSet.add(normalized);
        }
      }

      function collectActivePlaylistSet(status) {
        const names = new Set();
        if (!status || typeof status !== "object") {
          return names;
        }

        if (Array.isArray(status.active_playlists)) {
          status.active_playlists.forEach((name) => addPlaylistName(names, name));
        }

        const job = status.job;
        if (job && typeof job === "object") {
          addPlaylistName(names, job.playlist);
          if (Array.isArray(job.active_playlists)) {
            job.active_playlists.forEach((name) => addPlaylistName(names, name));
          }
        }

        return names;
      }

      function collectWaitingPlaylistSet(status) {
        const names = new Set();
        if (!status || typeof status !== "object") {
          return names;
        }

        const consider = (value) => {
          if (!Array.isArray(value)) {
            return;
          }
          value.forEach((name) => addPlaylistName(names, name));
        };

        consider(status.waiting_playlists);
        const job = status.job;
        if (job && typeof job === "object") {
          consider(job.waiting_playlists);
        }

        return names;
      }

      function getActivePlaylistNames(status) {
        return Array.from(collectActivePlaylistSet(status)).sort((a, b) =>
          a.localeCompare(b)
        );
      }

      function parseDurationToMs(value) {
        if (value === null || value === undefined) {
          return null;
        }

        if (typeof value === "number" && Number.isFinite(value)) {
          return value * 1000;
        }

        if (typeof value !== "string") {
          value = String(value);
        }

        const trimmed = value.trim();
        if (!trimmed) {
          return null;
        }

        if (/^\d+(?::\d+){1,2}$/.test(trimmed)) {
          const parts = trimmed.split(":").map((part) => Number(part));
          if (parts.some((part) => Number.isNaN(part))) {
            return null;
          }
          while (parts.length < 3) {
            parts.unshift(0);
          }
          const [hours, minutes, seconds] = parts;
          return ((hours * 60 + minutes) * 60 + seconds) * 1000;
        }

        if (/^\d+(?:\.\d+)?$/.test(trimmed)) {
          const numeric = Number(trimmed);
          return Number.isFinite(numeric) ? numeric * 1000 : null;
        }

        let totalSeconds = 0;
        let matched = false;
        const regex =
          /(\d+(?:\.\d+)?)\s*(h(?:ours?)?|hr|hrs|m(?:in(?:ute)?s?)?|s(?:ec(?:ond)?s?)?)/gi;
        let match;
        while ((match = regex.exec(trimmed)) !== null) {
          matched = true;
          const quantity = parseFloat(match[1]);
          if (Number.isNaN(quantity)) {
            continue;
          }
          const unit = match[2].toLowerCase();
          if (unit.startsWith("h")) {
            totalSeconds += quantity * 3600;
          } else if (unit.startsWith("m")) {
            totalSeconds += quantity * 60;
          } else if (unit.startsWith("s")) {
            totalSeconds += quantity;
          }
        }

        if (matched && totalSeconds > 0) {
          return totalSeconds * 1000;
        }

        return null;
      }

      function computeProjectedFinishDate(jobProgress) {
        if (!jobProgress || typeof jobProgress !== "object") {
          return null;
        }

        const etaValue =
          jobProgress.eta !== undefined && jobProgress.eta !== null
            ? jobProgress.eta
            : jobProgress.ETA;
        const etaMs = parseDurationToMs(etaValue);
        if (etaMs === null) {
          return null;
        }

        const projected = new Date(Date.now() + etaMs);
        return Number.isNaN(projected.getTime()) ? null : projected;
      }

      function updatePlaylistBuildUi(playlist) {
        if (!playlist || !playlist._statusElements) {
          return;
        }

        const { indicator, line, message, button } = playlist._statusElements;
        const playlistName = (playlist.name || "").trim();
        const status = latestBuildStatus;
        const activeJob = status?.job || null;
        const activePlaylistName =
          activeJob && activeJob.type === "playlist"
            ? (activeJob.playlist || "").trim()
            : "";
        const activePlaylistsSet = collectActivePlaylistSet(status);
        const activePlaylistNames = Array.from(activePlaylistsSet);
        let isRunningThisPlaylist = Boolean(
          status?.running && playlistName && activePlaylistsSet.has(playlistName)
        );
        const isAllRunning = Boolean(status?.running && activeJob?.type === "all");
        const otherActiveNames = activePlaylistNames.filter(
          (name) => name !== playlistName
        );
        const normalizeWaitingNames = (names) =>
          Array.isArray(names)
            ? names
                .map((name) =>
                  name === null || name === undefined ? "" : String(name).trim()
                )
                .filter((name) => name.length > 0)
            : [];

        const waitingPlaylists = [
          ...normalizeWaitingNames(status?.waiting_playlists),
          ...normalizeWaitingNames(activeJob?.waiting_playlists),
        ];
        const waitingSet = new Set(waitingPlaylists);

        let isWaitingThisPlaylist = Boolean(
          playlistName &&
            !isRunningThisPlaylist &&
            waitingSet.has(playlistName)
        );

        if (isWaitingThisPlaylist) {
          isRunningThisPlaylist = false;
        }

        const cancellationInfo =
          playlistName && playlistCancellationMessages.get(playlistName);
        const hasCancellationPending = Boolean(cancellationInfo);
        if (hasCancellationPending) {
          isRunningThisPlaylist = false;
          isWaitingThisPlaylist = false;
        }

        const coerceInteger = (value) => {
          if (typeof value === "number" && Number.isFinite(value)) {
            return value;
          }
          if (typeof value === "string") {
            const trimmed = value.trim();
            if (trimmed) {
              const parsed = Number.parseInt(trimmed, 10);
              if (Number.isFinite(parsed)) {
                return parsed;
              }
            }
          }
          return null;
        };

        let runningWorkers = coerceInteger(status?.running_workers);
        if (!Number.isFinite(runningWorkers) || runningWorkers < 0) {
          runningWorkers = 0;
        }

        let parallelLimit = coerceInteger(status?.parallel_limit);
        if (!Number.isFinite(parallelLimit) || parallelLimit < 1) {
          parallelLimit = 1;
        }

        let pendingJobs = coerceInteger(status?.pending_jobs);
        if (!Number.isFinite(pendingJobs) || pendingJobs < 0) {
          pendingJobs = 0;
        }

        const hasWorkerCapacity = runningWorkers < parallelLimit;
        const shouldShowQueueButton = Boolean(
          status?.running &&
            playlistName &&
            !isRunningThisPlaylist &&
            (isWaitingThisPlaylist || isAllRunning || !hasWorkerCapacity)
        );

        const playlistResults = status?.results?.playlists || {};
        const lastResult = playlistName ? playlistResults[playlistName] : undefined;

        let indicatorState = "idle";
        if (isRunningThisPlaylist) {
          indicatorState = "running";
        } else if (isWaitingThisPlaylist) {
          indicatorState = "waiting";
        } else if (lastResult) {
          if (lastResult.state === "error") {
            indicatorState = "error";
          } else if (lastResult.state === "stopped") {
            indicatorState = "stopped";
          } else {
            indicatorState = "idle";
          }
        } else {
          indicatorState = "idle";
        }

        if (hasCancellationPending) {
          indicatorState = "idle";
        }

        indicator.classList.remove(
          "running",
          "waiting",
          "idle",
          "error",
          "success",
          "stopped"
        );
        indicator.classList.add(indicatorState);

        let statusLineText = playlistName ? "Idle" : "Name required to build";
        if (isRunningThisPlaylist) {
          statusLineText = "Building now…";
        } else if (isWaitingThisPlaylist) {
          statusLineText = "Queued – waiting";
        }

        if (hasCancellationPending) {
          statusLineText = "Cancellation requested";
        }
        line.textContent = statusLineText;

        let detailText = "";
        if (isRunningThisPlaylist && status?.since) {
          detailText = `Started ${formatTimestamp(status.since)}`;
        }

        if (hasCancellationPending) {
          const cancellationMessage = cancellationInfo?.message;
          detailText = cancellationMessage || detailText;
        }
        message.textContent = detailText;

        let buttonIcon = "▶";
        let baseTitle = playlistName
          ? "Build this playlist"
          : "Enter a playlist name to build it individually";

        if (isRunningThisPlaylist || isWaitingThisPlaylist) {
          buttonIcon = "⏹";
          baseTitle = isWaitingThisPlaylist
            ? "Cancel the queued build for this playlist"
            : "Stop building this playlist";
          button.classList.add("danger");
          button.classList.remove("secondary");
        } else if (shouldShowQueueButton) {
          buttonIcon = "⏳";
          baseTitle = "Queue this playlist to build after the current jobs finish";
          button.classList.remove("danger");
          button.classList.add("secondary");
        } else {
          buttonIcon = "▶";
          button.classList.remove("danger");
          button.classList.remove("secondary");
        }

        button.textContent = buttonIcon;

        const disableButton = !playlistName;
        button.disabled = Boolean(disableButton);
        if (!playlistName) {
          const disabledTitle = "Enter a playlist name to build it individually.";
          button.title = disabledTitle;
          button.setAttribute("aria-label", disabledTitle);
        } else if (shouldShowQueueButton) {
          const queueHints = [];
          if (otherActiveNames.length === 1) {
            queueHints.push(`Currently building '${otherActiveNames[0]}'`);
          } else if (otherActiveNames.length > 1) {
            queueHints.push(`Currently building ${otherActiveNames.length} playlists`);
          } else if (isAllRunning) {
            queueHints.push("Currently building all playlists");
          } else if (activePlaylistName) {
            queueHints.push(`Currently building '${activePlaylistName}'`);
          }
          if (!hasWorkerCapacity) {
            if (parallelLimit === 1) {
              queueHints.push("Maximum simultaneous build reached");
            } else {
              queueHints.push(
                `Maximum of ${parallelLimit} concurrent builds already running`
              );
            }
          }
          if (pendingJobs > 0) {
            queueHints.push(
              `${pendingJobs} job${pendingJobs === 1 ? "" : "s"} already queued`
            );
          }
          queueHints.unshift(baseTitle);
          queueHints.push("Click to queue this playlist");
          const queueTitle = `${queueHints.join(". ")}.`;
          button.title = queueTitle;
          button.setAttribute("aria-label", queueTitle);
        } else {
          const baseTitleText = `${baseTitle}.`;
          button.title = baseTitleText;
          button.setAttribute("aria-label", baseTitleText);
        }

      }

      function updateBuildLogsUi(status) {
        if (!buildStatusPanel || !buildLogContainer) {
          return;
        }

        updateActivityCollapseUi();

        const nowMs = Date.now();
        Array.from(playlistCancellationMessages.entries()).forEach(
          ([name, info]) => {
            if (!info || info.expiresAt <= nowMs) {
              playlistCancellationMessages.delete(name);
            }
          }
        );
        const running = Boolean(status?.running);
        const activePlaylists = getActivePlaylistNames(status);
        const activePlaylistsSet = new Set(activePlaylists);

        const normalizeWaitingNames = (names) =>
          Array.isArray(names)
            ? names
                .map((name) =>
                  name === null || name === undefined ? "" : String(name).trim()
                )
                .filter((name) => name.length > 0)
            : [];

        const waitingPlaylists = Array.from(
          new Set([
            ...normalizeWaitingNames(status?.waiting_playlists),
            ...normalizeWaitingNames(status?.job?.waiting_playlists),
          ])
        );
        const waitingSet = new Set(waitingPlaylists);

        if (waitingSet.size === 0) {
          waitingPlaylistOrder.clear();
          nextWaitingOrderValue = 1;
        } else {
          Array.from(waitingPlaylistOrder.keys()).forEach((name) => {
            if (!waitingSet.has(name)) {
              waitingPlaylistOrder.delete(name);
            }
          });
        }

        waitingPlaylists.forEach((name) => {
          if (!waitingPlaylistOrder.has(name)) {
            waitingPlaylistOrder.set(name, nextWaitingOrderValue++);
          }
        });
        const waitingOrder = new Map();
        waitingPlaylists.forEach((name, index) => {
          const orderValue = waitingPlaylistOrder.get(name);
          if (!waitingOrder.has(name)) {
            waitingOrder.set(
              name,
              orderValue !== undefined ? orderValue : index
            );
          }
        });

        const activeOrder = new Map();
        activePlaylists.forEach((name, index) => {
          if (!activeOrder.has(name)) {
            activeOrder.set(name, index);
          }
        });

        buildStatusPanel.classList.toggle("running", running);

        const rawLogsByPlaylist = status?.logs?.playlists || {};
        const logsByPlaylist = {};
        Object.entries(rawLogsByPlaylist).forEach(([rawName, rawEntries]) => {
          const trimmedName =
            typeof rawName === "string" ? rawName.trim() : "";
          if (!trimmedName) {
            return;
          }
          logsByPlaylist[trimmedName] = rawEntries;
        });
        const generalLogs = Array.isArray(status?.logs?.general)
          ? status.logs.general.slice()
          : [];

        const isFiltersName = (value) =>
          typeof value === "string" && value.trim().toLowerCase() === "filters";

        let hasFiltersPlaylist = false;
        if (Array.isArray(state.playlists)) {
          hasFiltersPlaylist = state.playlists.some((playlist) =>
            isFiltersName(playlist?.name)
          );
        }

        if (!hasFiltersPlaylist && activePlaylists.some((name) => isFiltersName(name))) {
          hasFiltersPlaylist = true;
        }

        if (!hasFiltersPlaylist && waitingPlaylists.some((name) => isFiltersName(name))) {
          hasFiltersPlaylist = true;
        }

        if (!hasFiltersPlaylist) {
          for (const name of playlistCancellationMessages.keys()) {
            if (isFiltersName(name)) {
              hasFiltersPlaylist = true;
              break;
            }
          }
        }

        if (!hasFiltersPlaylist) {
          const resultPlaylists = status?.results?.playlists;
          if (resultPlaylists && typeof resultPlaylists === "object") {
            for (const rawName of Object.keys(resultPlaylists)) {
              if (isFiltersName(rawName)) {
                hasFiltersPlaylist = true;
                break;
              }
            }
          }
        }

        if (!hasFiltersPlaylist) {
          Object.keys(logsByPlaylist).forEach((name) => {
            if (!isFiltersName(name)) {
              return;
            }
            const entries = logsByPlaylist[name];
            delete logsByPlaylist[name];
            if (Array.isArray(entries)) {
              entries.forEach((entry) => {
                generalLogs.push(normalizeGeneralLogEntry(entry));
              });
            }
          });
        }

        const combinedNames = Object.keys(logsByPlaylist);
        activePlaylists.forEach((name) => {
          if (!combinedNames.includes(name)) {
            combinedNames.push(name);
          }
        });
        waitingPlaylists.forEach((name) => {
          if (!combinedNames.includes(name)) {
            combinedNames.push(name);
          }
        });
        playlistCancellationMessages.forEach((info, name) => {
          if (typeof name === "string") {
            const trimmedName = name.trim();
            if (trimmedName && !combinedNames.includes(trimmedName)) {
              combinedNames.push(trimmedName);
            }
          }
        });

        const seenActivityKeys = new Set();

        const playlistNames = [];
        const seenNames = new Set();
        combinedNames.forEach((name) => {
          const trimmedName = (name || "").trim();
          if (!trimmedName || seenNames.has(trimmedName)) {
            return;
          }
          seenNames.add(trimmedName);
          playlistNames.push(trimmedName);
        });

        activePlaylists.forEach((name) => {
          if (!playlistActivityOrder.has(name)) {
            playlistActivityOrder.set(name, nextPlaylistActivityOrder++);
          }
        });

        const getGroupRank = (name) => {
          if (activeOrder.has(name)) {
            return 0;
          }
          if (waitingOrder.has(name)) {
            return 1;
          }
          return 2;
        };

        playlistNames.sort((a, b) => {
          const groupDiff = getGroupRank(a) - getGroupRank(b);
          if (groupDiff !== 0) {
            return groupDiff;
          }

          const orderA = playlistActivityOrder.get(a);
          const orderB = playlistActivityOrder.get(b);
          if (orderA !== undefined && orderB !== undefined && orderA !== orderB) {
            return orderA - orderB;
          }
          if (orderA !== undefined && orderB === undefined) {
            return -1;
          }
          if (orderA === undefined && orderB !== undefined) {
            return 1;
          }

          if (activeOrder.has(a) && activeOrder.has(b)) {
            return activeOrder.get(a) - activeOrder.get(b);
          }

          if (waitingOrder.has(a) && waitingOrder.has(b)) {
            return waitingOrder.get(a) - waitingOrder.get(b);
          }

          return a.localeCompare(b);
        });

        buildLogContainer.innerHTML = "";

        const blocksToRender = [];
        let renderedGroups = 0;

        const playlistBlocks = [];
        const renderedPlaylistNames = new Set();

        playlistNames.forEach((trimmedName) => {
          const entries = logsByPlaylist[trimmedName] || [];
          const isWaiting = waitingSet.has(trimmedName);
          const cancellationInfo = playlistCancellationMessages.get(trimmedName);
          const hasCancellationMessage = Boolean(cancellationInfo);
          if (!entries.length && !running && !isWaiting && !hasCancellationMessage) {
            return;
          }

          const block = document.createElement("div");
          block.className = "build-log-playlist";
          const isActivePlaylist =
            running &&
            activePlaylistsSet.has(trimmedName) &&
            !waitingSet.has(trimmedName);
          if (isActivePlaylist) {
            block.classList.add("is-active");
          }
          if (isWaiting) {
            block.classList.add("is-waiting");
          }

          const title = document.createElement("div");
          title.className = "build-log-playlist-title";
          title.textContent = trimmedName || "Unnamed Playlist";
          block.appendChild(title);

          const listEl = document.createElement("div");
          listEl.className = "build-log-playlist-entries";

          if (
            (activePlaylistsSet.has(trimmedName) ||
              logsByPlaylist[trimmedName]?.length ||
              hasCancellationMessage) &&
            !playlistActivityOrder.has(trimmedName)
          ) {
            playlistActivityOrder.set(trimmedName, nextPlaylistActivityOrder++);
          }

          const cancellationCutoff = playlistCancellationCutoffs.get(trimmedName) ?? null;
          let hasRecentEntry = false;
          const normalizedEntries = hasCancellationMessage
            ? []
            : Array.isArray(entries)
                ? entries
                    .map((entry) => {
                      if (entry && typeof entry === "object") {
                        return entry;
                      }
                      return {
                        type: "message",
                        text:
                          typeof entry === "string" ? entry : String(entry ?? ""),
                      };
                    })
                    .filter((entry) => {
                      if (!entry || typeof entry !== "object") {
                        return false;
                      }

                      if (cancellationCutoff !== null) {
                        const timestampMs = parseTimestampMs(entry.timestamp);
                        if (timestampMs === null || timestampMs <= cancellationCutoff) {
                          return false;
                        }
                        hasRecentEntry = true;
                      }

                      return true;
                    })
                : [];
          if (hasRecentEntry) {
            playlistCancellationCutoffs.delete(trimmedName);
          }
          const hadAnyRawEntries = Array.isArray(entries) && entries.length > 0;

          let hasContent = false;

          if (normalizedEntries.length) {
            const entry = normalizedEntries[normalizedEntries.length - 1];
            const entryKey = getPlaylistActivityKey(trimmedName, entry);
            if (entryKey) {
              seenActivityKeys.add(entryKey);
            }

            const percentValue = normalizeProgressPercent(entry);
            const isProgressEntry =
              entry && entry.type === "progress" && percentValue !== null;
            const isWaitingActive = isWaiting && running;
            const isProgressActive =
              isProgressEntry && entry?.is_final !== true && running;
            const showSpinner =
              (isActivePlaylist || isWaitingActive) &&
              !isProgressEntry &&
              entry?.is_final !== true;
            const isEntryActive =
              showSpinner ||
              isProgressActive ||
              isActivePlaylist ||
              isWaitingActive;

            if (entryKey) {
              const previousTimestamp = activityEntryLastSeen.get(entryKey);
              if (isEntryActive || previousTimestamp === undefined) {
                activityEntryLastSeen.set(entryKey, nowMs);
              }
              const lastTimestamp = activityEntryLastSeen.get(entryKey);
              if (
                !isEntryActive &&
                lastTimestamp !== undefined &&
                nowMs - lastTimestamp > ACTIVITY_ENTRY_TTL_MS
              ) {
                return;
              }
              if (dismissedActivityKeys.has(entryKey)) {
                return;
              }
            }

            const item = document.createElement("div");
            item.className = "playlist-log-entry";
            if (entryKey) {
              item.dataset.activityKey = entryKey;
            }

            if (isProgressEntry) {
              item.classList.add("progress-entry");
              const progressWrapper = document.createElement("div");
              progressWrapper.className = "playlist-log-bar";
              progressWrapper.setAttribute("role", "progressbar");
              progressWrapper.setAttribute("aria-valuemin", "0");
              progressWrapper.setAttribute("aria-valuemax", "100");
              const progressFill = document.createElement("span");
              const sanitizedPercent = Math.max(0, Math.min(100, percentValue));
              progressWrapper.setAttribute(
                "aria-valuenow",
                String(Math.round(sanitizedPercent))
              );
              progressFill.style.setProperty("--progress", `${sanitizedPercent}%`);
              progressFill.style.width = `${sanitizedPercent}%`;
              progressWrapper.appendChild(progressFill);
              item.appendChild(progressWrapper);
            }

            const messageRow = document.createElement("div");
            messageRow.className = "playlist-log-message";

            if (showSpinner) {
              item.classList.add("is-active-step");
              const spinner = document.createElement("div");
              spinner.className = "playlist-log-spinner";
              messageRow.appendChild(spinner);
            }

            const text = document.createElement("div");
            text.className = "playlist-log-text";
            text.textContent = entry?.text || "";
            messageRow.appendChild(text);

            if (entryKey) {
              const dismissOptions = { playlistName: trimmedName };
              if (isActivePlaylist || isWaitingActive) {
                dismissOptions.onDismiss = () => {
                  requestStopPlaylistFromActivity(trimmedName, entryKey, {
                    isWaiting,
                  });
                };
              }
              messageRow.appendChild(
                createDismissButton(entryKey, dismissOptions)
              );
            }

            item.appendChild(messageRow);
            listEl.appendChild(item);
            hasContent = true;
          } else if (!hasCancellationMessage && !hadAnyRawEntries) {
            const placeholder = document.createElement("div");
            placeholder.className = "playlist-log-entry";
            const showPlaceholderSpinner = isActivePlaylist || (isWaiting && running);
            if (showPlaceholderSpinner) {
              placeholder.classList.add("is-active-step");
            }

            const messageRow = document.createElement("div");
            messageRow.className = "playlist-log-message";

            if (showPlaceholderSpinner) {
              const spinner = document.createElement("div");
              spinner.className = "playlist-log-spinner";
              messageRow.appendChild(spinner);
            }

            const text = document.createElement("div");
            text.className = "playlist-log-text";
            if (isWaiting) {
              text.textContent = running
                ? "Queued – waiting to start…"
                : "Queued – waiting to start";
            } else {
              text.textContent = running
                ? "Waiting for playlist activity…"
                : "No recent activity.";
            }

            messageRow.appendChild(text);
            placeholder.appendChild(messageRow);
            listEl.appendChild(placeholder);
            hasContent = true;
          }

          if (hasCancellationMessage) {
            const cancellationEntry = document.createElement("div");
            cancellationEntry.className = "playlist-log-entry cancellation-entry";
            cancellationEntry.dataset.playlistName = trimmedName;
            const messageRow = document.createElement("div");
            messageRow.className = "playlist-log-message";
            const messageText = document.createElement("div");
            messageText.className = "playlist-log-text";
            const cancellationText =
              (cancellationInfo && cancellationInfo.message) ||
              `${trimmedName} has been cancelled.`;
            messageText.textContent = cancellationText;
            messageRow.appendChild(messageText);
            cancellationEntry.appendChild(messageRow);
            listEl.appendChild(cancellationEntry);
            hasContent = true;
          }

          if (!hasContent) {
            return;
          }

          block.appendChild(listEl);
          playlistBlocks.push(block);
          renderedPlaylistNames.add(trimmedName);
        });

        if (playlistBlocks.length) {
          renderedGroups += playlistBlocks.length;
          playlistBlocks.forEach((block) => blocksToRender.push(block));
        }

        Array.from(playlistActivityOrder.keys()).forEach((name) => {
          if (!renderedPlaylistNames.has(name)) {
            playlistActivityOrder.delete(name);
          }
        });

        Array.from(playlistCancellationCutoffs.keys()).forEach((name) => {
          if (
            renderedPlaylistNames.has(name) ||
            activePlaylistsSet.has(name) ||
            waitingSet.has(name)
          ) {
            return;
          }
          const rawEntries = logsByPlaylist[name];
          if (Array.isArray(rawEntries) && rawEntries.length > 0) {
            return;
          }
          playlistCancellationCutoffs.delete(name);
        });

        const normalizedGeneralEntries = generalLogs
          .map((entry) => normalizeGeneralLogEntry(entry))
          .filter((entry) => {
            if (!entry) {
              return false;
            }
            const textValue =
              typeof entry.text === "string" ? entry.text.trim() : "";
            if (!textValue) {
              return false;
            }
            entry.text = textValue;
            const normalizedTextLower = textValue.toLowerCase();
            const isSuccessEntry =
              textValue.startsWith("✅") ||
              normalizedTextLower.includes("finished successfully");
            const timestampMs = parseTimestampMs(entry.timestamp);
            if (timestampMs !== null) {
              const retentionLimit = isSuccessEntry
                ? ACTIVITY_ENTRY_TTL_MS
                : GENERAL_ACTIVITY_RETENTION_MS;
              if (nowMs - timestampMs > retentionLimit) {
                return false;
              }
            }
            return true;
          })
          .slice(-3);

        if (normalizedGeneralEntries.length) {
          const block = document.createElement("div");
          block.className = "build-log-playlist general-activity";
          const title = document.createElement("div");
          title.className = "build-log-playlist-title";
          title.textContent = "General Activity";
          block.appendChild(title);

          const listEl = document.createElement("div");
          listEl.className = "build-log-playlist-entries";

          normalizedGeneralEntries.forEach((entry) => {
            const entryKey = getGeneralActivityKey(entry);
            if (entryKey) {
              seenActivityKeys.add(entryKey);
              const previousTimestamp = activityEntryLastSeen.get(entryKey);
              if (running || previousTimestamp === undefined) {
                activityEntryLastSeen.set(entryKey, nowMs);
              }
              const lastTimestamp = activityEntryLastSeen.get(entryKey);
              if (
                !running &&
                lastTimestamp !== undefined &&
                nowMs - lastTimestamp > ACTIVITY_ENTRY_TTL_MS
              ) {
                return;
              }
              if (dismissedActivityKeys.has(entryKey)) {
                return;
              }
            }

            const item = document.createElement("div");
            item.className = "playlist-log-entry general-entry";
            if (entryKey) {
              item.dataset.activityKey = entryKey;
            }
            const messageRow = document.createElement("div");
            messageRow.className = "playlist-log-message";

            const text = document.createElement("div");
            text.className = "playlist-log-text";
            text.textContent = entry.text || "";
            messageRow.appendChild(text);

            if (entryKey) {
              messageRow.appendChild(createDismissButton(entryKey));
            }

            item.appendChild(messageRow);
            listEl.appendChild(item);
          });

          if (listEl.childElementCount > 0) {
            block.appendChild(listEl);
            blocksToRender.push(block);
            renderedGroups += 1;
          }
        }

        blocksToRender.forEach((block) => buildLogContainer.appendChild(block));

        if (activityEntryLastSeen.size) {
          activityEntryLastSeen.forEach((timestamp, key) => {
            if (!seenActivityKeys.has(key)) {
              activityEntryLastSeen.delete(key);
            }
          });
        }

        if (!renderedGroups) {
          const empty = document.createElement("div");
          empty.className = "playlist-log-empty";
          empty.textContent = running
            ? "Waiting for playlist activity…"
            : "No playlist activity recorded yet.";
          buildLogContainer.appendChild(empty);
        }

        if (clearActivityBtn) {
          const hasDismissibleEntries = Boolean(
            buildLogContainer.querySelector(
              ".playlist-log-entry[data-activity-key]"
            )
          );
          const hasCancellationEntries = Boolean(
            buildLogContainer.querySelector(".playlist-log-entry.cancellation-entry")
          );
          const canClear = hasDismissibleEntries || hasCancellationEntries;
          clearActivityBtn.disabled = !canClear;
          clearActivityBtn.setAttribute(
            "aria-disabled",
            clearActivityBtn.disabled ? "true" : "false"
          );
        }
      }

      function updateBuildStatusUi(status) {
        if (!status) {
          return;
        }

        latestBuildStatus = status;
        updateBuildLogsUi(status);
        const isRunning = Boolean(status.running);
        const activeJob = status.job || null;
        const isAllRunning = Boolean(isRunning && activeJob?.type === "all");
        let indicatorState = "idle";
        if (isRunning) {
          indicatorState = "running";
        } else if (status.status === "error") {
          indicatorState = "error";
        } else if (status.status === "success") {
          indicatorState = "success";
        } else if (status.status === "stopped") {
          indicatorState = "stopped";
        }

        buildStatusIndicator.classList.remove(
          "running",
          "waiting",
          "idle",
          "error",
          "success",
          "stopped"
        );
        buildStatusIndicator.classList.add(indicatorState);

        let statusTextValue = "Idle";
        if (indicatorState === "running") {
          statusTextValue = "Building";
        } else if (indicatorState === "success") {
          statusTextValue = "Completed";
        } else if (indicatorState === "stopped") {
          statusTextValue = "Stopped";
        } else if (indicatorState === "error") {
          statusTextValue = "Error";
        }
        buildStatusText.textContent = statusTextValue;

        const jobProgress = activeJob?.progress;
        let statusMessageValue = status.message || "";
        const normalizedJobPercent = jobProgress
          ? normalizeProgressPercent(jobProgress)
          : null;
        if (
          isRunning &&
          jobProgress &&
          normalizedJobPercent !== null
        ) {
          const percentValue = normalizedJobPercent;
          const currentCandidate = Number(jobProgress.current);
          const totalCandidate = Number(jobProgress.total);
          const currentValue = Number.isFinite(currentCandidate)
            ? Math.max(0, Math.floor(currentCandidate))
            : null;
          const totalValue = Number.isFinite(totalCandidate)
            ? Math.max(0, Math.floor(totalCandidate))
            : null;
          const percentDisplay = Math.round(Math.max(0, Math.min(100, percentValue)));
          const totalText =
            currentValue !== null && totalValue !== null
              ? `${currentValue}/${totalValue}`
              : currentValue !== null
              ? `${currentValue}`
              : null;

          statusMessageValue = totalText
            ? `Filtering tracks… ${totalText} (${percentDisplay}%)`
            : `Filtering tracks… ${percentDisplay}%`;

          if (jobProgress.rate) {
            statusMessageValue = `${statusMessageValue} – ${jobProgress.rate}`;
          } else if (jobProgress.details) {
            statusMessageValue = `${statusMessageValue} ${jobProgress.details}`;
          }
        }

        buildStatusMessage.textContent = statusMessageValue;

        const projectedFinish = isRunning
          ? computeProjectedFinishDate(jobProgress)
          : null;
        const metaParts = [];
        if (isRunning && status.pid) {
          metaParts.push(`PID ${status.pid}`);
        }
        if (isRunning && status.since) {
          metaParts.push(`Started ${formatTimestamp(status.since)}`);
        }
        if (isRunning && projectedFinish) {
          metaParts.push(
            `Projected finish ${formatTimestamp(projectedFinish.toISOString())}`
          );
        }
        if (!isRunning) {
          const lastAllResult = status.results?.all;
          const lastFinishedIso = status.last_finished;
          if (
            lastAllResult?.finished_at &&
            (!lastFinishedIso || lastAllResult.finished_at === lastFinishedIso)
          ) {
            let label = "Last build finished";
            if (lastAllResult.state === "success") {
              label = "Last build completed";
            } else if (lastAllResult.state === "stopped") {
              label = "Last build stopped";
            } else if (lastAllResult.state === "error") {
              label = "Last build failed";
            }
            metaParts.push(`${label} ${formatTimestamp(lastAllResult.finished_at)}`);
          } else if (status.last_finished) {
            metaParts.push(`Last finished ${formatTimestamp(status.last_finished)}`);
          }
          if (typeof status.exit_code === "number") {
            metaParts.push(`Last exit code ${status.exit_code}`);
          }
        }
        buildStatusMeta.textContent = metaParts.join(" • ");

        buildToggleBtn.textContent = isAllRunning ? "⏹" : "▶";
        buildToggleBtn.classList.toggle("danger", isAllRunning);
        buildToggleBtn.disabled = Boolean(status.transitioning || (isRunning && !isAllRunning));
        let toggleTitle = "Build all playlists.";
        if (isRunning && !isAllRunning) {
          toggleTitle = "A playlist build is currently running.";
        } else if (isAllRunning) {
          toggleTitle = "Stop building all playlists.";
        }
        buildToggleBtn.title = toggleTitle;
        buildToggleBtn.setAttribute("aria-label", toggleTitle);

        if (Array.isArray(state.playlists)) {
          state.playlists.forEach((playlist) => updatePlaylistBuildUi(playlist));
        }
      }

      async function refreshBuildStatus(showErrors = false) {
        try {
          const response = await fetch("/api/build/status");
          if (!response.ok) {
            throw new Error("Unable to retrieve build status");
          }
          const status = await response.json();
          updateBuildStatusUi(status);
        } catch (error) {
          console.error(error);
          if (showErrors) {
            showMessage(error.message, true);
          }
        }
      }

      async function toggleBuild() {
        const isRunningAll = Boolean(
          latestBuildStatus?.running && latestBuildStatus?.job?.type === "all"
        );
        const anotherJobRunning = Boolean(
          latestBuildStatus?.running && !isRunningAll
        );
        if (anotherJobRunning) {
          showMessage("A playlist build is currently running. Stop it before starting a full build.", true);
          return;
        }

        const endpoint = isRunningAll ? "/api/build/stop" : "/api/build/start";

        buildToggleBtn.disabled = true;
        try {
          if (!isRunningAll) {
            await saveData({ showSuccessMessage: false, rethrowOnError: true });
          }

          const response = await fetch(endpoint, { method: "POST" });
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(
              result.message ||
                (isRunningAll ? "Failed to stop build." : "Failed to start build.")
            );
          }

          if (result.status) {
            updateBuildStatusUi(result.status);
          } else {
            await refreshBuildStatus();
          }

          if (result.message) {
            showMessage(result.message, false);
          } else {
            showMessage(isRunningAll ? "Build stopping..." : "Build starting...");
          }

          setTimeout(() => {
            refreshBuildStatus();
          }, 1000);
        } catch (error) {
          console.error(error);
          if (!error?._fromSaveData) {
            showMessage(error.message, true);
          }
        } finally {
          buildToggleBtn.disabled = false;
        }
      }

      async function togglePlaylistBuild(playlist) {
        const playlistName = (playlist?.name || "").trim();
        if (!playlistName) {
          showMessage("Please name the playlist before building it.", true);
          return;
        }

        const activePlaylistsSet = collectActivePlaylistSet(latestBuildStatus);
        const waitingPlaylistsSet = collectWaitingPlaylistSet(latestBuildStatus);
        const isRunningThisPlaylist = Boolean(
          latestBuildStatus?.running &&
            activePlaylistsSet.has(playlistName)
        );
        const isWaitingThisPlaylist = Boolean(
          waitingPlaylistsSet.has(playlistName)
        );
        const shouldStopPlaylist = isRunningThisPlaylist || isWaitingThisPlaylist;

        const elements = playlist._statusElements || {};
        if (elements.button) {
          elements.button.disabled = true;
        }

        const endpoint = shouldStopPlaylist
          ? "/api/build/stop_playlist"
          : "/api/build/start";
        const options = {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ playlist: playlistName }),
        };

        try {
          if (!shouldStopPlaylist) {
            await savePlaylist(
              playlist,
              undefined,
              elements.headerTitle,
              elements.nameInput,
              { showSuccessMessage: false, rethrowOnError: true }
            );
          }

          const response = await fetch(endpoint, options);
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(
              result.message ||
                (isRunningThisPlaylist
                  ? "Failed to stop playlist build."
                  : "Failed to start playlist build.")
            );
          }

          if (result.status) {
            updateBuildStatusUi(result.status);
          } else {
            await refreshBuildStatus();
          }

          if (result.message) {
            showMessage(result.message);
          } else {
            showMessage(
              shouldStopPlaylist
                ? isWaitingThisPlaylist
                  ? `Cancelling queued build for '${playlistName}'...`
                  : `Stopping '${playlistName}'...`
                : `Starting '${playlistName}'...`
            );
          }

          if (shouldStopPlaylist) {
            registerPlaylistCancellation(
              playlistName,
              isWaitingThisPlaylist
                ? `Cancellation requested for '${playlistName}'.`
                : undefined
            );
          }

          setTimeout(() => {
            refreshBuildStatus();
          }, 1000);
        } catch (error) {
          console.error(error);
          if (!error?._fromSavePlaylist) {
            showMessage(error.message, true);
          }
        } finally {
          if (elements.button) {
            elements.button.disabled = false;
          }
          updatePlaylistBuildUi(playlist);
        }
      }

      function ensureExtras(target) {
        if (!target.extras || typeof target.extras !== "object") {
          target.extras = {};
        }
        return target.extras;
      }

      function sanitizeExtras(extras) {
        const sanitized = {};
        Object.entries(extras || {}).forEach(([key, value]) => {
          if (value === undefined || value === null) {
            return;
          }
          const trimmed = String(value).trim();
          if (trimmed) {
            sanitized[key] = trimmed;
          }
        });
        return sanitized;
      }

      function buildCoverPreviewUrl(rawPath) {
        return `/api/cover_preview?path=${encodeURIComponent(rawPath)}`;
      }

      function updateImagePreview(
        container,
        imageEl,
        labelEl,
        rawPath,
        texts = {}
      ) {
        if (!container || !imageEl || !labelEl) {
          return;
        }
        const emptyText = texts.empty || "No image selected";
        const loadingText = texts.loading || "Loading preview…";
        const errorText = texts.error || "Preview unavailable";
        const value = (rawPath || "").trim();

        if (!value) {
          container.classList.remove("has-image");
          labelEl.textContent = emptyText;
          labelEl.title = emptyText;
          container.title = emptyText;
          container.setAttribute("aria-label", emptyText);
          imageEl.removeAttribute("src");
          imageEl.dataset.previewPath = "";
          return;
        }

        container.classList.remove("has-image");
        labelEl.textContent = loadingText;
        labelEl.title = value;
        container.title = loadingText;
        container.setAttribute("aria-label", loadingText);
        const previewPath = value;
        imageEl.dataset.previewPath = previewPath;
        imageEl.onload = () => {
          if (imageEl.dataset.previewPath !== previewPath) {
            return;
          }
          container.classList.add("has-image");
          labelEl.textContent = previewPath;
          labelEl.title = previewPath;
          container.title = previewPath;
          container.setAttribute("aria-label", previewPath);
        };
        imageEl.onerror = () => {
          if (imageEl.dataset.previewPath !== previewPath) {
            return;
          }
          container.classList.remove("has-image");
          labelEl.textContent = errorText;
          labelEl.title = errorText;
          container.title = errorText;
          container.setAttribute("aria-label", errorText);
        };
        imageEl.src = buildCoverPreviewUrl(previewPath);
      }

      function determineDirectoryHint(rawPath) {
        const trimmed = (rawPath || "").trim();
        if (!trimmed) {
          return "";
        }
        if (trimmed.endsWith("/") || trimmed.endsWith("\\")) {
          return trimmed;
        }
        const lastSlash = Math.max(
          trimmed.lastIndexOf("/"),
          trimmed.lastIndexOf("\\")
        );
        if (lastSlash >= 0) {
          return trimmed.slice(0, lastSlash + 1);
        }
        return "";
      }

      function computeParentPath(rawPath) {
        const trimmed = (rawPath || "").trim();
        if (!trimmed) {
          return "";
        }
        let normalized = trimmed;
        if (normalized.endsWith("/") || normalized.endsWith("\\")) {
          normalized = normalized.slice(0, -1);
        }
        const lastSlash = Math.max(
          normalized.lastIndexOf("/"),
          normalized.lastIndexOf("\\")
        );
        if (lastSlash < 0) {
          return "";
        }
        return normalized.slice(0, lastSlash + 1);
      }

      function renderCoverPickerDirectories(entries) {
        if (!coverPickerDirectories) {
          return false;
        }
        coverPickerDirectories.innerHTML = "";
        const directories = entries.filter((entry) => entry && entry.is_dir);
        directories.forEach((entry) => {
          const button = document.createElement("button");
          button.type = "button";
          button.textContent = `📁 ${entry.name}`;
          button.addEventListener("click", () => {
            loadCoverPickerDirectory(entry.suggestion || "");
          });
          coverPickerDirectories.appendChild(button);
        });
        return directories.length > 0;
      }

      function renderCoverPickerImages(entries) {
        if (!coverPickerGrid) {
          return false;
        }
        coverPickerGrid.innerHTML = "";
        const images = entries.filter((entry) => entry && entry.is_image);
        if (!images.length) {
          const empty = document.createElement("div");
          empty.className = "cover-picker-empty";
          empty.textContent = "No image files found in this folder.";
          coverPickerGrid.appendChild(empty);
          return false;
        }
        images.forEach((entry) => {
          const button = document.createElement("button");
          button.type = "button";
          const thumb = document.createElement("img");
          thumb.src = buildCoverPreviewUrl(entry.suggestion || "");
          thumb.alt = entry.name || "Cover image";
          thumb.loading = "lazy";
          thumb.draggable = false;
          button.appendChild(thumb);
          const caption = document.createElement("span");
          caption.textContent = entry.name || entry.suggestion || "Image";
          button.appendChild(caption);
          const handlePreview = () => {
            previewCoverCandidate(entry.suggestion || "");
          };
          button.addEventListener("mouseenter", handlePreview);
          button.addEventListener("focus", handlePreview);
          button.addEventListener("touchstart", handlePreview, { passive: true });
          button.addEventListener("click", () => {
            chooseCoverFromPicker(entry.suggestion || "");
          });
          coverPickerGrid.appendChild(button);
        });
        return true;
      }

      function applyCoverPickerWheelScroll(event, container) {
        if (!container || !coverPickerOverlay?.classList.contains("show")) {
          return false;
        }

        const maxScrollTop = container.scrollHeight - container.clientHeight;
        const maxScrollLeft = container.scrollWidth - container.clientWidth;
        const hasVertical = maxScrollTop > 0;
        const hasHorizontal = maxScrollLeft > 0;

        if (!hasVertical && !hasHorizontal) {
          return false;
        }

        const deltaY = event.deltaY || 0;
        const deltaX = event.deltaX || 0;
        let didScroll = false;

        if (hasVertical && deltaY) {
          const previousTop = container.scrollTop;
          const nextTop = Math.max(
            0,
            Math.min(maxScrollTop, previousTop + deltaY)
          );
          if (nextTop !== previousTop) {
            container.scrollTop = nextTop;
            didScroll = true;
          }
        }

        if (hasHorizontal && deltaX) {
          const previousLeft = container.scrollLeft;
          const nextLeft = Math.max(
            0,
            Math.min(maxScrollLeft, previousLeft + deltaX)
          );
          if (nextLeft !== previousLeft) {
            container.scrollLeft = nextLeft;
            didScroll = true;
          }
        }

        if (didScroll) {
          event.preventDefault();
        }

        return didScroll;
      }

      function updateCoverPickerUpButton() {
        if (!coverPickerUpBtn) {
          return;
        }
        const parentPath = computeParentPath(coverPickerState.currentRawPath);
        coverPickerUpBtn.disabled = !parentPath;
        coverPickerUpBtn.dataset.parentPath = parentPath || "";
      }

      function updateCoverPickerClearButton() {
        if (!coverPickerClearBtn) {
          return;
        }
        const hasSelection = Boolean(
          (coverPickerState.selectedPath || "").trim()
        );
        coverPickerClearBtn.disabled = !hasSelection;
      }

      function previewCoverCandidate(rawPath) {
        if (!coverPickerPreview || !coverPickerPreviewImage) {
          return;
        }
        const targetPath = (rawPath || "").trim();
        updateImagePreview(
          coverPickerPreview,
          coverPickerPreviewImage,
          coverPickerPreviewLabel,
          targetPath,
          COVER_PICKER_PREVIEW_TEXTS
        );
      }

      async function loadCoverPickerDirectory(rawPath = "") {
        if (!coverPickerOverlay) {
          return;
        }
        const trimmed = (rawPath || "").trim();
        if (coverPickerState.directoryController) {
          coverPickerState.directoryController.abort();
        }
        const controller = new AbortController();
        coverPickerState.directoryController = controller;
        coverPickerState.currentRawPath = trimmed;
        if (coverPickerDirectories) {
          coverPickerDirectories.innerHTML = "";
        }
        if (coverPickerGrid) {
          coverPickerGrid.innerHTML = "";
        }
        if (coverPickerStatus) {
          coverPickerStatus.textContent = "Loading covers…";
        }
        const params = new URLSearchParams();
        if (trimmed) {
          params.set("path", trimmed);
        }
        const query = params.toString();
        const url = query ? `/api/list_directory?${query}` : "/api/list_directory";
        try {
          const response = await fetch(url, { signal: controller.signal });
          if (!response.ok) {
            throw new Error("Unable to load directory contents");
          }
          const data = await response.json();
          if (controller.signal.aborted) {
            return;
          }
          const entries = Array.isArray(data.entries) ? data.entries : [];
          coverPickerState.currentDirectory = data.directory || "";
          if (coverPickerPath) {
            const pathText =
              coverPickerState.currentDirectory || "Directory unavailable";
            coverPickerPath.textContent = pathText;
            coverPickerPath.title = pathText;
          }
          const hasDirectories = renderCoverPickerDirectories(entries);
          const hasImages = renderCoverPickerImages(entries);
          if (coverPickerStatus) {
            if (!entries.length) {
              coverPickerStatus.textContent = "This folder is empty.";
            } else if (!hasImages && hasDirectories) {
              coverPickerStatus.textContent =
                "Open a folder to keep browsing covers.";
            } else if (!hasImages) {
              coverPickerStatus.textContent = "No image files found here.";
            } else {
              coverPickerStatus.textContent = "Tap a cover to select it.";
            }
          }
          previewCoverCandidate(coverPickerState.selectedPath);
        } catch (error) {
          if (controller.signal.aborted) {
            return;
          }
          console.error(error);
          if (coverPickerStatus) {
            coverPickerStatus.textContent =
              "Unable to load covers for this location.";
          }
          if (coverPickerGrid) {
            coverPickerGrid.innerHTML = "";
            const errorEl = document.createElement("div");
            errorEl.className = "cover-picker-empty";
            errorEl.textContent =
              "Unable to load cover images for this folder.";
            coverPickerGrid.appendChild(errorEl);
          }
        } finally {
          if (coverPickerState.directoryController === controller) {
            coverPickerState.directoryController = null;
          }
          updateCoverPickerUpButton();
          previewCoverCandidate(coverPickerState.selectedPath);
        }
      }

      function chooseCoverFromPicker(rawPath) {
        if (!coverPickerState.playlist || !coverPickerState.inputEl) {
          return;
        }
        const trimmed = (rawPath || "").trim();
        coverPickerState.selectedPath = trimmed;
        const extras = ensureExtras(coverPickerState.playlist);
        extras[coverPickerState.extrasKey] = trimmed;
        coverPickerState.inputEl.value = trimmed;
        updateCoverPickerClearButton();
        if (
          coverPickerState.previewContainer &&
          coverPickerState.previewImage &&
          coverPickerState.previewLabel
        ) {
          updateImagePreview(
            coverPickerState.previewContainer,
            coverPickerState.previewImage,
            coverPickerState.previewLabel,
            trimmed,
            CARD_COVER_PREVIEW_TEXTS
          );
        }
        coverPickerState.inputEl.dispatchEvent(
          new Event("input", { bubbles: true })
        );
        closeCoverPicker();
      }

      async function uploadCoverImage({
        file,
        playlist,
        inputEl,
        extrasKey,
        preview,
      }) {
        if (!file) {
          throw new Error("No cover image selected.");
        }

        const formData = new FormData();
        formData.append("file", file);

        let response;
        try {
          response = await fetch("/api/upload_cover", {
            method: "POST",
            body: formData,
          });
        } catch (error) {
          throw new Error("Unable to upload cover image.");
        }

        let payload = {};
        try {
          payload = await response.json();
        } catch (error) {
          payload = {};
        }

        if (!response.ok) {
          const message =
            (payload && (payload.error || payload.message)) ||
            `Upload failed with status ${response.status}.`;
          throw new Error(message);
        }

        const savedPath =
          typeof payload.path === "string" ? payload.path.trim() : "";
        if (!savedPath) {
          throw new Error(
            "Upload succeeded but no cover path was returned."
          );
        }

        if (inputEl) {
          inputEl.value = savedPath;
          inputEl.dispatchEvent(new Event("input", { bubbles: true }));
        } else if (playlist && extrasKey) {
          const extras = ensureExtras(playlist);
          delete extras.source;
          delete extras.spotify_url;
          playlist.source = normalizePlaylistSource(playlist.source);
          playlist.spotify_url = sanitizeSpotifyUrl(playlist.spotify_url);
          extras[extrasKey] = savedPath;
          if (
            preview?.container &&
            preview?.image &&
            preview?.label
          ) {
            updateImagePreview(
              preview.container,
              preview.image,
              preview.label,
              savedPath,
              CARD_COVER_PREVIEW_TEXTS
            );
          }
        }

        return { path: savedPath, response: payload };
      }

      async function handleCoverPickerUploadChange(event) {
        if (!coverPickerState.playlist || !coverPickerState.inputEl) {
          return;
        }
        const fileList = event?.target?.files;
        const file = fileList && fileList[0];
        if (!file) {
          return;
        }

        if (coverPickerUploadBtn) {
          coverPickerUploadBtn.disabled = true;
        }

        showPlaylistInlineMessage(
          coverPickerState.playlist,
          `Uploading "${file.name}"...`,
          { persist: true }
        );

        try {
          const result = await uploadCoverImage({
            file,
            playlist: coverPickerState.playlist,
            inputEl: coverPickerState.inputEl,
            extrasKey: coverPickerState.extrasKey,
            preview: {
              container: coverPickerState.previewContainer,
              image: coverPickerState.previewImage,
              label: coverPickerState.previewLabel,
            },
          });
          coverPickerState.selectedPath = result?.path || "";
          showPlaylistInlineMessage(
            coverPickerState.playlist,
            "Cover uploaded successfully."
          );
          closeCoverPicker();
        } catch (error) {
          console.error(error);
          const message =
            (error && error.message) || "Failed to upload cover image.";
          showPlaylistInlineMessage(coverPickerState.playlist, message, {
            isError: true,
            duration: 8000,
          });
        } finally {
          if (coverPickerUploadBtn) {
            coverPickerUploadBtn.disabled = false;
            coverPickerUploadBtn.blur();
          }
          if (coverPickerUploadInput) {
            coverPickerUploadInput.value = "";
          }
          updateCoverPickerClearButton();
        }
      }

      function openCoverPicker(playlist, inputEl, extrasKey, previewElements) {
        if (!coverPickerOverlay || !coverPickerPanel) {
          return;
        }
        coverPickerState.playlist = playlist;
        coverPickerState.inputEl = inputEl;
        coverPickerState.extrasKey = extrasKey;
        coverPickerState.previewContainer = previewElements?.container || null;
        coverPickerState.previewImage = previewElements?.image || null;
        coverPickerState.previewLabel = previewElements?.label || null;
        coverPickerState.selectedPath = (inputEl.value || "").trim();
        const directoryHint = determineDirectoryHint(
          coverPickerState.selectedPath
        );
        if (directoryHint) {
          coverPickerState.currentRawPath = directoryHint;
        } else {
          coverPickerState.currentRawPath = COVER_PICKER_DEFAULT_DIRECTORY;
        }
        coverPickerState.lastFocus = document.activeElement;
        updateCoverPickerClearButton();
        if (coverPickerUploadBtn) {
          coverPickerUploadBtn.disabled = false;
        }
        if (coverPickerUploadInput) {
          coverPickerUploadInput.value = "";
        }
        coverPickerOverlay.classList.add("show");
        coverPickerOverlay.setAttribute("aria-hidden", "false");
        if (document.body) {
          document.body.classList.add("no-scroll");
          coverPickerState.scrollLocked = true;
        }
        setTimeout(() => {
          try {
            coverPickerPanel.focus({ preventScroll: true });
          } catch (error) {
            // Ignore focus errors
          }
        }, 0);
        previewCoverCandidate(coverPickerState.selectedPath);
        loadCoverPickerDirectory(coverPickerState.currentRawPath);
      }

      function closeCoverPicker() {
        if (!coverPickerOverlay) {
          return;
        }
        if (coverPickerState.directoryController) {
          coverPickerState.directoryController.abort();
          coverPickerState.directoryController = null;
        }
        coverPickerOverlay.classList.remove("show");
        coverPickerOverlay.setAttribute("aria-hidden", "true");
        if (coverPickerStatus) {
          coverPickerStatus.textContent = "";
        }
        if (coverPickerDirectories) {
          coverPickerDirectories.innerHTML = "";
        }
        if (coverPickerGrid) {
          coverPickerGrid.innerHTML = "";
        }
        if (coverPickerUpBtn) {
          coverPickerUpBtn.disabled = true;
          coverPickerUpBtn.dataset.parentPath = "";
        }
        if (coverPickerUploadInput) {
          coverPickerUploadInput.value = "";
        }
        if (coverPickerUploadBtn) {
          coverPickerUploadBtn.disabled = false;
        }
        if (coverPickerClearBtn) {
          coverPickerClearBtn.disabled = true;
        }
        if (coverPickerState.scrollLocked && document.body) {
          if (!configOverlay?.classList.contains("show")) {
            document.body.classList.remove("no-scroll");
          }
          coverPickerState.scrollLocked = false;
        }
        const focusTarget = coverPickerState.lastFocus;
        coverPickerState.playlist = null;
        coverPickerState.inputEl = null;
        coverPickerState.extrasKey = "";
        coverPickerState.previewContainer = null;
        coverPickerState.previewImage = null;
        coverPickerState.previewLabel = null;
        coverPickerState.selectedPath = "";
        coverPickerState.currentRawPath = "";
        coverPickerState.currentDirectory = "";
        coverPickerState.lastFocus = null;
        if (focusTarget && typeof focusTarget.focus === "function") {
          try {
            focusTarget.focus({ preventScroll: true });
          } catch (error) {
            // Ignore focus restoration errors
          }
        }
      }

      function handleCoverPickerUp() {
        if (!coverPickerUpBtn) {
          return;
        }
        const parentPath =
          coverPickerUpBtn.dataset.parentPath ||
          computeParentPath(coverPickerState.currentRawPath);
        if (!parentPath) {
          return;
        }
        loadCoverPickerDirectory(parentPath);
      }

      function clearCoverPickerSelection() {
        if (!coverPickerState.inputEl || !coverPickerState.playlist) {
          return;
        }
        coverPickerState.selectedPath = "";
        coverPickerState.inputEl.value = "";
        coverPickerState.inputEl.dispatchEvent(
          new Event("input", { bubbles: true })
        );
        showPlaylistInlineMessage(
          coverPickerState.playlist,
          "Cover cleared."
        );
        updateCoverPickerClearButton();
        previewCoverCandidate("");
      }

      function createOptionElements(selectEl, opts, selectedValue = "") {
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select...";
        selectEl.appendChild(placeholder);

        opts.forEach((opt) => {
          const option = document.createElement("option");
          option.value = opt.value;
          option.textContent = opt.label;
          if (opt.value === selectedValue) {
            option.selected = true;
          }
          selectEl.appendChild(option);
        });
      }

      function renderFilters(containerEl, filters, onRemove) {
        containerEl.innerHTML = "";

        if (!filters.length) {
          const emptyState = document.createElement("p");
          emptyState.className = "no-filters";
          emptyState.textContent = "No filters configured.";
          containerEl.appendChild(emptyState);
        }

        filters.forEach((filter, index) => {
          const row = document.createElement("div");
          row.className = "filter-row";

          const fieldSelect = document.createElement("select");
          createOptionElements(fieldSelect, options.fields, filter.field || "");
          fieldSelect.value = filter.field || "";
          fieldSelect.addEventListener("change", (event) => {
            filter.field = event.target.value;
          });

          const operatorSelect = document.createElement("select");
          createOptionElements(operatorSelect, options.operators, filter.operator || "equals");
          operatorSelect.value = filter.operator || "";
          operatorSelect.addEventListener("change", (event) => {
            filter.operator = event.target.value;
          });

          const valueWrapper = document.createElement("div");
          valueWrapper.className = "value-input";
          const valueInput = document.createElement("input");
          valueInput.type = "text";
          valueInput.placeholder = "Value (comma separated for multiple)";
          valueInput.value = filter.value || "";
          valueInput.addEventListener("input", (event) => {
            filter.value = event.target.value;
          });

          const flagsWrapper = document.createElement("div");
          flagsWrapper.className = "filter-flags";

          const matchAllLabel = document.createElement("label");
          matchAllLabel.className = "filter-flag";
          const matchAllInput = document.createElement("input");
          matchAllInput.type = "checkbox";
          matchAllInput.checked = filter.match_all !== undefined ? !!filter.match_all : true;
          matchAllInput.setAttribute("aria-label", "Match all values");
          matchAllInput.addEventListener("change", (event) => {
            filter.match_all = event.target.checked;
          });
          matchAllLabel.appendChild(matchAllInput);
          matchAllLabel.appendChild(document.createTextNode("Match All"));
          flagsWrapper.appendChild(matchAllLabel);

          const wildcardLabel = document.createElement("label");
          wildcardLabel.className = "filter-flag";
          const wildcardInput = document.createElement("input");
          wildcardInput.type = "checkbox";
          wildcardInput.checked = !!filter.wildcard;
          wildcardInput.setAttribute(
            "aria-label",
            "Wildcard (ignore other filters)"
          );
          wildcardInput.addEventListener("change", (event) => {
            filter.wildcard = event.target.checked;
          });
          wildcardLabel.appendChild(wildcardInput);
          wildcardLabel.appendChild(document.createTextNode("🔥"));
          flagsWrapper.appendChild(wildcardLabel);

          valueWrapper.appendChild(valueInput);

          const shouldShowRemoveButton =
            filters.length > 1 || !isFilterEmpty(filter);

          if (shouldShowRemoveButton) {
            const removeBtn = document.createElement("button");
            removeBtn.type = "button";
            removeBtn.className = "icon-only danger remove-control";
            removeBtn.textContent = "✕";
            removeBtn.title = "Remove filter";
            removeBtn.addEventListener("click", () => onRemove(index));
            flagsWrapper.appendChild(removeBtn);
          }

          row.appendChild(fieldSelect);
          row.appendChild(operatorSelect);
          row.appendChild(valueWrapper);
          row.appendChild(flagsWrapper);

          containerEl.appendChild(row);
        });
      }

      function createEmptyBoostCondition() {
        return {
          field: "",
          operator: "equals",
          value: "",
          match_all: true,
        };
      }

      function createEmptyBoostRule() {
        return {
          conditions: [createEmptyBoostCondition()],
          boost: undefined,
        };
      }

      function isBoostConditionEmpty(condition) {
        if (!condition || typeof condition !== "object") {
          return true;
        }

        const hasField =
          typeof condition.field === "string" && condition.field.trim() !== "";
        const hasValue =
          condition.value !== undefined &&
          condition.value !== null &&
          String(condition.value).trim() !== "";
        const hasNonDefaultOperator =
          typeof condition.operator === "string" &&
          condition.operator.trim() !== "" &&
          condition.operator.trim() !== "equals";
        const hasMatchAllOverride = condition.match_all === false;

        return !(
          hasField ||
          hasValue ||
          hasNonDefaultOperator ||
          hasMatchAllOverride
        );
      }

      function isFilterEmpty(filter) {
        if (!filter || typeof filter !== "object") {
          return true;
        }

        const hasField =
          typeof filter.field === "string" && filter.field.trim() !== "";
        const hasValue =
          filter.value !== undefined &&
          filter.value !== null &&
          String(filter.value).trim() !== "";
        const hasNonDefaultOperator =
          typeof filter.operator === "string" &&
          filter.operator.trim() !== "" &&
          filter.operator.trim() !== "equals";
        const hasWildcard = !!filter.wildcard;
        const hasMatchAllOverride = filter.match_all === false;

        return !(
          hasField ||
          hasValue ||
          hasNonDefaultOperator ||
          hasWildcard ||
          hasMatchAllOverride
        );
      }

      function isBoostRuleEmpty(boost) {
        if (!boost || typeof boost !== "object") {
          return true;
        }

        const hasMultiplier =
          boost.boost !== undefined &&
          boost.boost !== null &&
          String(boost.boost).trim() !== "";

        const conditions = Array.isArray(boost.conditions)
          ? boost.conditions
          : [];
        const hasNonEmptyCondition = conditions.length
          ? conditions.some((condition) => !isBoostConditionEmpty(condition))
          : !isBoostConditionEmpty(boost);

        return !(hasMultiplier || hasNonEmptyCondition);
      }

      function normalizeBoostConditionForClient(condition) {
        if (!condition || typeof condition !== "object") {
          return createEmptyBoostCondition();
        }

        const normalized = createEmptyBoostCondition();
        if (typeof condition.field === "string") {
          normalized.field = condition.field;
        }
        if (typeof condition.operator === "string" && condition.operator.trim()) {
          normalized.operator = condition.operator;
        }

        if (condition.value === null || condition.value === undefined) {
          normalized.value = "";
        } else if (Array.isArray(condition.value)) {
          normalized.value = condition.value.map((item) => String(item)).join(", ");
        } else {
          normalized.value = String(condition.value);
        }

        if (condition.match_all !== undefined) {
          normalized.match_all = !!condition.match_all;
        }

        return normalized;
      }

      function normalizeBoostForClient(boost) {
        const normalized = {
          boost: normalizePopularityBoostMultiplier(
            boost?.boost !== undefined ? boost.boost : 1.0
          ),
        };

        const rawConditions = Array.isArray(boost?.conditions)
          ? boost.conditions
          : [boost];

        const conditions = rawConditions
          .map((condition) => normalizeBoostConditionForClient(condition))
          .filter((condition, index) => {
            if (index === 0) {
              return true;
            }
            return Boolean(
              (condition.field && condition.field.trim()) ||
                (condition.value && String(condition.value).trim())
            );
          });

        normalized.conditions =
          conditions.length > 0 ? conditions : [createEmptyBoostCondition()];

        return normalized;
      }

      function renderPopularityBoosts(containerEl, boosts, onRemove) {
        containerEl.innerHTML = "";

        if (!Array.isArray(boosts) || boosts.length === 0) {
          const emptyState = document.createElement("p");
          emptyState.className = "no-filters";
          emptyState.textContent = "No boost rules configured.";
          containerEl.appendChild(emptyState);
          return;
        }

        boosts.forEach((boost, index) => {
          if (!Array.isArray(boost.conditions) || boost.conditions.length === 0) {
            boost.conditions = [createEmptyBoostCondition()];
          }

          const row = document.createElement("div");
          row.className = "boost-row";

          const conditionsContainer = document.createElement("div");
          conditionsContainer.className = "boost-conditions";

          function renderConditions() {
            conditionsContainer.innerHTML = "";

            boost.conditions.forEach((condition, conditionIndex) => {
              const current = normalizeBoostConditionForClient(condition);
              boost.conditions[conditionIndex] = current;

              const conditionRow = document.createElement("div");
              conditionRow.className = "boost-condition";

              const fieldSelect = document.createElement("select");
              createOptionElements(fieldSelect, options.fields, current.field || "");
              fieldSelect.value = current.field || "";
              fieldSelect.addEventListener("change", (event) => {
                current.field = event.target.value;
              });
              conditionRow.appendChild(fieldSelect);

              const operatorSelect = document.createElement("select");
              createOptionElements(
                operatorSelect,
                options.operators,
                current.operator || "equals"
              );
              operatorSelect.value = current.operator || "equals";
              operatorSelect.addEventListener("change", (event) => {
                current.operator = event.target.value;
              });
              conditionRow.appendChild(operatorSelect);

              const valueWrapper = document.createElement("div");
              valueWrapper.className = "value-input";
              const valueInput = document.createElement("input");
              valueInput.type = "text";
              valueInput.placeholder = "Value (comma separated for multiple)";
              valueInput.value = current.value || "";
              valueInput.addEventListener("input", (event) => {
                current.value = event.target.value;
              });
              valueWrapper.appendChild(valueInput);
              conditionRow.appendChild(valueWrapper);

              const flagsWrapper = document.createElement("div");
              flagsWrapper.className = "filter-flags";
              const matchAllLabel = document.createElement("label");
              matchAllLabel.className = "filter-flag";
              const matchAllInput = document.createElement("input");
              matchAllInput.type = "checkbox";
              const normalizedMatchAll =
                current.match_all !== undefined ? !!current.match_all : true;
              matchAllInput.checked = normalizedMatchAll;
              matchAllInput.setAttribute(
                "aria-label",
                "Require a track to match every listed value"
              );
              current.match_all = normalizedMatchAll;
              matchAllInput.addEventListener("change", (event) => {
                current.match_all = event.target.checked;
              });
              matchAllLabel.appendChild(matchAllInput);
              matchAllLabel.appendChild(document.createTextNode("Match All"));
              flagsWrapper.appendChild(matchAllLabel);
              conditionRow.appendChild(flagsWrapper);

              const removeConditionBtn = document.createElement("button");
              removeConditionBtn.type = "button";
              removeConditionBtn.className = "icon-only danger remove-control";
              removeConditionBtn.textContent = "✕";
              removeConditionBtn.title = "Remove condition";
              removeConditionBtn.addEventListener("click", () => {
                if (boost.conditions.length > 1) {
                  boost.conditions.splice(conditionIndex, 1);
                  renderConditions();
                  return;
                }

                if (typeof onRemove === "function") {
                  onRemove(index);
                  return;
                }

                boost.conditions[0] = createEmptyBoostCondition();
                renderConditions();
              });
              flagsWrapper.appendChild(removeConditionBtn);

              conditionsContainer.appendChild(conditionRow);
            });
          }

          renderConditions();

          row.appendChild(conditionsContainer);

          const addConditionBtn = document.createElement("button");
          addConditionBtn.type = "button";
          addConditionBtn.className = "secondary";
          addConditionBtn.textContent = "Add Condition";
          addConditionBtn.addEventListener("click", () => {
            boost.conditions.push(createEmptyBoostCondition());
            renderConditions();
          });

          row.appendChild(addConditionBtn);

          const footer = document.createElement("div");
          footer.className = "boost-row-footer";

          const boostWrapper = document.createElement("div");
          boostWrapper.className = "boost-input";
          const boostInput = document.createElement("input");
          boostInput.type = "number";
          boostInput.min = "0";
          boostInput.step = "0.1";
          boostInput.placeholder = "Multiplier";
          const hasExistingMultiplier =
            boost.boost !== undefined && boost.boost !== null && boost.boost !== "";
          if (hasExistingMultiplier) {
            const normalized = normalizePopularityBoostMultiplier(boost.boost);
            boost.boost = normalized;
            boostInput.value = String(normalized);
          } else {
            boost.boost = undefined;
          }
          boostInput.addEventListener("input", (event) => {
            const { value } = event.target;
            const parsed = Number.parseFloat(value);
            if (Number.isFinite(parsed) && parsed >= 0) {
              boost.boost = parsed;
            } else if (value.trim() === "") {
              boost.boost = undefined;
            }
          });
          boostInput.addEventListener("blur", (event) => {
            const { value } = event.target;
            const trimmed = value.trim();
            if (trimmed === "") {
              boost.boost = undefined;
              event.target.value = "";
              return;
            }
            const parsed = Number.parseFloat(value);
            if (!Number.isFinite(parsed) || parsed < 0) {
              const normalized = normalizePopularityBoostMultiplier(value);
              boost.boost = normalized;
              event.target.value = String(normalized);
            } else {
              boost.boost = parsed;
              event.target.value = String(parsed);
            }
          });
          boostWrapper.appendChild(boostInput);
          footer.appendChild(boostWrapper);

          row.appendChild(footer);

          containerEl.appendChild(row);
        });
      }

      function updatePlaylistCollapseUi(playlist) {
        if (!playlist || typeof playlist !== "object") {
          return;
        }

        const elements = playlist._collapseElements || {};
        const { card, toggleButton } = elements;
        const isCollapsed = !!playlist._collapsed;
        const label = isCollapsed
          ? "Expand playlist details"
          : "Collapse playlist details";

        if (card) {
          card.classList.toggle("is-collapsed", isCollapsed);
        }

        if (toggleButton) {
          toggleButton.textContent = isCollapsed ? "▸" : "▾";
          toggleButton.setAttribute("aria-expanded", isCollapsed ? "false" : "true");
          toggleButton.setAttribute("aria-label", label);
          toggleButton.title = label;
        }
      }

      function openDefaultsPopover() {
        if (!defaultsPopover || isDefaultsPopoverOpen) {
          return;
        }

        defaultsLastFocused = document.activeElement;
        defaultsPopover.classList.add("show");
        defaultsPopover.removeAttribute("hidden");
        defaultsPopover.setAttribute("aria-hidden", "false");
        isDefaultsPopoverOpen = true;

        if (defaultsBtn) {
          defaultsBtn.setAttribute("aria-expanded", "true");
        }

        const focusTarget =
          defaultsPopover.querySelector("[data-defaults-initial-focus]") ||
          defaultsPopover.querySelector("button, [href], input, select, textarea") ||
          defaultsPopover;
        if (focusTarget && typeof focusTarget.focus === "function") {
          focusTarget.focus();
        }

        document.addEventListener("mousedown", handleDefaultsOutsideInteraction);
        document.addEventListener("focusin", handleDefaultsOutsideInteraction);
      }

      function closeDefaultsPopover({ skipFocusRestore } = {}) {
        if (!defaultsPopover || !isDefaultsPopoverOpen) {
          return;
        }

        defaultsPopover.classList.remove("show");
        defaultsPopover.setAttribute("aria-hidden", "true");
        defaultsPopover.setAttribute("hidden", "");
        isDefaultsPopoverOpen = false;

        if (defaultsBtn) {
          defaultsBtn.setAttribute("aria-expanded", "false");
        }

        document.removeEventListener("mousedown", handleDefaultsOutsideInteraction);
        document.removeEventListener("focusin", handleDefaultsOutsideInteraction);

        if (!skipFocusRestore && defaultsLastFocused) {
          try {
            if (typeof defaultsLastFocused.focus === "function") {
              defaultsLastFocused.focus();
            }
          } catch (error) {
            // Ignore focus restoration failures.
          }
        }
        defaultsLastFocused = null;
      }

      function toggleDefaultsPopover() {
        if (isDefaultsPopoverOpen) {
          closeDefaultsPopover();
        } else {
          openDefaultsPopover();
        }
      }

      function handleDefaultsOutsideInteraction(event) {
        if (!defaultsPopover || !isDefaultsPopoverOpen) {
          return;
        }

        const isInsidePopover = defaultsPopover.contains(event.target);
        const isToggleButton =
          event.target === defaultsBtn || defaultsBtn?.contains(event.target);

        if (!isInsidePopover && !isToggleButton) {
          closeDefaultsPopover({ skipFocusRestore: true });
        }
      }

      function scrollPlaylistIntoView(playlist) {
        if (!playlist) {
          return;
        }

        const schedule =
          (typeof window !== "undefined" && window.requestAnimationFrame) ||
          ((callback) => setTimeout(callback, 16));

        schedule(() => {
          const card = playlist._collapseElements?.card;
          if (card && typeof card.scrollIntoView === "function") {
            card.scrollIntoView({ behavior: "smooth", block: "start" });
          }
        });
      }

      function normalizePlaylistSource(value) {
        const normalized = String(value || "").toLowerCase();
        if (normalized === "spotify") {
          return normalized;
        }
        return "plex";
      }

      function sanitizeSpotifyUrl(value) {
        if (value === undefined || value === null) {
          return "";
        }
        return String(value).trim();
      }


      function normalizePopularityBoostMultiplier(value) {
        const parsed = Number.parseFloat(value);
        if (!Number.isFinite(parsed) || parsed < 0) {
          return 1.0;
        }
        return parsed;
      }

      function createPlaylistDuplicate(sourcePlaylist) {
        const duplicate = {};

        if (sourcePlaylist && typeof sourcePlaylist === "object") {
          Object.entries(sourcePlaylist).forEach(([key, value]) => {
            if (
              key === "name" ||
              key === "_originalName" ||
              key === "_statusElements" ||
              key === "_collapseElements"
            ) {
              return;
            }

            if (key === "plex_filter") {
              if (Array.isArray(value)) {
                duplicate.plex_filter = value.map((filter) => {
                  const clonedFilter = { ...filter };
                  if (Array.isArray(filter?.value)) {
                    clonedFilter.value = [...filter.value];
                  } else if (
                    filter &&
                    typeof filter.value === "object" &&
                    filter.value !== null
                  ) {
                    clonedFilter.value = JSON.parse(JSON.stringify(filter.value));
                  }
                  return clonedFilter;
                });
              }
              return;
            }

            if (key === "popularity_boosts") {
              if (Array.isArray(value)) {
                duplicate.popularity_boosts = value.map((boost) => {
                  const clonedBoost = { ...boost };
                  if (Array.isArray(boost?.conditions)) {
                    clonedBoost.conditions = boost.conditions.map((condition) => ({
                      ...condition,
                    }));
                  }
                  return clonedBoost;
                });
              }
              return;
            }

            if (key === "extras") {
              if (value && typeof value === "object") {
                duplicate.extras = JSON.parse(JSON.stringify(value));
              }
              return;
            }

            if (typeof value === "object" && value !== null) {
              try {
                duplicate[key] = JSON.parse(JSON.stringify(value));
              } catch (error) {
                duplicate[key] = value;
              }
            } else {
              duplicate[key] = value;
            }
          });
        }

        duplicate.name = "New Playlist";
        duplicate._originalName = "";
        duplicate.limit = duplicate.limit ?? 0;
        duplicate.artist_limit = duplicate.artist_limit ?? 0;
        duplicate.album_limit = duplicate.album_limit ?? 0;
        duplicate.year_limit = duplicate.year_limit ?? 0;
        duplicate.sort_by = duplicate.sort_by || "";
        if (!Array.isArray(duplicate.plex_filter)) {
          duplicate.plex_filter = [];
        }
        if (!Array.isArray(duplicate.popularity_boosts)) {
          duplicate.popularity_boosts = [];
        }
        if (!duplicate.extras || typeof duplicate.extras !== "object") {
          duplicate.extras = {};
        }

        duplicate._collapsed = false;

        return duplicate;
      }


      function playlistMatchesSearch(playlist, normalizedTerm) {
        if (!normalizedTerm) {
          return true;
        }

        if (!playlist || typeof playlist !== "object") {
          return false;
        }

        const haystacks = [];
        const collect = (value) => {
          if (typeof value !== "string") {
            return;
          }
          const trimmed = value.trim();
          if (trimmed) {
            haystacks.push(trimmed.toLowerCase());
          }
        };

        collect(playlist.name);
        collect(playlist._originalName);
        collect(playlist.summary);
        collect(playlist.description);

        if (playlist.extras && typeof playlist.extras === "object") {
          Object.values(playlist.extras).forEach((value) => {
            if (value === undefined || value === null) {
              return;
            }
            collect(String(value));
          });
        }

        if (Array.isArray(playlist.plex_filter)) {
          playlist.plex_filter.forEach((filter) => {
            if (!filter || typeof filter !== "object") {
              return;
            }
            collect(filter.field);
            collect(filter.operator);
            if (filter.value !== undefined && filter.value !== null) {
              if (Array.isArray(filter.value)) {
                collect(filter.value.join(", "));
              } else {
                collect(String(filter.value));
              }
            }
          });
        }

        if (Array.isArray(playlist.popularity_boosts)) {
          playlist.popularity_boosts.forEach((boost) => {
            if (!boost || typeof boost !== "object") {
              return;
            }
            collect(boost.name);
            if (Array.isArray(boost.conditions)) {
              boost.conditions.forEach((condition) => {
                if (!condition || typeof condition !== "object") {
                  return;
                }
                collect(condition.field);
                collect(condition.operator);
                if (condition.value !== undefined && condition.value !== null) {
                  collect(String(condition.value));
                }
              });
            }
          });
        }

        return haystacks.some((text) => text.includes(normalizedTerm));
      }

      function getLimitFieldForType(typeKey) {
        switch (typeKey) {
          case "artist":
            return "artist_limit";
          case "album":
            return "album_limit";
          case "year":
            return "year_limit";
          default:
            return "";
        }
      }

      function ensureLimitSelections(playlist) {
        if (!playlist || typeof playlist !== "object") {
          return [];
        }
        if (!Array.isArray(playlist._limitSelections)) {
          playlist._limitSelections = [];
        }
        return playlist._limitSelections;
      }

      function addLimitSelection(playlist, typeKey) {
        if (!typeKey) {
          return;
        }
        const selections = ensureLimitSelections(playlist);
        if (!selections.includes(typeKey)) {
          selections.push(typeKey);
        }
      }

      function removeLimitSelection(playlist, typeKey) {
        const selections = ensureLimitSelections(playlist);
        const index = selections.indexOf(typeKey);
        if (index >= 0) {
          selections.splice(index, 1);
        }
      }

      function getPlaylistLimitRaw(playlist, typeKey) {
        if (!playlist || !typeKey) {
          return 0;
        }
        const field = getLimitFieldForType(typeKey);
        if (!field) {
          return 0;
        }
        const value = playlist[field];
        return value === undefined || value === null ? 0 : value;
      }

      function setPlaylistLimitValue(playlist, typeKey, value) {
        if (!playlist || !typeKey) {
          return;
        }
        const field = getLimitFieldForType(typeKey);
        if (!field) {
          return;
        }
        playlist[field] = value;
      }

      function normalizeLimitNumber(value) {
        if (value === null || value === undefined || value === "") {
          return 0;
        }
        const numeric = Number.parseInt(value, 10);
        return Number.isFinite(numeric) && numeric >= 0 ? numeric : 0;
      }

      function updateLimitDisplayForPlaylist(
        playlist,
        controlEl,
        valueEl,
        summaryEl
      ) {
        if (valueEl) {
          const normalizedLimit = normalizeLimitNumber(playlist?.limit);
          valueEl.textContent = normalizedLimit;
        }

        if (summaryEl && controlEl) {
          const summaryParts = [];
          LIMIT_TYPE_OPTIONS.forEach((option) => {
            const normalized = normalizeLimitNumber(playlist?.[option.field]);
            if (normalized > 0) {
              summaryParts.push(`${option.label}: ${normalized}`);
            }
          });
          const summaryText = summaryParts.join(" • ");
          summaryEl.textContent = summaryText;
          controlEl.classList.toggle("has-summary", Boolean(summaryText));
        }
      }

      function ensureLimitMenuElements() {
        if (!limitMenuState.backdrop) {
          const backdrop = document.createElement("div");
          backdrop.className = "limit-menu-backdrop";
          backdrop.addEventListener("click", () => {
            closeLimitMenu();
          });
          document.body.appendChild(backdrop);
          limitMenuState.backdrop = backdrop;
        }

        if (!limitMenuState.container) {
          const menu = document.createElement("div");
          menu.className = "limit-menu";
          menu.setAttribute("role", "dialog");
          menu.setAttribute("aria-modal", "true");
          menu.setAttribute("aria-hidden", "true");
          menu.tabIndex = -1;
          document.body.appendChild(menu);
          limitMenuState.container = menu;
        }
      }

      function handleLimitMenuKeydown(event) {
        if (event.key === "Escape") {
          closeLimitMenu();
        }
      }

      function positionLimitMenu() {
        const { container, anchor } = limitMenuState;
        if (!container || !anchor) {
          return;
        }

        const anchorRect = anchor.getBoundingClientRect();
        const menuRect = container.getBoundingClientRect();
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        const viewportHeight =
          document.documentElement.clientHeight || window.innerHeight;

        let top = anchorRect.bottom + window.scrollY + 8;
        let left = anchorRect.left + window.scrollX;

        const maxLeft =
          window.scrollX + viewportWidth - menuRect.width - 16;
        if (left > maxLeft) {
          left = Math.max(window.scrollX + 16, maxLeft);
        } else {
          left = Math.max(window.scrollX + 16, left);
        }

        const maxTop = window.scrollY + viewportHeight - menuRect.height - 16;
        if (top > maxTop) {
          top = anchorRect.top + window.scrollY - menuRect.height - 8;
        }
        if (top < window.scrollY + 16) {
          top = window.scrollY + 16;
        }

        container.style.left = `${left}px`;
        container.style.top = `${top}px`;
      }

      function closeLimitMenu() {
        const { container, backdrop } = limitMenuState;
        if (!container || container.getAttribute("aria-hidden") === "true") {
          return;
        }

        const toggleButton = limitMenuState.toggleButton;
        const shouldRestoreFocus =
          toggleButton && document.body.contains(toggleButton);

        container.classList.remove("show");
        container.setAttribute("aria-hidden", "true");
        container.style.display = "none";
        container.style.visibility = "";
        container.innerHTML = "";

        if (backdrop) {
          backdrop.style.display = "none";
        }

        document.removeEventListener("keydown", handleLimitMenuKeydown, true);
        if (limitMenuState.repositionHandler) {
          window.removeEventListener("resize", limitMenuState.repositionHandler);
          window.removeEventListener("scroll", limitMenuState.repositionHandler, true);
        }

        limitMenuState.playlist = null;
        limitMenuState.anchor = null;
        limitMenuState.updateDisplay = null;
        limitMenuState.repositionHandler = null;

        if (toggleButton) {
          toggleButton.setAttribute("aria-expanded", "false");
        }

        limitMenuState.toggleButton = null;

        if (shouldRestoreFocus && toggleButton) {
          toggleButton.focus({ preventScroll: true });
        }
      }

      function openLimitMenu(playlist, anchor, updateDisplay) {
        if (!playlist || !anchor) {
          return;
        }

        closeLimitMenu();
        ensureLimitMenuElements();

        const { container, backdrop } = limitMenuState;
        if (!container || !backdrop) {
          return;
        }

        limitMenuState.playlist = playlist;
        limitMenuState.anchor = anchor;
        limitMenuState.toggleButton = anchor;
        limitMenuState.updateDisplay =
          typeof updateDisplay === "function" ? updateDisplay : null;

        container.innerHTML = "";
        container.setAttribute("aria-hidden", "false");
        container.style.display = "flex";
        container.style.visibility = "hidden";
        container.classList.add("show");

        backdrop.style.display = "block";

        anchor.setAttribute("aria-expanded", "true");

        const header = document.createElement("div");
        header.className = "limit-menu-header";
        const title = document.createElement("h3");
        title.id = LIMIT_MENU_TITLE_ID;
        title.textContent = "Limits";
        header.appendChild(title);
        const closeBtn = document.createElement("button");
        closeBtn.type = "button";
        closeBtn.className = "icon-only secondary limit-remove";
        closeBtn.setAttribute("aria-label", "Close limit menu");
        closeBtn.textContent = "✕";
        closeBtn.addEventListener("click", () => {
          closeLimitMenu();
        });
        header.appendChild(closeBtn);
        container.appendChild(header);
        container.setAttribute("aria-labelledby", LIMIT_MENU_TITLE_ID);

        const rowsContainer = document.createElement("div");
        rowsContainer.className = "limit-menu-rows";
        container.appendChild(rowsContainer);

        const baseRow = document.createElement("div");
        baseRow.className = "limit-row-base";
        const baseLabel = document.createElement("label");
        baseLabel.textContent = "Limit";
        const baseInput = document.createElement("input");
        baseInput.type = "number";
        baseInput.min = "0";
        baseInput.value = playlist.limit ?? 0;
        baseInput.addEventListener("input", (event) => {
          playlist.limit = event.target.value;
          limitMenuState.updateDisplay?.();
        });
        baseLabel.appendChild(baseInput);
        baseRow.appendChild(baseLabel);
        rowsContainer.appendChild(baseRow);

        const limitRows = [];
        let addButton = null;

        const getUsedTypes = (excludedRow = null) => {
          const used = new Set();
          limitRows.forEach((row) => {
            if (row === excludedRow) {
              return;
            }
            if (row.type) {
              used.add(row.type);
            }
          });
          return used;
        };

        const refreshAddButton = () => {
          if (!addButton) {
            return;
          }
          const usedTypes = getUsedTypes();
          const shouldDisable = usedTypes.size >= LIMIT_TYPE_OPTIONS.length;
          addButton.disabled = shouldDisable;
          if (shouldDisable) {
            addButton.setAttribute("aria-disabled", "true");
          } else {
            addButton.removeAttribute("aria-disabled");
          }
        };

        const refreshSelectOptions = () => {
          limitRows.forEach((row) => {
            const usedByOthers = getUsedTypes(row);
            Array.from(row.select.options).forEach((optionEl) => {
              if (!optionEl.value) {
                optionEl.disabled = false;
                return;
              }
              optionEl.disabled = usedByOthers.has(optionEl.value);
            });
          });
          refreshAddButton();
        };

        const createExtraLimitRow = (initialType) => {
          const row = document.createElement("div");
          row.className = "limit-row-extra";

          const typeSelect = document.createElement("select");
          const placeholderOption = document.createElement("option");
          placeholderOption.value = "";
          placeholderOption.textContent = "Select type";
          typeSelect.appendChild(placeholderOption);
          LIMIT_TYPE_OPTIONS.forEach((option) => {
            const optionEl = document.createElement("option");
            optionEl.value = option.key;
            optionEl.textContent = `${option.label} Limit`;
            typeSelect.appendChild(optionEl);
          });

          const valueInput = document.createElement("input");
          valueInput.type = "number";
          valueInput.min = "0";
          valueInput.value = 0;
          valueInput.disabled = true;

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "icon-only secondary limit-remove";
          removeBtn.setAttribute("aria-label", "Remove limit");
          removeBtn.textContent = "✕";

          row.appendChild(typeSelect);
          row.appendChild(valueInput);
          row.appendChild(removeBtn);
          rowsContainer.appendChild(row);

          const rowState = {
            element: row,
            select: typeSelect,
            input: valueInput,
            removeBtn,
            type: "",
          };

          limitRows.push(rowState);

          const applyType = (newType) => {
            if (rowState.type === newType) {
              refreshSelectOptions();
              return;
            }

            if (rowState.type) {
              setPlaylistLimitValue(playlist, rowState.type, 0);
              removeLimitSelection(playlist, rowState.type);
            }

            rowState.type = newType;

            if (newType) {
              valueInput.disabled = false;
              const existingValue = getPlaylistLimitRaw(playlist, newType);
              valueInput.value = existingValue ?? 0;
              addLimitSelection(playlist, newType);
              setPlaylistLimitValue(playlist, newType, valueInput.value);
            } else {
              valueInput.disabled = true;
              valueInput.value = 0;
            }

            refreshSelectOptions();
            limitMenuState.updateDisplay?.();
          };

          typeSelect.addEventListener("change", () => {
            applyType(typeSelect.value);
          });

          valueInput.addEventListener("input", (event) => {
            if (!rowState.type) {
              return;
            }
            setPlaylistLimitValue(playlist, rowState.type, event.target.value);
            limitMenuState.updateDisplay?.();
          });

          removeBtn.addEventListener("click", () => {
            if (rowState.type) {
              setPlaylistLimitValue(playlist, rowState.type, 0);
              removeLimitSelection(playlist, rowState.type);
            }

            const index = limitRows.indexOf(rowState);
            if (index >= 0) {
              limitRows.splice(index, 1);
            }
            row.remove();
            refreshSelectOptions();
            limitMenuState.updateDisplay?.();
          });

          if (initialType) {
            typeSelect.value = initialType;
            applyType(initialType);
          } else {
            const availableType = LIMIT_TYPE_OPTIONS.find(
              (option) => !getUsedTypes().has(option.key)
            );
            if (availableType) {
              typeSelect.value = availableType.key;
              applyType(availableType.key);
            } else {
              applyType("");
            }
          }

          return rowState;
        };

        const initialTypes = Array.from(
          new Set([
            ...ensureLimitSelections(playlist),
            ...LIMIT_TYPE_OPTIONS.filter((option) =>
              normalizeLimitNumber(playlist?.[option.field]) > 0
            ).map((option) => option.key),
          ])
        );

        playlist._limitSelections = initialTypes.slice();

        initialTypes.forEach((typeKey) => {
          createExtraLimitRow(typeKey);
        });

        addButton = document.createElement("button");
        addButton.type = "button";
        addButton.className = "secondary limit-add";
        addButton.textContent = "＋ Add new limit";
        addButton.addEventListener("click", () => {
          const rowState = createExtraLimitRow("");
          if (rowState?.select) {
            rowState.select.focus({ preventScroll: true });
          }
        });

        const footer = document.createElement("div");
        footer.className = "limit-menu-footer";
        footer.appendChild(addButton);
        container.appendChild(footer);

        refreshSelectOptions();
        limitMenuState.updateDisplay?.();

        const repositionHandler = () => {
          positionLimitMenu();
        };
        limitMenuState.repositionHandler = repositionHandler;
        window.addEventListener("resize", repositionHandler);
        window.addEventListener("scroll", repositionHandler, true);
        document.addEventListener("keydown", handleLimitMenuKeydown, true);

        requestAnimationFrame(() => {
          positionLimitMenu();
          container.style.visibility = "visible";
          baseInput.focus({ preventScroll: true });
          baseInput.select();
        });
      }

      function renderPlaylists() {
        if (coverPickerOverlay?.classList.contains("show")) {
          closeCoverPicker();
        }
        closeLimitMenu();
        playlistsContainer.innerHTML = "";
        const totalPlaylists = state.playlists.length;
        const normalizedSearch = (playlistSearchTerm || "").trim().toLowerCase();
        const visiblePlaylists = !normalizedSearch
          ? state.playlists.slice()
          : state.playlists.filter((playlist) =>
              playlistMatchesSearch(playlist, normalizedSearch)
            );
        const hasVisiblePlaylists = visiblePlaylists.length > 0;

        if (expandAllPlaylistsBtn) {
          expandAllPlaylistsBtn.disabled = !hasVisiblePlaylists;
        }

        if (collapseAllPlaylistsBtn) {
          collapseAllPlaylistsBtn.disabled = !hasVisiblePlaylists;
        }

        if (!hasVisiblePlaylists) {
          const empty = document.createElement("p");
          empty.className = "no-filters";
          empty.textContent = totalPlaylists
            ? "No playlists match your search."
            : "No playlists yet. Add one to get started.";
          playlistsContainer.appendChild(empty);
          return;
        }

        visiblePlaylists.forEach((playlist) => {
          const playlistIndex = state.playlists.indexOf(playlist);

          if (typeof playlist._collapsed !== "boolean") {
            playlist._collapsed = false;
          }

          if (!Array.isArray(playlist.popularity_boosts)) {
            playlist.popularity_boosts = [];
          }
          if (typeof playlist._boostsOpen !== "boolean") {
            playlist._boostsOpen = false;
          }
          if (typeof playlist.after_sort !== "string") {
            playlist.after_sort = "";
          }

          const card = document.createElement("div");
          card.className = "card playlist-card";

          const header = document.createElement("div");
          header.className = "playlist-header";

          const titleWrapper = document.createElement("div");
          titleWrapper.className = "playlist-header-title";

          const toggleBtn = document.createElement("button");
          toggleBtn.type = "button";
          toggleBtn.className = "icon-only secondary playlist-collapse-btn";

          const title = document.createElement("h3");
          title.textContent = playlist.name || "Untitled Playlist";

          titleWrapper.appendChild(toggleBtn);
          titleWrapper.appendChild(title);

          const statusGroup = document.createElement("div");
          statusGroup.className = "playlist-status";

          const statusIndicator = document.createElement("span");
          statusIndicator.className = "status-indicator idle";

          const statusTextWrapper = document.createElement("div");
          statusTextWrapper.className = "playlist-status-text";

          const statusLine = document.createElement("div");
          statusLine.className = "playlist-status-line";
          statusLine.textContent = "Not built yet";

          const statusMessage = document.createElement("div");
          statusMessage.className = "playlist-status-message";

          statusTextWrapper.appendChild(statusLine);
          statusTextWrapper.appendChild(statusMessage);
          statusGroup.appendChild(statusIndicator);
          statusGroup.appendChild(statusTextWrapper);

          const buildBtn = document.createElement("button");
          buildBtn.type = "button";
          buildBtn.className = "playlist-build-btn icon-only";
          buildBtn.textContent = "▶";
          buildBtn.setAttribute("aria-label", "Build this playlist");
          buildBtn.title = "Build this playlist.";
          buildBtn.addEventListener("click", () => togglePlaylistBuild(playlist));

          const saveBtn = document.createElement("button");
          saveBtn.type = "button";
          saveBtn.className = "icon-only";
          saveBtn.textContent = "💾";
          saveBtn.setAttribute("aria-label", "Save playlist");
          saveBtn.title = "Save this playlist to playlists.yml";

          const duplicateBtn = document.createElement("button");
          duplicateBtn.type = "button";
          duplicateBtn.className = "icon-only secondary";
          duplicateBtn.textContent = "⧉";
          duplicateBtn.setAttribute("aria-label", "Duplicate playlist");
          duplicateBtn.title = "Duplicate playlist";
          duplicateBtn.addEventListener("click", () => {
            const duplicate = createPlaylistDuplicate(playlist);
            const insertIndex = playlistIndex >= 0 ? playlistIndex + 1 : state.playlists.length;
            state.playlists.splice(insertIndex, 0, duplicate);
            renderPlaylists();
            scrollPlaylistIntoView(duplicate);
          });

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "icon-only danger";
          removeBtn.textContent = "✕";
          removeBtn.setAttribute("aria-label", "Delete playlist");
          removeBtn.title = "Delete playlist";
          removeBtn.addEventListener("click", () => {
            const playlistName = (playlist.name || "").trim();
            const confirmationMessage = playlistName
              ? `Are you sure you want to delete "${playlistName}"?\nThis action cannot be undone.`
              : `Are you sure you want to delete this playlist?\nThis action cannot be undone.`;
            if (!confirm(confirmationMessage)) {
              return;
            }

            delete playlist._statusElements;
            delete playlist._collapseElements;
            if (playlistIndex >= 0) {
              state.playlists.splice(playlistIndex, 1);
            }
            renderPlaylists();
          });

          header.appendChild(titleWrapper);
          header.appendChild(statusGroup);
          const actionButtons = document.createElement("div");
          actionButtons.className = "playlist-action-buttons";
          actionButtons.appendChild(buildBtn);
          actionButtons.appendChild(saveBtn);
          actionButtons.appendChild(duplicateBtn);
          actionButtons.appendChild(removeBtn);
          header.appendChild(actionButtons);
          const inlineMessage = document.createElement("div");
          inlineMessage.className = "playlist-inline-message";
          header.appendChild(inlineMessage);
          card.appendChild(header);

          const details = document.createElement("div");
          details.className = "playlist-details";
          card.appendChild(details);

          const extras = ensureExtras(playlist);

          const grid = document.createElement("div");
          grid.className = "input-grid";

          const nameLabel = document.createElement("label");
          nameLabel.textContent = "Playlist Name";
          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.value = playlist.name || "";
          nameInput.addEventListener("input", (event) => {
            playlist.name = event.target.value;
            title.textContent = event.target.value || "Untitled Playlist";
            updatePlaylistBuildUi(playlist);
          });
          nameLabel.appendChild(nameInput);

          playlist._statusElements = {
            indicator: statusIndicator,
            line: statusLine,
            message: statusMessage,
            button: buildBtn,
            headerTitle: title,
            nameInput,
            inlineMessage,
          };
          playlist._inlineMessageEl = inlineMessage;
          updatePlaylistBuildUi(playlist);

          saveBtn.addEventListener("click", () =>
            savePlaylist(playlist, saveBtn, title, nameInput)
          );

          let updateSourceUi;

          const sourceLabel = document.createElement("label");
          sourceLabel.textContent = "Source";
          const sourceSelect = document.createElement("select");
          [
            { value: "plex", label: "Plex" },
            { value: "spotify", label: "Spotify" },
          ].forEach((optionData) => {
            const option = document.createElement("option");
            option.value = optionData.value;
            option.textContent = optionData.label;
            sourceSelect.appendChild(option);
          });
          sourceSelect.value = playlist.source;
          sourceSelect.addEventListener("change", (event) => {
            playlist.source = normalizePlaylistSource(event.target.value);
            if (typeof updateSourceUi === "function") {
              updateSourceUi();
            }
          });
          sourceLabel.appendChild(sourceSelect);

          const spotifyUrlLabel = document.createElement("label");
          spotifyUrlLabel.textContent = "Spotify Playlist URL";
          const spotifyUrlInput = document.createElement("input");
          spotifyUrlInput.type = "url";
          spotifyUrlInput.placeholder = "https://open.spotify.com/playlist/...";
          spotifyUrlInput.value = playlist.spotify_url || "";
          spotifyUrlInput.addEventListener("input", (event) => {
            playlist.spotify_url = sanitizeSpotifyUrl(event.target.value);
          });
          spotifyUrlLabel.appendChild(spotifyUrlInput);

          if (playlist.artist_limit === undefined) {
            playlist.artist_limit = 0;
          }
          if (playlist.album_limit === undefined) {
            playlist.album_limit = 0;
          }
          if (playlist.year_limit === undefined) {
            playlist.year_limit = 0;
          }
          if (!Array.isArray(playlist._limitSelections)) {
            playlist._limitSelections = [];
          }

          const limitControl = document.createElement("div");
          limitControl.className = "limit-control";
          const limitButton = document.createElement("button");
          limitButton.type = "button";
          limitButton.className = "limit-button";
          limitButton.setAttribute("aria-haspopup", "dialog");
          limitButton.setAttribute("aria-expanded", "false");
          const limitButtonLabel = document.createElement("span");
          limitButtonLabel.textContent = "Limit";
          const limitButtonValue = document.createElement("span");
          limitButtonValue.className = "limit-button-value";
          limitButton.appendChild(limitButtonLabel);
          limitButton.appendChild(limitButtonValue);
          limitControl.appendChild(limitButton);
          const limitSummary = document.createElement("div");
          limitSummary.className = "limit-summary";
          limitControl.appendChild(limitSummary);

          const syncLimitDisplay = () => {
            updateLimitDisplayForPlaylist(
              playlist,
              limitControl,
              limitButtonValue,
              limitSummary
            );
          };

          limitButton.addEventListener("click", () => {
            const menuOpen =
              limitMenuState.toggleButton === limitButton &&
              limitMenuState.container &&
              limitMenuState.container.getAttribute("aria-hidden") === "false";
            if (menuOpen) {
              closeLimitMenu();
            } else {
              openLimitMenu(playlist, limitButton, syncLimitDisplay);
            }
          });

          syncLimitDisplay();

          const sortLabel = document.createElement("label");
          sortLabel.textContent = "Sort By";
          const sortSelect = document.createElement("select");
          const sortFieldValues = options.sort_fields.map((opt) => opt.value);
          if (
            (!playlist.sort_by || !sortFieldValues.includes(playlist.sort_by)) &&
            options.sort_fields.length
          ) {
            playlist.sort_by = options.sort_fields[0].value;
          }
          const allowedAfterSortValues = new Set(sortFieldValues);
          allowedAfterSortValues.add("");
          if (!allowedAfterSortValues.has(playlist.after_sort)) {
            playlist.after_sort = "";
          }
          options.sort_fields.forEach((opt) => {
            const option = document.createElement("option");
            option.value = opt.value;
            option.textContent = opt.label;
            sortSelect.appendChild(option);
          });
          sortSelect.value = playlist.sort_by || "";
          sortSelect.addEventListener("change", (event) => {
            playlist.sort_by = event.target.value;
          });
          sortLabel.appendChild(sortSelect);

          const afterSortLabel = document.createElement("label");
          afterSortLabel.textContent = "After Sort";
          const afterSortSelect = document.createElement("select");
          const afterSortOptions = [{ value: "", label: "None" }, ...options.sort_fields];
          afterSortOptions.forEach((opt) => {
            const option = document.createElement("option");
            option.value = opt.value;
            option.textContent = opt.label;
            afterSortSelect.appendChild(option);
          });
          afterSortSelect.value = playlist.after_sort || "";
          afterSortSelect.addEventListener("change", (event) => {
            playlist.after_sort = event.target.value;
          });
          afterSortLabel.appendChild(afterSortSelect);

          const coverField = document.createElement("div");
          coverField.className = "cover-field";
          const coverInputId = `coverInput-${Math.random()
            .toString(36)
            .slice(2, 10)}`;
          const coverLabel = document.createElement("label");
          coverLabel.className = "cover-field-label";
          coverLabel.textContent = "Cover Image";
          coverField.appendChild(coverLabel);

          const coverPreviewContainer = document.createElement("button");
          coverPreviewContainer.type = "button";
          coverPreviewContainer.className = "cover-preview";
          coverPreviewContainer.setAttribute(
            "aria-label",
            "Choose a cover image"
          );
          const coverPreviewFrame = document.createElement("div");
          coverPreviewFrame.className = "cover-preview-frame";
          const coverPreviewImage = document.createElement("img");
          coverPreviewImage.alt = "Cover preview";
          coverPreviewImage.draggable = false;
          const coverPreviewPlaceholder = document.createElement("div");
          coverPreviewPlaceholder.className = "cover-preview-placeholder";
          coverPreviewPlaceholder.textContent = "Select a cover";
          coverPreviewFrame.appendChild(coverPreviewImage);
          coverPreviewFrame.appendChild(coverPreviewPlaceholder);
          const coverPreviewCaption = document.createElement("div");
          coverPreviewCaption.className = "cover-preview-caption";
          coverPreviewCaption.classList.add("visually-hidden");
          coverPreviewContainer.appendChild(coverPreviewFrame);
          coverPreviewContainer.appendChild(coverPreviewCaption);
          coverField.appendChild(coverPreviewContainer);

          const coverInput = document.createElement("input");
          coverInput.type = "hidden";
          coverInput.id = coverInputId;
          coverInput.value = extras.cover || "";
          coverInput.addEventListener("input", (event) => {
            const value = event.target.value || "";
            extras.cover = value;
            updateImagePreview(
              coverPreviewContainer,
              coverPreviewImage,
              coverPreviewCaption,
              value,
              CARD_COVER_PREVIEW_TEXTS
            );
          });
          coverField.appendChild(coverInput);
          coverPreviewContainer.addEventListener("click", () => {
            openCoverPicker(playlist, coverInput, "cover", {
              container: coverPreviewContainer,
              image: coverPreviewImage,
              label: coverPreviewCaption,
            });
          });

          updateImagePreview(
            coverPreviewContainer,
            coverPreviewImage,
            coverPreviewCaption,
            extras.cover || "",
            CARD_COVER_PREVIEW_TEXTS
          );

          grid.appendChild(nameLabel);
          grid.appendChild(sourceLabel);
          grid.appendChild(spotifyUrlLabel);
          grid.appendChild(limitControl);
          grid.appendChild(sortLabel);
          grid.appendChild(coverField);
          grid.appendChild(afterSortLabel);

          details.appendChild(grid);

          const filtersWrapper = document.createElement("div");
          filtersWrapper.className = "filters-container";
          renderFilters(filtersWrapper, playlist.plex_filter, (filterIndex) => {
            playlist.plex_filter.splice(filterIndex, 1);
            renderPlaylists();
          });

          details.appendChild(filtersWrapper);

          const addFilterBtn = document.createElement("button");
          addFilterBtn.type = "button";
          addFilterBtn.className = "secondary";
          addFilterBtn.textContent = "＋ Add Filter";
          addFilterBtn.addEventListener("click", () => {
            playlist.plex_filter.push({
              field: "",
              operator: "equals",
              value: "",
              match_all: true,
              wildcard: false,
            });
            renderPlaylists();
          });

          details.appendChild(addFilterBtn);

          const boostsPopout = document.createElement("details");
          boostsPopout.className = "boosts-popout";
          if (playlist._boostsOpen) {
            boostsPopout.open = true;
          }

          const boostsSummary = document.createElement("summary");
          boostsSummary.textContent = "⚡ Popularity Boosts";
          boostsSummary.setAttribute(
            "aria-label",
            "Toggle popularity boost rules"
          );
          boostsPopout.appendChild(boostsSummary);

          const boostsPanel = document.createElement("div");
          boostsPanel.className = "boosts-panel";

          const boostsDescription = document.createElement("p");
          boostsDescription.textContent =
            "Boost multipliers adjust the popularity score of matching tracks. Uncheck Match All to treat comma-separated values as match-any.";
          boostsPanel.appendChild(boostsDescription);

          const boostsContainer = document.createElement("div");
          boostsContainer.className = "boosts-container";
          renderPopularityBoosts(
            boostsContainer,
            playlist.popularity_boosts,
            (boostIndex) => {
              playlist._boostsOpen = true;
              playlist.popularity_boosts.splice(boostIndex, 1);
              renderPlaylists();
            }
          );
          boostsPanel.appendChild(boostsContainer);

          const addBoostBtn = document.createElement("button");
          addBoostBtn.type = "button";
          addBoostBtn.className = "secondary";
          addBoostBtn.textContent = "＋ Add Boost Rule";
          addBoostBtn.addEventListener("click", () => {
            playlist.popularity_boosts.push(createEmptyBoostRule());
            playlist._boostsOpen = true;
            renderPlaylists();
          });
          boostsPanel.appendChild(addBoostBtn);

          boostsPopout.appendChild(boostsPanel);
          boostsPopout.addEventListener("toggle", () => {
            playlist._boostsOpen = boostsPopout.open;
          });

          details.appendChild(boostsPopout);

          updateSourceUi = () => {
            const source = normalizePlaylistSource(playlist.source);
            const usesPlex = source === "plex";
            filtersWrapper.style.display = usesPlex ? "" : "none";
            addFilterBtn.style.display = usesPlex ? "" : "none";
            boostsPopout.style.display = usesPlex ? "" : "none";
            spotifyUrlLabel.style.display = source === "spotify" ? "" : "none";
          };

          updateSourceUi();

          playlist._collapseElements = {
            card,
            toggleButton: toggleBtn,
          };
          updatePlaylistCollapseUi(playlist);

          toggleBtn.addEventListener("click", () => {
            playlist._collapsed = !playlist._collapsed;
            updatePlaylistCollapseUi(playlist);
          });


          playlistsContainer.appendChild(card);
        });
      }

      function renderDefaultFilters() {
        if (!Array.isArray(state.defaults.plex_filter)) {
          state.defaults.plex_filter = [];
        }

        if (defaultFiltersContainer) {
          renderFilters(
            defaultFiltersContainer,
            state.defaults.plex_filter,
            (index) => {
              state.defaults.plex_filter.splice(index, 1);
              renderDefaultFilters();
            }
          );
        }

        if (!Array.isArray(state.defaults.popularity_boosts)) {
          state.defaults.popularity_boosts = [];
        }

        if (defaultBoostsContainer) {
          renderPopularityBoosts(
            defaultBoostsContainer,
            state.defaults.popularity_boosts,
            (index) => {
              isDefaultBoostsOpen = true;
              state.defaults.popularity_boosts.splice(index, 1);
              renderDefaultFilters();
            }
          );
        }

        if (defaultBoostsPopout) {
          if (defaultBoostsPopout.open !== isDefaultBoostsOpen) {
            defaultBoostsPopout.open = isDefaultBoostsOpen;
          }
        }
      }

      function renderAll() {
        renderDefaultFilters();
        renderPlaylists();
      }

      async function loadData() {
        try {
          const response = await fetch("/api/playlists");
          if (!response.ok) {
            throw new Error("Unable to load playlists.");
          }
          const data = await response.json();
          options = data.options || options;

          state.defaults.plex_filter = (data.defaults?.plex_filter || []).map((filter) => ({
            field: filter.field || "",
            operator: filter.operator || "equals",
            value: filter.value || "",
            match_all: filter.match_all !== undefined ? filter.match_all : true,
            wildcard: filter.wildcard !== undefined ? !!filter.wildcard : false,
          }));
          state.defaults.extras = data.defaults?.extras || {};
          state.defaults.popularity_boosts = (
            data.defaults?.popularity_boosts || []
          ).map((boost) => normalizeBoostForClient(boost || {}));

          isDefaultBoostsOpen = state.defaults.popularity_boosts.length > 0;

          state.playlists = (data.playlists || []).map((playlist) => {
            const playlistName = playlist.name || "";
            const normalizedSource = normalizePlaylistSource(
              playlist.source || playlist.extras?.source
            );
            const spotifyUrl = sanitizeSpotifyUrl(
              playlist.spotify_url || playlist.extras?.spotify_url || ""
            );
            const extras = { ...(playlist.extras || {}) };
            delete extras.source;
            delete extras.spotify_url;

            const entry = {
              name: playlistName,
              limit: playlist.limit ?? 0,
              artist_limit: playlist.artist_limit ?? 0,
              album_limit: playlist.album_limit ?? 0,
              year_limit: playlist.year_limit ?? 0,
              sort_by: playlist.sort_by || "",
              after_sort: playlist.after_sort || "",
              plex_filter: (playlist.plex_filter || []).map((filter) => ({
                field: filter.field || "",
                operator: filter.operator || "equals",
                value: filter.value || "",
                match_all:
                  filter.match_all !== undefined ? filter.match_all : true,
                wildcard: filter.wildcard !== undefined ? !!filter.wildcard : false,
              })),
              popularity_boosts: (playlist.popularity_boosts || []).map((boost) =>
                normalizeBoostForClient(boost || {})
              ),
              extras,
              source: normalizedSource,
              spotify_url: normalizedSource === "spotify" ? spotifyUrl : "",
            };
            entry._originalName = playlistName;
            entry._collapsed = true;
            entry._boostsOpen = false;
            return entry;
          });

          renderAll();
        } catch (error) {
          console.error(error);
          showMessage(error.message, true);
        }
      }

      function prepareFiltersForSave(filters) {
        return filters.map((filter) => ({
          field: filter.field || "",
          operator: filter.operator || "equals",
          value: filter.value || "",
          match_all: filter.match_all !== undefined ? !!filter.match_all : true,
          wildcard: filter.wildcard !== undefined ? !!filter.wildcard : false,
        }));
      }

      function prepareBoostsForSave(boosts) {
        return (boosts || []).map((boost) => {
          const rawConditions = Array.isArray(boost?.conditions)
            ? boost.conditions
            : [boost];

          const preparedConditions = rawConditions
            .map((condition) => normalizeBoostConditionForClient(condition))
            .map((condition) => ({
              field: condition.field || "",
              operator: condition.operator || "equals",
              value: condition.value || "",
              match_all:
                condition.match_all !== undefined
                  ? !!condition.match_all
                  : true,
            }));

          const conditionsToSave =
            preparedConditions.length > 0
              ? preparedConditions
              : [createEmptyBoostCondition()];

          return {
            conditions: conditionsToSave,
            boost: normalizePopularityBoostMultiplier(
              boost?.boost !== undefined ? boost.boost : 1.0
            ),
          };
        });
      }

      async function saveData(options = {}) {
        if (options && typeof options.preventDefault === "function") {
          options.preventDefault();
          options = {};
        }

        if (!options || typeof options !== "object") {
          options = {};
        }

        const { showSuccessMessage = true, rethrowOnError = false } = options;

        const payload = {
          defaults: {
            plex_filter: prepareFiltersForSave(state.defaults.plex_filter),
            popularity_boosts: prepareBoostsForSave(
              state.defaults.popularity_boosts
            ),
            extras: sanitizeExtras(state.defaults.extras || {}),
          },
          playlists: state.playlists.map((playlist) => {
            const source = normalizePlaylistSource(playlist.source);
            const spotifyUrl = sanitizeSpotifyUrl(playlist.spotify_url);
            const extras = sanitizeExtras(playlist.extras || {});
            delete extras.source;
            delete extras.spotify_url;

            return {
              name: playlist.name || "",
              limit: playlist.limit ?? 0,
              artist_limit: playlist.artist_limit ?? 0,
              album_limit: playlist.album_limit ?? 0,
              year_limit: playlist.year_limit ?? 0,
              sort_by: playlist.sort_by || "",
              after_sort: playlist.after_sort || "",
              plex_filter: prepareFiltersForSave(playlist.plex_filter),
              popularity_boosts: prepareBoostsForSave(
                playlist.popularity_boosts
              ),
              extras,
              source,
              spotify_url: source === "spotify" ? spotifyUrl : "",
            };
          }),
        };

        try {
          const response = await fetch("/api/playlists", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ error: "Unknown error" }));
            throw new Error(error.error || "Failed to save playlists.");
          }

          if (showSuccessMessage) {
            showMessage("Playlists saved successfully.");
          }
        } catch (error) {
          console.error(error);
          showMessage(error.message, true);
          if (rethrowOnError && error && typeof error === "object") {
            error._fromSaveData = true;
            throw error;
          }
        }
      }

      async function savePlaylist(
        playlist,
        triggerButton,
        titleEl,
        nameInputEl,
        options = {}
      ) {
        const trimmedName = (playlist.name || "").trim();
        if (!trimmedName) {
          showMessage("Playlist name is required before saving.", true);
          return;
        }

        if (!options || typeof options !== "object") {
          options = {};
        }

        const { showSuccessMessage = true, rethrowOnError = false } = options;

        const source = normalizePlaylistSource(playlist.source);
        const spotifyUrl = sanitizeSpotifyUrl(playlist.spotify_url);
        const extras = sanitizeExtras(playlist.extras || {});
        delete extras.source;
        delete extras.spotify_url;

        const payload = {
            playlist: {
              name: trimmedName,
              limit: playlist.limit ?? 0,
              artist_limit: playlist.artist_limit ?? 0,
              album_limit: playlist.album_limit ?? 0,
              year_limit: playlist.year_limit ?? 0,
              sort_by: playlist.sort_by || "",
            after_sort: playlist.after_sort || "",
            plex_filter: prepareFiltersForSave(playlist.plex_filter),
            popularity_boosts: prepareBoostsForSave(
              playlist.popularity_boosts
            ),
            extras,
            source,
            spotify_url: source === "spotify" ? spotifyUrl : "",
          },
          original_name: playlist._originalName || "",
        };

        if (triggerButton) {
          triggerButton.disabled = true;
        }

        if (showSuccessMessage) {
          showPlaylistInlineMessage(playlist, "Saving…", { persist: true });
        }

        try {
          const response = await fetch("/api/playlists/save_single", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });

          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(result.error || "Failed to save playlist.");
          }

          const savedName = result.name || trimmedName;
          playlist._originalName = savedName;
          playlist.name = trimmedName;

          if (titleEl) {
            titleEl.textContent = trimmedName || "Untitled Playlist";
          }

          if (nameInputEl) {
            nameInputEl.value = trimmedName;
          }

          if (showSuccessMessage) {
            showPlaylistInlineMessage(
              playlist,
              `Playlist '${savedName}' saved.`,
              { isError: false }
            );
            showMessage(`Playlist '${savedName}' saved.`);
          }
        } catch (error) {
          console.error(error);
          const errorMessage = error?.message || "Failed to save playlist.";
          showPlaylistInlineMessage(playlist, errorMessage, { isError: true });
          showMessage(errorMessage, true);
          if (rethrowOnError && error && typeof error === "object") {
            error._fromSavePlaylist = true;
            throw error;
          }
        } finally {
          if (triggerButton) {
            triggerButton.disabled = false;
          }
        }
      }

      if (configBtn && configOverlay) {
        configBtn.addEventListener("click", () => {
          if (configOverlay.classList.contains("show")) {
            closeConfigMenu();
          } else {
            openConfigMenu();
          }
        });
      }

      if (configSaveBtn) {
        configSaveBtn.addEventListener("click", () => {
          saveConfigSettings();
        });
      }

      if (configRestartBtn) {
        configRestartBtn.addEventListener("click", () => {
          requestContainerRestart();
        });
      }

      [configCloseBtn, configDismissBtn].forEach((btn) => {
        if (btn) {
          btn.addEventListener("click", () => {
            closeConfigMenu();
          });
        }
      });

      if (configOverlay) {
        configOverlay.addEventListener("click", (event) => {
          if (event.target === configOverlay) {
            closeConfigMenu();
          }
        });
      }

      if (coverPickerOverlay) {
        coverPickerOverlay.addEventListener("click", (event) => {
          if (event.target === coverPickerOverlay) {
            closeCoverPicker();
          }
        });
        coverPickerOverlay.addEventListener(
          "wheel",
          (event) => {
            if (
              !coverPickerOverlay.classList.contains("show") ||
              event.defaultPrevented
            ) {
              return;
            }

            const target = event.target;
            if (
              target instanceof Element &&
              target.closest(".cover-picker-grid, .cover-picker-directory-list")
            ) {
              return;
            }

            const scrollTargets = [coverPickerGrid, coverPickerDirectories];
            const didScroll = scrollTargets.some((container) =>
              applyCoverPickerWheelScroll(event, container)
            );

            if (!didScroll) {
              event.preventDefault();
            }
          },
          { passive: false }
        );
        coverPickerOverlay.addEventListener("focusout", (event) => {
          if (!coverPickerOverlay.contains(event.relatedTarget)) {
            previewCoverCandidate(coverPickerState.selectedPath);
          }
        });
      }

      if (coverPickerCloseBtn) {
        coverPickerCloseBtn.addEventListener("click", () => {
          closeCoverPicker();
        });
      }

      if (coverPickerUpBtn) {
        coverPickerUpBtn.addEventListener("click", handleCoverPickerUp);
      }

      if (coverPickerUploadBtn && coverPickerUploadInput) {
        coverPickerUploadBtn.addEventListener("click", () => {
          coverPickerUploadInput.click();
        });
      }

      if (coverPickerUploadInput) {
        coverPickerUploadInput.addEventListener("change", (event) => {
          handleCoverPickerUploadChange(event).catch((error) => {
            console.error(error);
          });
        });
      }

      if (coverPickerClearBtn) {
        coverPickerClearBtn.addEventListener("click", () => {
          clearCoverPickerSelection();
        });
      }

      if (coverPickerGrid) {
        coverPickerGrid.addEventListener(
          "wheel",
          (event) => {
            if (!event.defaultPrevented) {
              applyCoverPickerWheelScroll(event, coverPickerGrid);
            }
          },
          { passive: false }
        );
        coverPickerGrid.addEventListener("mouseleave", () => {
          if (coverPickerOverlay?.classList.contains("show")) {
            previewCoverCandidate(coverPickerState.selectedPath);
          }
        });
      }

      if (coverPickerDirectories) {
        coverPickerDirectories.addEventListener(
          "wheel",
          (event) => {
            if (!event.defaultPrevented) {
              applyCoverPickerWheelScroll(event, coverPickerDirectories);
            }
          },
          { passive: false }
        );
      }

      if (defaultsBtn) {
        defaultsBtn.addEventListener("click", () => {
          toggleDefaultsPopover();
        });
      }

      if (defaultsCloseBtn) {
        defaultsCloseBtn.addEventListener("click", () => {
          closeDefaultsPopover();
        });
      }

      if (playlistSearchInput) {
        playlistSearchInput.addEventListener("input", (event) => {
          playlistSearchTerm = event.target.value || "";
          renderPlaylists();
        });

        playlistSearchInput.addEventListener("keydown", (event) => {
          if (event.key === "Escape" && playlistSearchTerm.trim()) {
            event.preventDefault();
            playlistSearchInput.value = "";
            playlistSearchTerm = "";
            renderPlaylists();
          }
        });
      }

      document.addEventListener("keydown", (event) => {
        if (event.key !== "Escape") {
          return;
        }

        if (
          playlistSearchInput &&
          document.activeElement === playlistSearchInput &&
          playlistSearchTerm.trim()
        ) {
          event.preventDefault();
          playlistSearchInput.value = "";
          playlistSearchTerm = "";
          renderPlaylists();
          return;
        }

        if (coverPickerOverlay?.classList.contains("show")) {
          event.preventDefault();
          closeCoverPicker();
          return;
        }

        if (configOverlay?.classList.contains("show")) {
          event.preventDefault();
          closeConfigMenu();
          return;
        }

        if (isDefaultsPopoverOpen) {
          event.preventDefault();
          closeDefaultsPopover();
        }
      });

      const addDefaultFilterBtn = document.getElementById("addDefaultFilter");
      if (addDefaultFilterBtn) {
        addDefaultFilterBtn.addEventListener("click", () => {
          state.defaults.plex_filter.push({
            field: "",
            operator: "equals",
            value: "",
            match_all: true,
            wildcard: false,
          });
          renderDefaultFilters();
        });
      }

      const addDefaultBoostBtn = document.getElementById("addDefaultBoost");
      if (addDefaultBoostBtn) {
        addDefaultBoostBtn.addEventListener("click", () => {
          if (!Array.isArray(state.defaults.popularity_boosts)) {
            state.defaults.popularity_boosts = [];
          }

          state.defaults.popularity_boosts.push(createEmptyBoostRule());
          isDefaultBoostsOpen = true;
          renderDefaultFilters();
        });
      }

      if (defaultBoostsPopout) {
        defaultBoostsPopout.addEventListener("toggle", () => {
          isDefaultBoostsOpen = defaultBoostsPopout.open;
        });
      }

      if (expandAllPlaylistsBtn) {
        expandAllPlaylistsBtn.addEventListener("click", () => {
          if (!state.playlists.length) {
            return;
          }

          state.playlists.forEach((playlist) => {
            if (!playlist) {
              return;
            }
            playlist._collapsed = false;
            updatePlaylistCollapseUi(playlist);
          });
        });
      }

      if (collapseAllPlaylistsBtn) {
        collapseAllPlaylistsBtn.addEventListener("click", () => {
          if (!state.playlists.length) {
            return;
          }

          state.playlists.forEach((playlist) => {
            if (!playlist) {
              return;
            }
            playlist._collapsed = true;
            updatePlaylistCollapseUi(playlist);
          });
        });
      }

      document.getElementById("addPlaylist").addEventListener("click", () => {
        const defaultSort = options.sort_fields?.[0]?.value || "";
          const newPlaylist = {
            name: "New Playlist",
            limit: 0,
            artist_limit: 0,
            album_limit: 0,
            year_limit: 0,
            sort_by: defaultSort,
            after_sort: "",
            plex_filter: [],
            popularity_boosts: [],
            extras: {},
          source: "plex",
          spotify_url: "",
          _originalName: "",
          _collapsed: false,
          _boostsOpen: false,
        };
        state.playlists.push(newPlaylist);
        renderPlaylists();
        scrollPlaylistIntoView(newPlaylist);
      });

      document.getElementById("reloadBtn").addEventListener("click", () => {
        loadData().then(() => showMessage("Reloaded from playlists.yml"));
      });

      document.getElementById("saveBtn").addEventListener("click", saveData);

      if (buildToggleBtn) {
        buildToggleBtn.addEventListener("click", toggleBuild);
      }

      if (playlistActivityToggle) {
        updateActivityCollapseUi();
        playlistActivityToggle.addEventListener("click", () => {
          setActivityCollapsed(!isActivityCollapsed);
        });
      } else {
        updateActivityCollapseUi();
      }

      async function handleClearActivityClick() {
        if (clearActivityBtn) {
          clearActivityBtn.disabled = true;
          clearActivityBtn.setAttribute("aria-disabled", "true");
        }

        try {
          await cancelActiveBuilds();
        } finally {
          dismissAllActivityEntries();
          updateBuildLogsUi(latestBuildStatus);
        }
      }

      if (clearActivityBtn) {
        clearActivityBtn.addEventListener("click", () => {
          handleClearActivityClick().catch((error) => {
            console.error(error);
          });
        });
      }

      const containerLifecycleEvents = ["pagehide", "beforeunload"];
      containerLifecycleEvents.forEach((eventName) => {
        window.addEventListener(eventName, () => {
          dismissAllNotifications();
        });
      });

      refreshBuildStatus();
      buildStatusTimer = setInterval(() => refreshBuildStatus(), 5000);
      loadData();
    </script>
  </body>
</html>
